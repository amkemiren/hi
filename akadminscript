-- AKAdmin Combined Script
-- Auto-generated from individual dev/admin scripts


--[[ vcbypass ]]
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "VoiceChatToggleGui"
screenGui.Parent = playerGui
screenGui.ResetOnSpawn = false

-- Create Container Frame
local container = Instance.new("Frame")
container.Name = "Container"
container.Size = UDim2.new(0, 65, 0, 65)
container.Position = UDim2.new(0.9, -30, 0.7, -30)
container.BackgroundTransparency = 1
container.Parent = screenGui

-- Create the Button
local toggleButton = Instance.new("TextButton")
toggleButton.Name = "ToggleButton"
toggleButton.Text = "🎤"
toggleButton.Size = UDim2.new(1, -5, 1, -5)
toggleButton.Position = UDim2.new(0, 2.5, 0, 2.5)
toggleButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
toggleButton.BackgroundTransparency = 0.1
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 28
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Parent = container

-- Add corner radius
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(1, 0)
buttonCorner.Parent = toggleButton

-- Create keyboard hint label
local keyHint = Instance.new("TextLabel")
keyHint.Name = "KeyHint"
keyHint.Text = "[V]"
keyHint.Size = UDim2.new(0, 30, 0, 20)
keyHint.Position = UDim2.new(0.5, -15, 1, 5)
keyHint.BackgroundTransparency = 1
keyHint.Font = Enum.Font.GothamBold
keyHint.TextSize = 14
keyHint.TextColor3 = Color3.fromRGB(255, 255, 255)
keyHint.Parent = container

-- Only show the GUI for mobile users
if not UserInputService.TouchEnabled then
    screenGui.Enabled = false
end

-- Dragging functionality
local isDragging = false
local dragStart
local startPos

local function updateDrag(input)
    local delta = input.Position - dragStart
    local position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
    
    local viewportSize = workspace.CurrentCamera.ViewportSize
    local containerSize = container.AbsoluteSize
    
    position = UDim2.new(
        position.X.Scale,
        math.clamp(position.X.Offset, 0, viewportSize.X - containerSize.X),
        position.Y.Scale,
        math.clamp(position.Y.Offset, 0, viewportSize.Y - containerSize.Y)
    )
    
    container.Position = position
end

-- Touch and mouse input handling
container.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or
       input.UserInputType == Enum.UserInputType.Touch then
        isDragging = true
        dragStart = input.Position
        startPos = container.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isDragging = false
            end
        end)
    end
end)

-- Simple hover effect
toggleButton.MouseEnter:Connect(function()
    TweenService:Create(toggleButton, TweenInfo.new(0.3), {
        Size = UDim2.new(1, -2, 1, -2),
        Position = UDim2.new(0, 1, 0, 1)
    }):Play()
end)

toggleButton.MouseLeave:Connect(function()
    TweenService:Create(toggleButton, TweenInfo.new(0.3), {
        Size = UDim2.new(1, -5, 1, -5),
        Position = UDim2.new(0, 2.5, 0, 2.5)
    }):Play()
end)

UserInputService.InputChanged:Connect(function(input)
    if isDragging and
       (input.UserInputType == Enum.UserInputType.MouseMovement or
        input.UserInputType == Enum.UserInputType.Touch) then
        updateDrag(input)
    end
end)

-- Voice chat logic
local isRunning = false
local loopTask

local function startVoiceChatLoop()
    isRunning = true
    TweenService:Create(toggleButton, TweenInfo.new(0.3), {
        BackgroundColor3 = Color3.fromRGB(170, 0, 0)
    }):Play()
    
    loopTask = coroutine.create(function()
        while isRunning do
            game:GetService("VoiceChatService"):joinVoice()
            wait(3)
        end
    end)
    coroutine.resume(loopTask)
end

local function stopVoiceChatLoop()
    isRunning = false
    TweenService:Create(toggleButton, TweenInfo.new(0.3), {
        BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    }):Play()
end

local function toggleVoiceChat()
    if isRunning then
        stopVoiceChatLoop()
    else
        startVoiceChatLoop()
    end
end

-- Connect button click
toggleButton.MouseButton1Click:Connect(toggleVoiceChat)

-- Connect keyboard input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.V then
        toggleVoiceChat()
    end
end)

-- Mobile detection to show/hide keyboard hint
if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
    keyHint.Visible = false
end


--[[ rewind ]]
-------------------------------
-- Flashback Controller (Holds C to rewind)
-- Simple version with no GUI
-------------------------------

-- Load services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Player = Players.LocalPlayer

-------------------------------
-- Variables & Parameters
-------------------------------
local flashbackRecords = {}        -- Buffer for all individual frames
local maxFlashbackTime = 60        -- Record the last 60 seconds (max)
local isRewinding = false          -- Flag for rewind mode
local rewindKey = Enum.KeyCode.C   -- Default keybind (C)

-------------------------------
-- Helper function: Get character/wait
-------------------------------
local function getCharacter()
    while not Player.Character or not Player.Character.Parent do
        Player.CharacterAdded:Wait()
    end
    return Player.Character
end

-------------------------------
-- Record character state (each frame)
-------------------------------
local function recordCurrentState(character)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local currentRecord = {
        timestamp = tick(),
        cf = (character.PrimaryPart or hrp).CFrame,
        velocity = hrp.Velocity,
        state = humanoid:GetState()
    }
    table.insert(flashbackRecords, currentRecord)

    -- Remove entries older than maxFlashbackTime seconds
    local currentTime = tick()
    while #flashbackRecords > 0 and (currentTime - flashbackRecords[1].timestamp) > maxFlashbackTime do
        table.remove(flashbackRecords, 1)
    end
end

-------------------------------
-- Apply a recorded frame
-------------------------------
local function applyRecord(character, record)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local primary = character.PrimaryPart or hrp
    primary.CFrame = record.cf
    hrp.Velocity = record.velocity

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and record.state then
        pcall(function()
            humanoid:ChangeState(record.state)
        end)
    end
end

-------------------------------
-- RenderStep: Each frame either record or rewind
-------------------------------
RunService:BindToRenderStep("FlashbackStep", 80, function(dt)
    local character = Player.Character or getCharacter()
    if not character then return end

    if isRewinding then
        -- Rewind: Apply the last recorded frame and remove it
        if #flashbackRecords > 0 then
            local record = table.remove(flashbackRecords)
            if record then
                applyRecord(character, record)
            end
        end
    else
        -- Normal: Record each frame
        recordCurrentState(character)
    end
end)

-------------------------------
-- Input: Toggle rewind mode when C is pressed/released
-------------------------------
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == rewindKey then
            isRewinding = true
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == rewindKey then
            isRewinding = false
        end
    end
end)

print("Flashback Controller loaded. Hold C to rewind time.")


--[[ bigbaseplate ]]
-- Initialize services and variables
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local TweenService = game:GetService("TweenService")

-- Create or get folder for baseplates
local baseplateFolder = Workspace:FindFirstChild("InfiniteBaseplates")
if not baseplateFolder then
    baseplateFolder = Instance.new("Folder")
    baseplateFolder.Name = "InfiniteBaseplates"
    baseplateFolder.Parent = Workspace
end

-- Define baseplate size and spacing
local baseplateSize = 2000  -- Each baseplate is 2000x2000 studs
local baseplateSpacing = 0  -- No gap between baseplates

-- Table to keep track of created baseplates by grid key (e.g. "X,Z")
local baseplateGrid = {}

-- Selected color (default grey)
local selectedColor = Color3.fromRGB(128, 128, 128)

-- Variables for freezing and restoring the avatar
local frozen = false
local originalAnchoredStates = {}  -- Table to store each BasePart's original Anchored state

-- Function to create a baseplate at a specific position with a transparent smooth look
local function addGrassBaseplate(position)
    local key = tostring(position.X) .. "," .. tostring(position.Z)
    if baseplateGrid[key] then return end

    print("Creating baseplate at position: " .. tostring(position))
    local grassBaseplate = Instance.new("Part")
    grassBaseplate.Name = "GrassBaseplate"
    grassBaseplate.Size = Vector3.new(baseplateSize, 0.05, baseplateSize)
    grassBaseplate.Anchored = true
    grassBaseplate.Material = Enum.Material.SmoothPlastic
    grassBaseplate.Color = selectedColor
    grassBaseplate.Position = position
    grassBaseplate.Transparency = 0.5
    grassBaseplate.CanCollide = true
    grassBaseplate.Parent = baseplateFolder
    
    baseplateGrid[key] = grassBaseplate
end

-- Function to create a grid of baseplates around the player
local function createBaseplatesAroundPlayer()
    local character = Player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local playerPosition = character.HumanoidRootPart.Position
    local sizeMultiplier = baseplateSize + baseplateSpacing
    
    for x = -1, 1 do
        for z = -1, 1 do
            local posX = math.floor(playerPosition.X / sizeMultiplier) * sizeMultiplier + (x * sizeMultiplier)
            local posZ = math.floor(playerPosition.Z / sizeMultiplier) * sizeMultiplier + (z * sizeMultiplier)
            local position = Vector3.new(posX, 0, posZ)
            addGrassBaseplate(position)
        end
    end
end

-- Function to freeze the entire avatar by anchoring all BaseParts
local function freezeAvatar()
    local character = Player.Character
    if character then
        originalAnchoredStates = {}  -- Reset the table
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                table.insert(originalAnchoredStates, {part = part, wasAnchored = part.Anchored})
                part.Anchored = true
            end
        end
        frozen = true
    end
end

-- Function to unfreeze the avatar by restoring each BasePart's original anchored state
local function unfreezeAvatar()
    for _, info in ipairs(originalAnchoredStates) do
        if info.part and info.part.Parent then
            info.part.Anchored = info.wasAnchored
        end
    end
    frozen = false
end

-- Function to create a professional color selection GUI
local function createColorSelectionGUI()
    -- Remove any existing GUIs first
    for _, gui in ipairs(Player.PlayerGui:GetChildren()) do
        if gui.Name == "BaseplateColorGUI" then
            gui:Destroy()
        end
    end
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "BaseplateColorGUI"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = Player.PlayerGui
    
    local backgroundBlur = Instance.new("Frame")
    backgroundBlur.Name = "BackgroundBlur"
    backgroundBlur.Size = UDim2.new(1, 0, 1, 0)
    backgroundBlur.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    backgroundBlur.BackgroundTransparency = 0.5
    backgroundBlur.BorderSizePixel = 0
    backgroundBlur.ZIndex = 10
    backgroundBlur.Parent = ScreenGui
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "ColorSelectionFrame"
    mainFrame.Size = UDim2.new(0, 400, 0, 430)
    mainFrame.Position = UDim2.new(0.5, -200, 0.5, -215)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.ZIndex = 11
    
    local cornerRadius = Instance.new("UICorner")
    cornerRadius.CornerRadius = UDim.new(0, 10)
    cornerRadius.Parent = mainFrame
    
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundTransparency = 1
    shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.ZIndex = 10
    shadow.Image = "rbxassetid://6015897843"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(49, 49, 450, 450)
    shadow.Parent = mainFrame
    
    mainFrame.Parent = ScreenGui
    
    local titleContainer = Instance.new("Frame")
    titleContainer.Name = "TitleContainer"
    titleContainer.Size = UDim2.new(1, 0, 0, 60)
    titleContainer.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    titleContainer.BorderSizePixel = 0
    titleContainer.ZIndex = 12
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleContainer
    
    local bottomFrame = Instance.new("Frame")
    bottomFrame.Size = UDim2.new(1, 0, 0.5, 0)
    bottomFrame.Position = UDim2.new(0, 0, 0.5, 0)
    bottomFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    bottomFrame.BorderSizePixel = 0
    bottomFrame.ZIndex = 11
    bottomFrame.Parent = titleContainer
    
    titleContainer.Parent = mainFrame
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -20, 1, 0)
    title.Position = UDim2.new(0, 10, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "Baseplate Color Selection"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 22
    title.Font = Enum.Font.GothamBold
    title.ZIndex = 13
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleContainer
    
    local subtitle = Instance.new("TextLabel")
    subtitle.Size = UDim2.new(1, -40, 0, 20)
    subtitle.Position = UDim2.new(0, 20, 0, 70)
    subtitle.BackgroundTransparency = 1
    subtitle.Text = "Choose a color for your infinite baseplate"
    subtitle.TextColor3 = Color3.fromRGB(200, 200, 200)
    subtitle.TextSize = 16
    subtitle.Font = Enum.Font.Gotham
    subtitle.ZIndex = 12
    subtitle.TextXAlignment = Enum.TextXAlignment.Left
    subtitle.Parent = mainFrame
    
    local colors = {
        {name = "Slate Grey", color = Color3.fromRGB(128, 128, 128)},
        {name = "Forest Green", color = Color3.fromRGB(34, 139, 34)},
        {name = "Royal Blue", color = Color3.fromRGB(65, 105, 225)},
        {name = "Crimson Red", color = Color3.fromRGB(220, 20, 60)},
        {name = "Golden Yellow", color = Color3.fromRGB(255, 215, 0)},
        {name = "Deep Purple", color = Color3.fromRGB(128, 0, 128)},
        {name = "Sunset Orange", color = Color3.fromRGB(255, 94, 77)},
        {name = "Emerald Green", color = Color3.fromRGB(80, 200, 120)},
        {name = "Electric Purple", color = Color3.fromRGB(191, 0, 255)},
        {name = "Aqua Blue", color = Color3.fromRGB(0, 255, 255)}
    }
    
    local colorContainer = Instance.new("Frame")
    colorContainer.Name = "ColorContainer"
    colorContainer.Size = UDim2.new(1, -40, 0, 270)
    colorContainer.Position = UDim2.new(0, 20, 0, 100)
    colorContainer.BackgroundTransparency = 1
    colorContainer.ZIndex = 12
    colorContainer.Parent = mainFrame
    
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0.333, -10, 0, 60)
    gridLayout.CellPadding = UDim2.new(0, 10, 0, 10)
    gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    gridLayout.Parent = colorContainer
    
    local confirmButton
    
    for i, colorInfo in ipairs(colors) do
        local button = Instance.new("Frame")
        button.Name = colorInfo.name
        button.BackgroundColor3 = colorInfo.color
        button.BorderSizePixel = 0
        button.ZIndex = 13
        button.LayoutOrder = i
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 6)
        buttonCorner.Parent = button
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0.5, 0)
        label.BackgroundTransparency = 0.6
        label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.Text = colorInfo.name
        label.TextSize = 14
        label.Font = Enum.Font.GothamSemibold
        label.ZIndex = 14
        local labelCorner = Instance.new("UICorner")
        labelCorner.CornerRadius = UDim.new(0, 4)
        labelCorner.Parent = label
        label.Parent = button
        
        local clickDetector = Instance.new("TextButton")
        clickDetector.Size = UDim2.new(1, 0, 1, 0)
        clickDetector.BackgroundTransparency = 1
        clickDetector.Text = ""
        clickDetector.ZIndex = 15
        clickDetector.Parent = button
        
        local selectionIndicator = Instance.new("Frame")
        selectionIndicator.Name = "SelectionIndicator"
        selectionIndicator.Size = UDim2.new(1, 4, 1, 4)
        selectionIndicator.Position = UDim2.new(0, -2, 0, -2)
        selectionIndicator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        selectionIndicator.BorderSizePixel = 0
        selectionIndicator.ZIndex = 12
        selectionIndicator.Visible = false
        local selectionCorner = Instance.new("UICorner")
        selectionCorner.CornerRadius = UDim.new(0, 8)
        selectionCorner.Parent = selectionIndicator
        selectionIndicator.Parent = button
        
        clickDetector.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {Size = UDim2.new(1, 0, 1, 5)}):Play()
        end)
        
        clickDetector.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {Size = UDim2.new(1, 0, 1, 0)}):Play()
        end)
        
        clickDetector.MouseButton1Click:Connect(function()
            for _, otherButton in ipairs(colorContainer:GetChildren()) do
                if otherButton:IsA("Frame") and otherButton:FindFirstChild("SelectionIndicator") then
                    otherButton.SelectionIndicator.Visible = false
                end
            end
            selectionIndicator.Visible = true
            selectedColor = colorInfo.color
            
            if confirmButton then
                local confirmTween = TweenService:Create(confirmButton, TweenInfo.new(0.3), {BackgroundColor3 = Color3.fromRGB(46, 204, 113)})
                confirmTween:Play()
            end
        end)
        
        button.Parent = colorContainer
        
        if colorInfo.color == selectedColor then
            selectionIndicator.Visible = true
        end
    end
    
    confirmButton = Instance.new("TextButton")
    confirmButton.Name = "ConfirmButton"
    confirmButton.Size = UDim2.new(0, 200, 0, 40)
    confirmButton.Position = UDim2.new(0.5, -100, 1, -60)
    confirmButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
    confirmButton.BorderSizePixel = 0
    confirmButton.Text = "Confirm Selection"
    confirmButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    confirmButton.TextSize = 16
    confirmButton.Font = Enum.Font.GothamBold
    confirmButton.ZIndex = 13
    
    local confirmCorner = Instance.new("UICorner")
    confirmCorner.CornerRadius = UDim.new(0, 8)
    confirmCorner.Parent = confirmButton
    
    confirmButton.MouseEnter:Connect(function()
        TweenService:Create(confirmButton, TweenInfo.new(0.2), {Size = UDim2.new(0, 210, 0, 45), Position = UDim2.new(0.5, -105, 1, -62)}):Play()
    end)
    
    confirmButton.MouseLeave:Connect(function()
        TweenService:Create(confirmButton, TweenInfo.new(0.2), {Size = UDim2.new(0, 200, 0, 40), Position = UDim2.new(0.5, -100, 1, -60)}):Play()
    end)
    
    confirmButton.MouseButton1Click:Connect(function()
        -- Freeze the avatar by anchoring all its BaseParts
        freezeAvatar()
        
        -- Animate GUI fade out and closing
        local fadeOutTween = TweenService:Create(backgroundBlur, TweenInfo.new(0.5), {BackgroundTransparency = 1})
        fadeOutTween:Play()
        TweenService:Create(mainFrame, TweenInfo.new(0.3), {Position = UDim2.new(0.5, -200, 1.5, 0)}):Play()
        
        -- Remove all existing baseplates and reset grid
        for _, part in ipairs(baseplateFolder:GetChildren()) do
            if part.Name == "GrassBaseplate" then
                part:Destroy()
            end
        end
        baseplateGrid = {}
        
        -- Start generating new baseplates with the selected color
        spawn(function()
            wait(0.5)
            ScreenGui:Destroy()
            spawn(function() 
                while wait(1) do
                    createBaseplatesAroundPlayer()
                end
            end)
            
            -- Wait until a new baseplate with the selected color appears, then unfreeze the avatar
            spawn(function()
                while true do
                    wait(0.1)
                    local found = false
                    for _, baseplate in ipairs(baseplateFolder:GetChildren()) do
                        if baseplate.Name == "GrassBaseplate" and baseplate.Color == selectedColor then
                            found = true
                            break
                        end
                    end
                    if found then break end
                end
                unfreezeAvatar()
            end)
        end)
    end)
    
    confirmButton.Parent = mainFrame
    
    -- Animate GUI opening
    mainFrame.Position = UDim2.new(0.5, -200, -0.5, 0)
    backgroundBlur.BackgroundTransparency = 1
    TweenService:Create(backgroundBlur, TweenInfo.new(0.5), {BackgroundTransparency = 0.5}):Play()
    TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back), {Position = UDim2.new(0.5, -200, 0.5, -215)}):Play()
end

-- Always show the color selection GUI on execution
createColorSelectionGUI()


--[[ ndsgodmode ]]
local runsvc = game:GetService("RunService")
local heartbeat = runsvc.Heartbeat
local rstepped = runsvc.RenderStepped
local players = game:GetService("Players")

local lp = players.LocalPlayer
local novel = Vector3.zero

local function noDamage(chr)
    local root = chr:WaitForChild("HumanoidRootPart")
    local humanoid = chr:WaitForChild("Humanoid")

    if root and humanoid then
        -- Prevent fall damage
        local rootCon
        rootCon = heartbeat:Connect(function()
            if not root.Parent then
                rootCon:Disconnect()
                return
            end

            local oldVel = root.AssemblyLinearVelocity
            root.AssemblyLinearVelocity = novel

            rstepped:Wait()
            root.AssemblyLinearVelocity = oldVel
        end)

        -- Prevent all other types of damage
        local healthCon
        healthCon = humanoid.HealthChanged:Connect(function(health)
            if health < humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end)

        -- Cleanup connections on character removal
        chr.AncestryChanged:Connect(function(_, parent)
            if not parent then
                if rootCon then rootCon:Disconnect() end
                if healthCon then healthCon:Disconnect() end
            end
        end)
    end
end

-- Apply no damage to the current character
if lp.Character then
    noDamage(lp.Character)
end

-- Apply no damage to future characters
lp.CharacterAdded:Connect(noDamage)


--[[ oof ]]
game.Players.LocalPlayer.Character.Humanoid.Health = 0
function log()
    deadpos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
end

game.Players.LocalPlayer.Character.Humanoid.Died:Connect(log)
game.Players.LocalPlayer.CharacterAdded:Connect(
    function(char)
        char:WaitForChild("Humanoid", 3).Died:Connect(log)
        char:WaitForChild("HumanoidRootPart", 3).CFrame = deadpos
    end
)()


--[[ fov ]]
--[[ 
    Professional FOV Changer GUI Script for Roblox
    ------------------------------------------------
    This script creates a polished, draggable GUI with:
      • A stylish header with a title.
      • A minimize button to collapse/expand the content area.
      • A close button to destroy the GUI.
      • A slider to adjust the Camera's Field of View (FOV) up to 400.
    
    Place this LocalScript in StarterGui or inside a ScreenGui.
--]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Create the ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ProfessionalFOVChangerGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- Create the main frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 250, 0, 150)
mainFrame.Position = UDim2.new(0.5, -125, 0.5, -75)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BackgroundTransparency = 0.1
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

-- Rounded corners for main frame
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Subtle border using UIStroke
local mainStroke = Instance.new("UIStroke")
mainStroke.Color = Color3.fromRGB(60, 60, 60)
mainStroke.Thickness = 2
mainStroke.Parent = mainFrame

-- Create header (drag area)
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, 30)
header.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
header.BackgroundTransparency = 0.2
header.BorderSizePixel = 0
header.Parent = mainFrame

-- Rounded corners for header
local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 8)
headerCorner.Parent = header

-- UIGradient for a sleek header look
local headerGradient = Instance.new("UIGradient")
headerGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
})
headerGradient.Parent = header

-- Title label in the header
local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -60, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "FOV Changer"
title.Font = Enum.Font.GothamSemibold
title.TextSize = 18
title.TextColor3 = Color3.new(1, 1, 1)
title.Parent = header

-- Close button in the header
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 25, 0, 25)
closeButton.Position = UDim2.new(1, -30, 0, 2)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.Text = "X"
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
closeButton.TextColor3 = Color3.new(1, 1, 1)
closeButton.BorderSizePixel = 0
closeButton.Parent = header

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 5)
closeCorner.Parent = closeButton

-- Minimize button in the header
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Size = UDim2.new(0, 25, 0, 25)
minimizeButton.Position = UDim2.new(1, -60, 0, 2)
minimizeButton.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
minimizeButton.Text = "-"
minimizeButton.Font = Enum.Font.GothamBold
minimizeButton.TextSize = 16
minimizeButton.TextColor3 = Color3.new(1, 1, 1)
minimizeButton.BorderSizePixel = 0
minimizeButton.Parent = header

local minimizeCorner = Instance.new("UICorner")
minimizeCorner.CornerRadius = UDim.new(0, 5)
minimizeCorner.Parent = minimizeButton

-- Create content frame for the slider and FOV label (collapsible)
local contentFrame = Instance.new("Frame")
contentFrame.Name = "ContentFrame"
contentFrame.Size = UDim2.new(1, 0, 1, -30)
contentFrame.Position = UDim2.new(0, 0, 0, 30)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

-- FOV display label
local fovLabel = Instance.new("TextLabel")
fovLabel.Name = "FOVLabel"
fovLabel.Size = UDim2.new(1, -20, 0, 25)
fovLabel.Position = UDim2.new(0, 10, 0, 10)
fovLabel.BackgroundTransparency = 1
fovLabel.Text = "FOV: " .. math.floor(camera.FieldOfView)
fovLabel.Font = Enum.Font.Gotham
fovLabel.TextSize = 16
fovLabel.TextColor3 = Color3.new(1, 1, 1)
fovLabel.Parent = contentFrame

-- Slider track frame
local sliderFrame = Instance.new("Frame")
sliderFrame.Name = "SliderFrame"
sliderFrame.Size = UDim2.new(0.9, 0, 0, 20)
sliderFrame.Position = UDim2.new(0.05, 0, 0, 45)
sliderFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
sliderFrame.BorderSizePixel = 0
sliderFrame.Parent = contentFrame

local sliderCorner = Instance.new("UICorner")
sliderCorner.CornerRadius = UDim.new(0, 10)
sliderCorner.Parent = sliderFrame

-- Slider knob
local sliderKnob = Instance.new("Frame")
sliderKnob.Name = "SliderKnob"
sliderKnob.Size = UDim2.new(0, 14, 1, 0)
sliderKnob.Position = UDim2.new(0, 0, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(220, 220, 220)
sliderKnob.BorderSizePixel = 0
sliderKnob.Parent = sliderFrame

local knobCorner = Instance.new("UICorner")
knobCorner.CornerRadius = UDim.new(0, 10)
knobCorner.Parent = sliderKnob

-- Slider settings: minimum remains at 70, maximum is now set to 400.
local minFOV = 70
local maxFOV = 400

-- Update FOV based on the knob's position relative to the slider track.
local function updateFOV(inputPositionX)
    local sliderAbsolutePos = sliderFrame.AbsolutePosition.X
    local sliderWidth = sliderFrame.AbsoluteSize.X
    local relativePos = math.clamp((inputPositionX - sliderAbsolutePos) / sliderWidth, 0, 1)
    local newFOV = minFOV + (maxFOV - minFOV) * relativePos
    camera.FieldOfView = newFOV
    fovLabel.Text = "FOV: " .. math.floor(newFOV)
    sliderKnob.Position = UDim2.new(relativePos, -sliderKnob.Size.X.Offset/2, 0, 0)
end

-- Slider input events
sliderFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        updateFOV(input.Position.X)
    end
end)

sliderFrame.InputChanged:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch)
       and input.UserInputState == Enum.UserInputState.Change then
        updateFOV(input.Position.X)
    end
end)

-- Draggable functionality via the header only
local dragging = false
local dragStart, startPos

header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

header.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Minimize functionality: toggles the content frame's visibility
local isMinimized = false
local originalSize = mainFrame.Size

minimizeButton.MouseButton1Click:Connect(function()
    if isMinimized then
        TweenService:Create(mainFrame, TweenInfo.new(0.25), {Size = originalSize}):Play()
        contentFrame.Visible = true
        minimizeButton.Text = "-"
    else
        TweenService:Create(mainFrame, TweenInfo.new(0.25), {Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, header.Size.Y.Offset)}):Play()
        contentFrame.Visible = false
        minimizeButton.Text = "+"
    end
    isMinimized = not isMinimized
end)

-- Close functionality: destroys the GUI
closeButton.MouseButton1Click:Connect(function()
    mainFrame:Destroy()
end)


--[[ antiall2 ]]
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

-- Function to remove dangerous objects
local function removeDangerousObjects()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and (
            obj.Name:lower():match("kill") or 
            obj.Name:lower():match("death") or 
            (obj:GetAttribute("kills") ~= nil)
        ) then
            obj:Destroy()
        end
        
        if obj:IsA("TouchTransmitter") then
            obj:Destroy()
        end
        
        if (obj:IsA("Script") or obj:IsA("LocalScript")) and (
            obj.Name:lower():match("kill") or
            obj.Name:lower():match("death") or 
            obj.Name:lower():match("damage")
        ) then
            obj:Destroy()
        end
    end
end

-- Create GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TeleportGUI"
screenGui.ResetOnSpawn = false
local button = Instance.new("TextButton")

button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(0.95, -30, 0.5, -30)
button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
button.BackgroundTransparency = 0.2
button.Text = "v"
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.TextSize = 18
button.Font = Enum.Font.GothamBlack
button.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = button

-- Dragging functionality
local dragging = false
local dragInput
local dragStart
local startPos

local function updateInput(input)
    local delta = input.Position - dragStart
    button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = button.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        updateInput(input)
    end
end)

-- Freeze and unfreeze functions
local function freezeCharacter(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
end

local function unfreezeCharacter(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
    end
end

-- Safe teleport function
local function safeTeleport()
    local player = Players.LocalPlayer
    local character = player.Character
    if character then
        removeDangerousObjects()
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        local originalCFrame = humanoidRootPart.CFrame
        
        TweenService:Create(button, TweenInfo.new(0.1), {
            Size = UDim2.new(0, 54, 0, 54),
            Position = button.Position + UDim2.new(0, 3, 0, 3)
        }):Play()
        
        -- Freeze character
        freezeCharacter(character)
        
        -- Teleport sideways (90-degree rotation on the Z-axis)
        local targetRotation = CFrame.Angles(0, 0, math.rad(90))
        humanoidRootPart.CFrame = CFrame.new(4213, 0.5, 68) * targetRotation
        
        -- Wait and return with original orientation
        task.wait(0.6)
        
        -- Instantly unfreeze before teleporting back
        unfreezeCharacter(character)
        humanoidRootPart.CFrame = CFrame.new(originalCFrame.Position) * 
            CFrame.Angles(0, originalCFrame.Rotation.Y, 0)
        
        TweenService:Create(button, TweenInfo.new(0.1), {
            Size = UDim2.new(0, 60, 0, 60),
            Position = button.Position - UDim2.new(0, 3, 0, 3)
        }):Play()
    end
end

-- Button effects
button.MouseEnter:Connect(function()
    TweenService:Create(button, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(60, 60, 60),
        TextSize = 20
    }):Play()
end)

button.MouseLeave:Connect(function()
    TweenService:Create(button, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(40, 40, 40),
        TextSize = 18
    }):Play()
end)

button.MouseButton1Click:Connect(safeTeleport)

-- Initialize
removeDangerousObjects()
screenGui.Parent = CoreGui


--[[ fitchanger ]]
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ModifyUsername_upvr = ReplicatedStorage:WaitForChild("ModifyUsername")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local MAIN_COLOR = Color3.fromRGB(41, 53, 68)
local SECONDARY_COLOR = Color3.fromRGB(52, 152, 219)
local BUTTON_COLOR = Color3.fromRGB(46, 204, 113)
local TEXT_COLOR = Color3.fromRGB(236, 240, 241)
local SAVED_FILE = "saved_usernames.txt"
local KEYBIND_FILE = "username_keybinds.txt"

local function createRoundedCornerUI(parent)
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = parent
    return uiCorner
end

local function createStroke(parent, color, thickness)
    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = color or Color3.fromRGB(255, 255, 255)
    uiStroke.Thickness = thickness or 1
    uiStroke.Parent = parent
    return uiStroke
end

local function saveUsername(username)
    if not pcall(function() readfile(SAVED_FILE) end) then
        writefile(SAVED_FILE, username)
    else
        local existing = readfile(SAVED_FILE)
        if not string.find(existing, username.."\n") and not string.find(existing, "^"..username.."$") then
            writefile(SAVED_FILE, existing.."\n"..username)
        end
    end
end

local function deleteUsername(username)
    if pcall(function() readfile(SAVED_FILE) end) then
        local content = readfile(SAVED_FILE)
        local usernames = {}
        
        for name in string.gmatch(content, "[^\n]+") do
            if name ~= username then
                table.insert(usernames, name)
            end
        end
        
        local newContent = table.concat(usernames, "\n")
        writefile(SAVED_FILE, newContent)
        
        if pcall(function() readfile(KEYBIND_FILE) end) then
            local keybindContent = readfile(KEYBIND_FILE)
            local lines = {}
            
            for line in string.gmatch(keybindContent, "[^\n]+") do
                local storedUsername = line:match("^(.-):")
                if storedUsername ~= username then
                    table.insert(lines, line)
                end
            end
            
            writefile(KEYBIND_FILE, table.concat(lines, "\n"))
        end
    end
end

local function loadUsernames()
    if pcall(function() readfile(SAVED_FILE) end) then
        local content = readfile(SAVED_FILE)
        local usernames = {}
        
        for username in string.gmatch(content, "[^\n]+") do
            if username and username ~= "" then
                table.insert(usernames, username)
            end
        end
        
        return usernames
    else
        return {}
    end
end

local function saveKeybind(username, keyCode)
    local content = ""
    if pcall(function() content = readfile(KEYBIND_FILE) end) then
        local lines = {}
        for line in string.gmatch(content, "[^\n]+") do
            local storedUsername = line:match("^(.-):")
            if storedUsername ~= username then
                table.insert(lines, line)
            end
        end
        content = table.concat(lines, "\n")
        if #content > 0 then content = content .. "\n" end
    end
    
    content = content .. username .. ":" .. tostring(keyCode.Value)
    writefile(KEYBIND_FILE, content)
end

local function getKeybindForUsername(username)
    if pcall(function() readfile(KEYBIND_FILE) end) then
        local content = readfile(KEYBIND_FILE)
        
        for line in string.gmatch(content, "[^\n]+") do
            local storedUsername, keyCodeValue = line:match("^(.-):(%d+)$")
            if storedUsername == username then
                return tonumber(keyCodeValue)
            end
        end
    end
    return nil
end

local function loadKeybinds()
    local keybinds = {}
    if pcall(function() readfile(KEYBIND_FILE) end) then
        local content = readfile(KEYBIND_FILE)
        
        for line in string.gmatch(content, "[^\n]+") do
            local username, keyCodeValue = line:match("^(.-):(%d+)$")
            if username and keyCodeValue then
                keybinds[tonumber(keyCodeValue)] = username
            end
        end
    end
    return keybinds
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "UsernameModifierGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.Size = UDim2.new(0, 320, 0, 400)
frame.Position = UDim2.new(0.5, -160, 0.5, -200)
frame.Active = true
frame.Draggable = true
frame.BackgroundColor3 = MAIN_COLOR
frame.BackgroundTransparency = 0
frame.BorderSizePixel = 0
frame.ZIndex = 2
frame.Parent = screenGui
createRoundedCornerUI(frame)

local originalFrameSize = frame.Size
local originalFramePosition = frame.Position
local isMinimized = false

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, MAIN_COLOR),
    ColorSequenceKeypoint.new(1, MAIN_COLOR:Lerp(Color3.new(0, 0, 0), 0.3))
})
gradient.Rotation = 45
gradient.Parent = frame

local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, 40)
header.Position = UDim2.new(0, 0, 0, 0)
header.BackgroundColor3 = SECONDARY_COLOR
header.BorderSizePixel = 0
header.ZIndex = 3
header.Parent = frame

local headerCorner = createRoundedCornerUI(header)
headerCorner.CornerRadius = UDim.new(0, 8)

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -80, 1, 0)
title.Position = UDim2.new(0, 15, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Fit Changer"
title.TextColor3 = TEXT_COLOR
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.ZIndex = 4
title.Parent = header

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Name = "MinimizeButton"
minimizeBtn.Size = UDim2.new(0, 28, 0, 28)
minimizeBtn.Position = UDim2.new(1, -70, 0, 6)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(241, 196, 15)
minimizeBtn.BorderSizePixel = 0
minimizeBtn.Text = "−"
minimizeBtn.TextColor3 = TEXT_COLOR
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 24
minimizeBtn.ZIndex = 4
minimizeBtn.Parent = header
createRoundedCornerUI(minimizeBtn)

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "CloseButton"
closeBtn.Size = UDim2.new(0, 28, 0, 28)
closeBtn.Position = UDim2.new(1, -34, 0, 6)
closeBtn.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
closeBtn.BorderSizePixel = 0
closeBtn.Text = "×"
closeBtn.TextColor3 = TEXT_COLOR
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 24
closeBtn.ZIndex = 4
closeBtn.Parent = header
createRoundedCornerUI(closeBtn)

local inputLabel = Instance.new("TextLabel")
inputLabel.Name = "InputLabel"
inputLabel.Size = UDim2.new(1, -30, 0, 20)
inputLabel.Position = UDim2.new(0, 15, 0, 50)
inputLabel.BackgroundTransparency = 1
inputLabel.Text = "Enter Username:"
inputLabel.TextColor3 = TEXT_COLOR
inputLabel.Font = Enum.Font.Gotham
inputLabel.TextSize = 14
inputLabel.TextXAlignment = Enum.TextXAlignment.Left
inputLabel.ZIndex = 3
inputLabel.Parent = frame

local inputBox = Instance.new("TextBox")
inputBox.Name = "UsernameInput"
inputBox.Size = UDim2.new(1, -30, 0, 36)
inputBox.Position = UDim2.new(0, 15, 0, 75)
inputBox.PlaceholderText = "Username"
inputBox.Text = ""
inputBox.ClearTextOnFocus = false
inputBox.BackgroundColor3 = Color3.fromRGB(52, 73, 94)
inputBox.TextColor3 = TEXT_COLOR
inputBox.Font = Enum.Font.Gotham
inputBox.TextSize = 16
inputBox.ZIndex = 3
inputBox.Parent = frame
createRoundedCornerUI(inputBox)

local modifyBtn = Instance.new("TextButton")
modifyBtn.Name = "ModifyButton"
modifyBtn.Size = UDim2.new(0.5, -22, 0, 36)
modifyBtn.Position = UDim2.new(0, 15, 0, 125)
modifyBtn.BackgroundColor3 = BUTTON_COLOR
modifyBtn.BorderSizePixel = 0
modifyBtn.Text = "Change Outfit"
modifyBtn.TextColor3 = TEXT_COLOR
modifyBtn.Font = Enum.Font.GothamBold
modifyBtn.TextSize = 16
modifyBtn.ZIndex = 3
modifyBtn.Parent = frame
createRoundedCornerUI(modifyBtn)

local useOwnBtn = Instance.new("TextButton")
useOwnBtn.Name = "UseOwnButton"
useOwnBtn.Size = UDim2.new(0.5, -22, 0, 36)
useOwnBtn.Position = UDim2.new(0.5, 7, 0, 125)
useOwnBtn.BackgroundColor3 = Color3.fromRGB(142, 68, 173)
useOwnBtn.BorderSizePixel = 0
useOwnBtn.Text = "Use My Name"
useOwnBtn.TextColor3 = TEXT_COLOR
useOwnBtn.Font = Enum.Font.GothamBold
useOwnBtn.TextSize = 16
useOwnBtn.ZIndex = 3
useOwnBtn.Parent = frame
createRoundedCornerUI(useOwnBtn)

local saveBtn = Instance.new("TextButton")
saveBtn.Name = "SaveButton"
saveBtn.Size = UDim2.new(1, -30, 0, 36)
saveBtn.Position = UDim2.new(0, 15, 0, 175)
saveBtn.BackgroundColor3 = Color3.fromRGB(52, 152, 219) 
saveBtn.BorderSizePixel = 0
saveBtn.Text = "Save Username"
saveBtn.TextColor3 = TEXT_COLOR
saveBtn.Font = Enum.Font.GothamBold
saveBtn.TextSize = 16
saveBtn.ZIndex = 3
saveBtn.Parent = frame
createRoundedCornerUI(saveBtn)

local savedLabel = Instance.new("TextLabel")
savedLabel.Name = "SavedLabel"
savedLabel.Size = UDim2.new(1, -30, 0, 20)
savedLabel.Position = UDim2.new(0, 15, 0, 225)
savedLabel.BackgroundTransparency = 1
savedLabel.Text = "Saved Usernames:"
savedLabel.TextColor3 = TEXT_COLOR
savedLabel.Font = Enum.Font.GothamBold
savedLabel.TextSize = 14
savedLabel.TextXAlignment = Enum.TextXAlignment.Left
savedLabel.ZIndex = 3
savedLabel.Parent = frame

local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "SavedUsernames"
scrollFrame.Size = UDim2.new(1, -30, 0, 140)
scrollFrame.Position = UDim2.new(0, 15, 0, 245)
scrollFrame.BackgroundColor3 = Color3.fromRGB(44, 62, 80)
scrollFrame.BackgroundTransparency = 0
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.ZIndex = 3
scrollFrame.Parent = frame
createRoundedCornerUI(scrollFrame)

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 5)
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Parent = scrollFrame

local keybindModal = Instance.new("Frame")
keybindModal.Name = "KeybindModal"
keybindModal.Size = UDim2.new(0, 250, 0, 120)
keybindModal.Position = UDim2.new(0.5, -125, 0.5, -60)
keybindModal.BackgroundColor3 = Color3.fromRGB(44, 62, 80)
keybindModal.BorderSizePixel = 0
keybindModal.Visible = false
keybindModal.ZIndex = 10
keybindModal.Parent = screenGui
createRoundedCornerUI(keybindModal)

local modalBlocker = Instance.new("Frame")
modalBlocker.Name = "ModalBlocker"
modalBlocker.Size = UDim2.new(1, 0, 1, 0)
modalBlocker.Position = UDim2.new(0, 0, 0, 0)
modalBlocker.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
modalBlocker.BackgroundTransparency = 0.5
modalBlocker.BorderSizePixel = 0
modalBlocker.Visible = false
modalBlocker.ZIndex = 9
modalBlocker.Parent = screenGui

local keybindTitle = Instance.new("TextLabel")
keybindTitle.Name = "KeybindTitle"
keybindTitle.Size = UDim2.new(1, 0, 0, 30)
keybindTitle.Position = UDim2.new(0, 0, 0, 0)
keybindTitle.BackgroundColor3 = SECONDARY_COLOR
keybindTitle.Text = "Set Keybind"
keybindTitle.TextColor3 = TEXT_COLOR
keybindTitle.Font = Enum.Font.GothamBold
keybindTitle.TextSize = 16
keybindTitle.ZIndex = 11
keybindTitle.Parent = keybindModal
createRoundedCornerUI(keybindTitle)

local keybindInstructions = Instance.new("TextLabel")
keybindInstructions.Name = "KeybindInstructions"
keybindInstructions.Size = UDim2.new(1, -20, 0, 40)
keybindInstructions.Position = UDim2.new(0, 10, 0, 40)
keybindInstructions.BackgroundTransparency = 1
keybindInstructions.Text = "Press any key to set as keybind..."
keybindInstructions.TextColor3 = TEXT_COLOR
keybindInstructions.Font = Enum.Font.Gotham
keybindInstructions.TextSize = 14
keybindInstructions.TextWrapped = true
keybindInstructions.ZIndex = 11
keybindInstructions.Parent = keybindModal

local cancelKeybindBtn = Instance.new("TextButton")
cancelKeybindBtn.Name = "CancelKeybindButton"
cancelKeybindBtn.Size = UDim2.new(1, -20, 0, 30)
cancelKeybindBtn.Position = UDim2.new(0, 10, 0, 80)
cancelKeybindBtn.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
cancelKeybindBtn.BorderSizePixel = 0
cancelKeybindBtn.Text = "Cancel"
cancelKeybindBtn.TextColor3 = TEXT_COLOR
cancelKeybindBtn.Font = Enum.Font.GothamBold
cancelKeybindBtn.TextSize = 14
cancelKeybindBtn.ZIndex = 11
cancelKeybindBtn.Parent = keybindModal
createRoundedCornerUI(cancelKeybindBtn)

local function showNotification(message, color)
    local notification = Instance.new("TextLabel")
    notification.Name = "Notification"
    notification.Size = UDim2.new(1, -30, 0, 30)
    notification.Position = UDim2.new(0, 15, 1, -40)
    notification.BackgroundColor3 = color or Color3.fromRGB(46, 204, 113)
    notification.Text = message
    notification.TextColor3 = TEXT_COLOR
    notification.Font = Enum.Font.GothamBold
    notification.TextSize = 14
    notification.ZIndex = 5
    notification.Parent = frame
    createRoundedCornerUI(notification)
    
    delay(2, function()
        for i = 1, 10 do
            notification.BackgroundTransparency = i/10
            notification.TextTransparency = i/10
            wait(0.05)
        end
        notification:Destroy()
    end)
end

local currentKeybindUsername = nil
local function showKeybindModal(username)
    currentKeybindUsername = username
    keybindTitle.Text = "Set Keybind for: " .. username
    keybindModal.Visible = true
    modalBlocker.Visible = true
    
    local connection
    connection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            saveKeybind(username, input.KeyCode)
            keybindModal.Visible = false
            modalBlocker.Visible = false
            showNotification("Keybind set for " .. username .. ": " .. input.KeyCode.Name, Color3.fromRGB(52, 152, 219))
            connection:Disconnect()
            updateSavedUsernamesList()
        end
    end)
    
    local cancelConn
    cancelConn = cancelKeybindBtn.MouseButton1Click:Connect(function()
        keybindModal.Visible = false
        modalBlocker.Visible = false
        connection:Disconnect()
        cancelConn:Disconnect()
    end)
end

local function updateSavedUsernamesList()
    for _, child in pairs(scrollFrame:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
    
    local usernames = loadUsernames()
    
    for i, username in ipairs(usernames) do
        local usernameContainer = Instance.new("Frame")
        usernameContainer.Name = "UsernameContainer_" .. i
        usernameContainer.Size = UDim2.new(1, -10, 0, 30)
        usernameContainer.BackgroundColor3 = Color3.fromRGB(52, 73, 94)
        usernameContainer.BorderSizePixel = 0
        usernameContainer.LayoutOrder = i
        usernameContainer.ZIndex = 4
        usernameContainer.Parent = scrollFrame
        createRoundedCornerUI(usernameContainer)
        
        local usernameLabel = Instance.new("TextLabel")
        usernameLabel.Name = "UsernameLabel"
        usernameLabel.Size = UDim2.new(0.45, -5, 1, 0)
        usernameLabel.Position = UDim2.new(0, 5, 0, 0)
        usernameLabel.BackgroundTransparency = 1
        usernameLabel.Text = username
        usernameLabel.TextColor3 = TEXT_COLOR
        usernameLabel.Font = Enum.Font.Gotham
        usernameLabel.TextSize = 14
        usernameLabel.TextXAlignment = Enum.TextXAlignment.Left
        usernameLabel.ZIndex = 5
        usernameLabel.Parent = usernameContainer
        
        local keyCodeValue = getKeybindForUsername(username)
        local keybindText = "Set Key"
        
        if keyCodeValue then
            for _, enum in pairs(Enum.KeyCode:GetEnumItems()) do
                if enum.Value == keyCodeValue then
                    keybindText = enum.Name
                    break
                end
            end
        end
        
        local keybindButton = Instance.new("TextButton")
        keybindButton.Name = "KeybindButton"
        keybindButton.Size = UDim2.new(0.25, -5, 1, -6)
        keybindButton.Position = UDim2.new(0.45, 0, 0, 3)
        keybindButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
        keybindButton.BorderSizePixel = 0
        keybindButton.Text = keybindText
        keybindButton.TextColor3 = TEXT_COLOR
        keybindButton.Font = Enum.Font.Gotham
        keybindButton.TextSize = 12
        keybindButton.ZIndex = 5
        keybindButton.Parent = usernameContainer
        createRoundedCornerUI(keybindButton)
        
        local deleteButton = Instance.new("TextButton")
        deleteButton.Name = "DeleteButton"
        deleteButton.Size = UDim2.new(0.25, -5, 1, -6)
        deleteButton.Position = UDim2.new(0.7, 0, 0, 3)
        deleteButton.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
        deleteButton.BorderSizePixel = 0
        deleteButton.Text = "Delete"
        deleteButton.TextColor3 = TEXT_COLOR
        deleteButton.Font = Enum.Font.Gotham
        deleteButton.TextSize = 12
        deleteButton.ZIndex = 5
        deleteButton.Parent = usernameContainer
        createRoundedCornerUI(deleteButton)
        
        usernameContainer.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                inputBox.Text = username
            end
        end)
        
        keybindButton.MouseButton1Click:Connect(function()
            showKeybindModal(username)
        end)
        
        deleteButton.MouseButton1Click:Connect(function()
            deleteUsername(username)
            updateSavedUsernamesList()
            showNotification("Deleted username: " .. username, Color3.fromRGB(231, 76, 60))
        end)
        
        usernameContainer.MouseEnter:Connect(function()
            TweenService:Create(usernameContainer, TweenInfo.new(0.3), {
                BackgroundColor3 = Color3.fromRGB(52, 73, 94):Lerp(Color3.new(1, 1, 1), 0.1)
            }):Play()
        end)
        
        usernameContainer.MouseLeave:Connect(function()
            TweenService:Create(usernameContainer, TweenInfo.new(0.3), {
                BackgroundColor3 = Color3.fromRGB(52, 73, 94)
            }):Play()
        end)
    end
    
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 5)
end

minimizeBtn.MouseButton1Click:Connect(function()
    if isMinimized then
        TweenService:Create(frame, TweenInfo.new(0.3), {
            Size = originalFrameSize,
            Position = originalFramePosition
        }):Play()
        
        for _, child in pairs(frame:GetChildren()) do
            if child.Name ~= "Header" and child:IsA("GuiObject") then
                child.Visible = true
            end
        end
        
        minimizeBtn.Text = "−"
    else
        TweenService:Create(frame, TweenInfo.new(0.3), {
            Size = UDim2.new(0, 320, 0, 40),
            Position = UDim2.new(0.5, -160, 0, 0)
        }):Play()
        
        for _, child in pairs(frame:GetChildren()) do
            if child.Name ~= "Header" and child:IsA("GuiObject") then
                child.Visible = false
            end
        end
        
        minimizeBtn.Text = "+"
    end
    
    isMinimized = not isMinimized
end)

closeBtn.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

modifyBtn.MouseButton1Click:Connect(function()
    local newUsername = inputBox.Text
    if newUsername == nil or newUsername == "" then
        showNotification("Please enter a valid username", Color3.fromRGB(231, 76, 60))
        return
    end
    
    ModifyUsername_upvr:FireServer(newUsername)
    showNotification("Outfit changed to " .. newUsername)
end)

useOwnBtn.MouseButton1Click:Connect(function()
    local myUsername = player.Name
    inputBox.Text = myUsername
    showNotification("Set to your username: " .. myUsername)
end)

saveBtn.MouseButton1Click:Connect(function()
    local newUsername = inputBox.Text
    if newUsername == nil or newUsername == "" then
        showNotification("Please enter a valid username", Color3.fromRGB(231, 76, 60))
        return
    end
    
    pcall(function()
        saveUsername(newUsername)
        updateSavedUsernamesList()
        showNotification("Username saved successfully")
    end)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.Return and inputBox:IsFocused() then
        ModifyUsername_upvr:FireServer(inputBox.Text)
        showNotification("Outfit changed to " .. inputBox.Text)
    else
        local keybinds = loadKeybinds()
        local username = keybinds[input.KeyCode.Value]
        
        if username then
            ModifyUsername_upvr:FireServer(username)
            showNotification("Outfit changed to " .. username .. " (Keybind: " .. input.KeyCode.Name .. ")")
        end
    end
end)

for _, button in pairs({modifyBtn, useOwnBtn, saveBtn, minimizeBtn}) do
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = button.BackgroundColor3:Lerp(Color3.new(1, 1, 1), 0.2)
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        local originalColor
        if button.Name == "ModifyButton" then
            originalColor = BUTTON_COLOR
        elseif button.Name == "UseOwnButton" then
            originalColor = Color3.fromRGB(142, 68, 173)
        elseif button.Name == "MinimizeButton" then
            originalColor = Color3.fromRGB(241, 196, 15)
        else
            originalColor = Color3.fromRGB(52, 152, 219)
        end
        
        TweenService:Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = originalColor
        }):Play()
    end)
end

updateSavedUsernamesList()


--[[ ftp ]]
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

-- Function to show a CoreGui notification
local function showNotification()
    StarterGui:SetCore("SendNotification", {
        Title = "Teleport Instructions",
        Text = "Press 'F' to teleport to your mouse position.",
        Duration = 5 -- Notification duration in seconds
    })
end

-- Function to safely get the player's character
local function safeGetCharacter()
    local character = Player.Character or Player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    return character, humanoidRootPart
end

-- Function to teleport to the mouse position
local function teleportToMouse()
    local character, humanoidRootPart = safeGetCharacter()
    if humanoidRootPart then
        local mousePosition = Mouse.Hit.Position
        humanoidRootPart.CFrame = CFrame.new(mousePosition + Vector3.new(0, 3, 0))
    end
end

-- Input listener for teleportation
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.F then
        teleportToMouse()
    end
end)

-- Show the notification when the script runs
showNotification()


--[[ clrchat ]]
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function chatMessage(str)
    str = tostring(str)
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local generalChannel = TextChatService:FindFirstChild("TextChannels"):FindFirstChild("RBXGeneral")
        if generalChannel then
            generalChannel:SendAsync(str)
        else
            warn("RBXGeneral channel not found!")
        end
    else
        local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest")
        if chatEvent then
            chatEvent:FireServer(str, "All")
        else
            warn("DefaultChatSystemChatEvents not found!")
        end
    end
end

local blob = "\u{000D}"
local clearMessage = ""..string.rep(blob, 197)..""


for i = 1, 5 do
    chatMessage(clearMessage) 
end



--[[ emotes ]]
local IsStudio = false

local ContextActionService = game:GetService("ContextActionService")
local HttpService = game:GetService("HttpService")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")
local AvatarEditorService = game:GetService("AvatarEditorService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

local Emotes = {}
local function AddEmote(name: string, id: IntValue, price: IntValue?)
	if not (name and id) then
		return
	end

	table.insert(Emotes, {
		["name"] = name,
		["id"] = id,
		["icon"] = "rbxthumb://type=Asset&id=".. id .."&w=150&h=150",
		["price"] = price or 0,
		["index"] = #Emotes + 1,
		["sort"] = {}
	})
end
local CurrentSort = "newestfirst"

local FavoriteOff = "rbxassetid://10651060677"
local FavoriteOn = "rbxassetid://10651061109"
local FavoritedEmotes = {}

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Emotes"
ScreenGui.DisplayOrder = 2
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = false

local BackFrame = Instance.new("Frame")
BackFrame.Size = UDim2.new(0.8, 0, 0.45, 0)
BackFrame.AnchorPoint = Vector2.new(0.5, 0.5)
BackFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
BackFrame.SizeConstraint = Enum.SizeConstraint.RelativeYY
BackFrame.BackgroundTransparency = 1
BackFrame.BorderSizePixel = 0
BackFrame.Parent = ScreenGui

local EmoteName = Instance.new("TextLabel")
EmoteName.Name = "EmoteName"
EmoteName.TextScaled = true
EmoteName.AnchorPoint = Vector2.new(0.5, 0.5)
EmoteName.Position = UDim2.new(-0.1, 0, 0.5, 0)
EmoteName.Size = UDim2.new(0.18, 0, 0.18, 0)
EmoteName.SizeConstraint = Enum.SizeConstraint.RelativeYY
EmoteName.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
EmoteName.TextColor3 = Color3.new(1, 1, 1)
EmoteName.BorderSizePixel = 0
EmoteName.Parent = BackFrame

local Corner = Instance.new("UICorner")
Corner.CornerRadius = UDim.new(0.1, 0)
Corner.Parent = EmoteName

local Loading = Instance.new("TextLabel", BackFrame)
Loading.AnchorPoint = Vector2.new(0.5, 0.5)
Loading.Text = "Loading..."
Loading.TextColor3 = Color3.new(1, 1, 1)
Loading.BackgroundColor3 = Color3.new(0, 0, 0)
Loading.TextScaled = true
Loading.BackgroundTransparency = 0.5
Loading.Size = UDim2.fromScale(0.2, 0.1)
Loading.Position = UDim2.fromScale(0.5, 0.2)
Corner:Clone().Parent = Loading

local Frame = Instance.new("ScrollingFrame")
Frame.Size = UDim2.new(1, 0, 1, 0)
Frame.CanvasSize = UDim2.new(0, 0, 0, 0)
Frame.AutomaticCanvasSize = Enum.AutomaticSize.Y
Frame.ScrollingDirection = Enum.ScrollingDirection.Y
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame.BackgroundTransparency = 1
Frame.ScrollBarThickness = 4
Frame.BorderSizePixel = 0
Frame.MouseLeave:Connect(function()
	EmoteName.Text = "Select an Emote"
end)
Frame.Parent = BackFrame

local Grid = Instance.new("UIGridLayout")
Grid.CellSize = UDim2.new(0.1, 0, 0, 0)
Grid.CellPadding = UDim2.new(0.006, 0, 0.006, 0)
Grid.SortOrder = Enum.SortOrder.LayoutOrder
Grid.Parent = Frame

local SortFrame = Instance.new("Frame")
SortFrame.Visible = false
SortFrame.BorderSizePixel = 0
SortFrame.Position = UDim2.new(1, 5, -0.125, 0)
SortFrame.Size = UDim2.new(0.2, 0, 0, 0)
SortFrame.AutomaticSize = Enum.AutomaticSize.Y
SortFrame.BackgroundTransparency = 1
Corner:Clone().Parent = SortFrame
SortFrame.Parent = BackFrame

local SortList = Instance.new("UIListLayout")
SortList.Padding = UDim.new(0.02, 0)
SortList.HorizontalAlignment = Enum.HorizontalAlignment.Center
SortList.VerticalAlignment = Enum.VerticalAlignment.Top
SortList.SortOrder = Enum.SortOrder.LayoutOrder
SortList.Parent = SortFrame

local function SortEmotes()
	for i,Emote in pairs(Emotes) do
		local EmoteButton = Frame:FindFirstChild(Emote.id)
		if not EmoteButton then
			continue
		end
		local IsFavorited = table.find(FavoritedEmotes, Emote.id)
		EmoteButton.LayoutOrder = Emote.sort[CurrentSort] + ((IsFavorited and 0) or #Emotes)
		EmoteButton.number.Text = Emote.sort[CurrentSort]
	end
end

local function createsort(order, text, sort)
	local CreatedSort = Instance.new("TextButton")
	CreatedSort.SizeConstraint = Enum.SizeConstraint.RelativeXX
	CreatedSort.Size = UDim2.new(1, 0, 0.2, 0)
	CreatedSort.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	CreatedSort.LayoutOrder = order
	CreatedSort.TextColor3 = Color3.new(1, 1, 1)
	CreatedSort.Text = text
	CreatedSort.TextScaled = true
	CreatedSort.BorderSizePixel = 0
	Corner:Clone().Parent = CreatedSort
	CreatedSort.Parent = SortFrame
	CreatedSort.MouseButton1Click:Connect(function()
		SortFrame.Visible = false
		CurrentSort = sort
		SortEmotes()
	end)
	return CreatedSort
end

createsort(1, "Newest First", "newestfirst")
createsort(2, "Oldest First", "oldestfirst")
createsort(3, "Alphabetically First", "alphabeticfirst")
createsort(4, "Alphabetically Last", "alphabeticlast")
createsort(5, "Highest Price", "highestprice")
createsort(6, "Lowest Price", "lowestprice")

local SortButton = Instance.new("TextButton")
SortButton.BorderSizePixel = 0
SortButton.AnchorPoint = Vector2.new(0.5, 0.5)
SortButton.Position = UDim2.new(0.925, -5, -0.075, 0)
SortButton.Size = UDim2.new(0.15, 0, 0.1, 0)
SortButton.TextScaled = true
SortButton.TextColor3 = Color3.new(1, 1, 1)
SortButton.BackgroundColor3 = Color3.new(0, 0, 0)
SortButton.BackgroundTransparency = 0.3
SortButton.Text = "Sort"
SortButton.MouseButton1Click:Connect(function()
	SortFrame.Visible = not SortFrame.Visible
end)
Corner:Clone().Parent = SortButton
SortButton.Parent = BackFrame

local CloseButton = Instance.new("TextButton")
CloseButton.BorderSizePixel = 0
CloseButton.AnchorPoint = Vector2.new(0.5, 0.5)
CloseButton.Position = UDim2.new(0.075, 0, -0.075, 0)
CloseButton.Size = UDim2.new(0.15, 0, 0.1, 0)
CloseButton.TextScaled = true
CloseButton.TextColor3 = Color3.new(1, 1, 1)
CloseButton.BackgroundColor3 = Color3.new(0, 0, 0)
CloseButton.BackgroundTransparency = 0.3
CloseButton.Text = "Close"
CloseButton.MouseButton1Click:Connect(function()
	ScreenGui.Enabled = false
end)
Corner:Clone().Parent = CloseButton
CloseButton.Parent = BackFrame

local SearchBar = Instance.new("TextBox")
SearchBar.BorderSizePixel = 0
SearchBar.AnchorPoint = Vector2.new(0.5, 0.5)
SearchBar.Position = UDim2.new(0.5, 0, -0.075, 0)
SearchBar.Size = UDim2.new(0.55, 0, 0.1, 0)
SearchBar.TextScaled = true
SearchBar.PlaceholderText = "Search"
SearchBar.TextColor3 = Color3.new(1, 1, 1)
SearchBar.BackgroundColor3 = Color3.new(0, 0, 0)
SearchBar.BackgroundTransparency = 0.3
SearchBar:GetPropertyChangedSignal("Text"):Connect(function()
	local text = SearchBar.Text:lower()
	local buttons = Frame:GetChildren()
	if text ~= text:sub(1,50) then
		SearchBar.Text = SearchBar.Text:sub(1,50)
		text = SearchBar.Text:lower()
	end
	if text ~= ""  then
		for i,button in pairs(buttons) do
			if button:IsA("GuiButton") then
				local name = button:GetAttribute("name"):lower()
				if name:match(text) then
					button.Visible = true
				else
					button.Visible = false
				end
			end
		end
	else
		for i,button in pairs(buttons) do
			if button:IsA("GuiButton") then
				button.Visible = true
			end
		end
	end
end)
Corner:Clone().Parent = SearchBar
SearchBar.Parent = BackFrame

local MobileButtonGui = Instance.new("ScreenGui")
MobileButtonGui.Name = "EmotesButtonGui"
MobileButtonGui.ResetOnSpawn = false
MobileButtonGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
MobileButtonGui.DisplayOrder = 1

local MobileButtonFrame = Instance.new("Frame")
MobileButtonFrame.Name = "MobileButtonFrame"
MobileButtonFrame.Size = UDim2.new(0, 35, 0, 35) 
MobileButtonFrame.Position = UDim2.new(0.93, 0, 0.4, 0)
MobileButtonFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
MobileButtonFrame.BorderSizePixel = 0
MobileButtonFrame.Active = true
MobileButtonFrame.Draggable = true

local MobileCorner = Instance.new("UICorner")
MobileCorner.CornerRadius = UDim.new(0.5, 0)
MobileCorner.Parent = MobileButtonFrame

local MobileToggleButton = Instance.new("TextButton")
MobileToggleButton.Name = "MobileToggleButton"
MobileToggleButton.Text = "😊"
MobileToggleButton.TextScaled = true
MobileToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MobileToggleButton.BackgroundTransparency = 1
MobileToggleButton.Size = UDim2.new(1, 0, 1, 0)
MobileToggleButton.Parent = MobileButtonFrame

local Shadow = Instance.new("Frame")
Shadow.Name = "Shadow"
Shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Shadow.BackgroundTransparency = 0.7
Shadow.BorderSizePixel = 0
Shadow.Size = UDim2.new(1, 4, 1, 4)
Shadow.Position = UDim2.new(0, -2, 0, -2)
Shadow.ZIndex = -1
local ShadowCorner = MobileCorner:Clone()
ShadowCorner.Parent = Shadow
Shadow.Parent = MobileButtonFrame

MobileButtonFrame.Parent = MobileButtonGui

MobileToggleButton.MouseButton1Click:Connect(function()
    ScreenGui.Enabled = not ScreenGui.Enabled
end)

local function SetupMobileButton()
    if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled then
        if LocalPlayer then
            if IsStudio then
                MobileButtonGui.Parent = LocalPlayer.PlayerGui
            else
                local SynV3 = syn and DrawingImmediate
                if (not is_sirhurt_closure) and (not SynV3) and (syn and syn.protect_gui) then
                    syn.protect_gui(MobileButtonGui)
                    MobileButtonGui.Parent = CoreGui
                elseif get_hidden_gui or gethui then
                    local hiddenUI = get_hidden_gui or gethui
                    MobileButtonGui.Parent = hiddenUI()
                else
                    MobileButtonGui.Parent = CoreGui
                end
            end
        else
            Players.PlayerAdded:Connect(function(plr)
                if plr == Players.LocalPlayer then
                    if IsStudio then
                        MobileButtonGui.Parent = plr.PlayerGui
                    else
                        MobileButtonGui.Parent = CoreGui
                    end
                end
            end)
        end
    end
end

local function openemotes(name, state, input)
	if state == Enum.UserInputState.Begin then
		ScreenGui.Enabled = not ScreenGui.Enabled
	end
end

if IsStudio then
	ContextActionService:BindActionAtPriority(
		"Emote Menu",
		openemotes,
		true,
		2001,
		Enum.KeyCode.Comma
	)
else
	ContextActionService:BindCoreActionAtPriority(
		"Emote Menu",
		openemotes,
		true,
		2001,
		Enum.KeyCode.Comma
	)
end

local inputconnect
ScreenGui:GetPropertyChangedSignal("Enabled"):Connect(function()
	if ScreenGui.Enabled == true then
		EmoteName.Text = "Select an Emote"
		SearchBar.Text = ""
		SortFrame.Visible = false
		GuiService:SetEmotesMenuOpen(false)
		inputconnect = UserInputService.InputBegan:Connect(function(input, processed)
			if not processed then
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					local mousePos = UserInputService:GetMouseLocation()
					local framePos = BackFrame.AbsolutePosition
					local frameSize = BackFrame.AbsoluteSize
					
					if mousePos.X < framePos.X or mousePos.X > framePos.X + frameSize.X or
					   mousePos.Y < framePos.Y or mousePos.Y > framePos.Y + frameSize.Y then
						ScreenGui.Enabled = false
					end
				end
			end
		end)
	else
		if inputconnect then
			inputconnect:Disconnect()
		end
	end
end)

if not IsStudio then
	GuiService.EmotesMenuOpenChanged:Connect(function(isopen)
		if isopen then
			ScreenGui.Enabled = false
		end
	end)
end

GuiService.MenuOpened:Connect(function()
	ScreenGui.Enabled = false
end)

local function IsMobile()
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled
end

if not game:IsLoaded() then
	game.Loaded:Wait()
end

if IsStudio then
	ScreenGui.Parent = LocalPlayer.PlayerGui
else
	local SynV3 = syn and DrawingImmediate
	if (not is_sirhurt_closure) and (not SynV3) and (syn and syn.protect_gui) then
		syn.protect_gui(ScreenGui)
		ScreenGui.Parent = CoreGui
	elseif get_hidden_gui or gethui then
		local hiddenUI = get_hidden_gui or gethui
		ScreenGui.Parent = hiddenUI()
	else
		ScreenGui.Parent = CoreGui
	end
	
	SetupMobileButton()
end


local function SendNotification(title, text)
	if (not IsStudio) and syn and syn.toast_notification then
		syn.toast_notification({
			Type = ToastType.Error,
			Title = title,
			Content = text
		})
	else
		StarterGui:SetCore("SendNotification", {
			Title = title,
			Text = text
		})
	end
end

local function HumanoidPlayEmote(humanoid, name, id)
	if IsStudio then
		return humanoid:PlayEmote(name)
	else
		return humanoid:PlayEmoteAndGetAnimTrackById(id)
	end
end

local function PlayEmote(name: string, id: IntValue)
	SearchBar.Text = ""
	local Humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	local Description = Humanoid and Humanoid:FindFirstChildOfClass("HumanoidDescription")
	if not Description then
		return
	end
	if LocalPlayer.Character.Humanoid.RigType ~= Enum.HumanoidRigType.R6 then
		local succ, err = pcall(function()
			HumanoidPlayEmote(Humanoid, name, id)
		end)
		if not succ then
			Description:AddEmote(name, id)
			HumanoidPlayEmote(Humanoid, name, id)
		end
	else
		SendNotification(
			"r6? lol",
			"you gotta be r15 dude"
		)
	end
end

local function WaitForChildOfClass(parent, class)
	local child = parent:FindFirstChildOfClass(class)
	while not child or child.ClassName ~= class do
		child = parent.ChildAdded:Wait()
	end
	return child
end

local params = CatalogSearchParams.new()
params.AssetTypes = {Enum.AvatarAssetType.EmoteAnimation}
params.SortType = Enum.CatalogSortType.RecentlyCreated
params.SortAggregation = Enum.CatalogSortAggregation.AllTime
params.IncludeOffSale = true
params.CreatorName = "Roblox"
params.Limit = 120

local function getCatalogPage()
	local success, catalogPage = pcall(function()
		return AvatarEditorService:SearchCatalog(params)
	end)
	if not success then
		task.wait(5)
		return getCatalogPage()
	end
	return catalogPage
end

local catalogPage = getCatalogPage()

local pages = {}

while true do
	local currentPage = catalogPage:GetCurrentPage()
	table.insert(pages, currentPage)
	if catalogPage.IsFinished then
		break
	end
	local function AdvanceToNextPage()
		local success = pcall(function()
			catalogPage:AdvanceToNextPageAsync()
		end)
		if not success then
			task.wait(5)
			return AdvanceToNextPage()
		end
	end
	AdvanceToNextPage()
end

local totalEmotes = {}
for _, page in pairs(pages) do
	for _, emote in pairs(page) do
		table.insert(totalEmotes, emote)
	end
end

for i, Emote in pairs(totalEmotes) do
	AddEmote(Emote.Name, Emote.Id, Emote.Price)
end

AddEmote("Arm Wave", 5915773155)
AddEmote("Head Banging", 5915779725)
AddEmote("Face Calisthenics", 9830731012)

Loading:Destroy()

table.sort(Emotes, function(a, b)
	return a.index < b.index
end)
for i,v in pairs(Emotes) do
	v.sort.newestfirst = i
end

table.sort(Emotes, function(a, b)
	return a.index > b.index
end)
for i,v in pairs(Emotes) do
	v.sort.oldestfirst = i
end

table.sort(Emotes, function(a, b)
	return a.name:lower() < b.name:lower()
end)
for i,v in pairs(Emotes) do
	v.sort.alphabeticfirst = i
end

table.sort(Emotes, function(a, b)
	return a.name:lower() > b.name:lower()
end)
for i,v in pairs(Emotes) do
	v.sort.alphabeticlast = i
end

table.sort(Emotes, function(a, b)
	return a.price < b.price
end)
for i,v in pairs(Emotes) do
	v.sort.lowestprice = i
end

table.sort(Emotes, function(a, b)
	return a.price > b.price
end)
for i,v in pairs(Emotes) do
	v.sort.highestprice = i
end


local function IsFileFunc(...)
	if IsStudio then
		return
	elseif isfile then
		return isfile(...)
	end
end

local function WriteFileFunc(...)
	if IsStudio then
		return
	elseif writefile then
		return writefile(...)
	end
end

local function ReadFileFunc(...)
	if IsStudio then
		return
	elseif readfile then
		return readfile(...)
	end
end

if not IsStudio then
	if IsFileFunc("FavoritedEmotes.txt") then
		if not pcall(function()
			FavoritedEmotes = HttpService:JSONDecode(ReadFileFunc("FavoritedEmotes.txt"))
		end) then
			FavoritedEmotes = {}
		end
	else
		WriteFileFunc("FavoritedEmotes.txt", HttpService:JSONEncode(FavoritedEmotes))
	end
	local UpdatedFavorites = {}
	for i,name in pairs(FavoritedEmotes) do
		if typeof(name) == "string" then
			for i,emote in pairs(Emotes) do
				if emote.name == name then
					table.insert(UpdatedFavorites, emote.id)
					break
				end
			end
		end
	end
	if #UpdatedFavorites ~= 0 then
		FavoritedEmotes = UpdatedFavorites
		WriteFileFunc("FavoritedEmotes.txt", HttpService:JSONEncode(FavoritedEmotes))
	end
end


local function CharacterAdded(Character)
	for i,v in pairs(Frame:GetChildren()) do
		if not v:IsA("UIGridLayout") then
			v:Destroy()
		end
	end
	local Humanoid = WaitForChildOfClass(Character, "Humanoid")
	local Description = Humanoid:WaitForChild("HumanoidDescription", 5) or Instance.new("HumanoidDescription", Humanoid)
	local random = Instance.new("TextButton")
	local Ratio = Instance.new("UIAspectRatioConstraint")
	Ratio.AspectType = Enum.AspectType.ScaleWithParentSize
	Ratio.Parent = random
	random.LayoutOrder = 0
	random.TextColor3 = Color3.new(1, 1, 1)
	random.BorderSizePixel = 0
	random.BackgroundTransparency = 0.5
	random.BackgroundColor3 = Color3.new(0, 0, 0)
	random.TextScaled = true
	random.Text = "Random"
	random:SetAttribute("name", "")
	Corner:Clone().Parent = random
	random.MouseButton1Click:Connect(function()
		local randomemote = Emotes[math.random(1, #Emotes)]
		PlayEmote(randomemote.name, randomemote.id)
	end)
	random.MouseEnter:Connect(function()
		EmoteName.Text = "Random"
	end)
	random.Parent = Frame
	for i,Emote in pairs(Emotes) do
		Description:AddEmote(Emote.name, Emote.id)
		local EmoteButton = Instance.new("ImageButton")
		local IsFavorited = table.find(FavoritedEmotes, Emote.id)
		EmoteButton.LayoutOrder = Emote.sort[CurrentSort] + ((IsFavorited and 0) or #Emotes)
		EmoteButton.Name = Emote.id
		EmoteButton:SetAttribute("name", Emote.name)
		Corner:Clone().Parent = EmoteButton
		EmoteButton.Image = Emote.icon
		EmoteButton.BackgroundTransparency = 0.5
		EmoteButton.BackgroundColor3 = Color3.new(0, 0, 0)
		EmoteButton.BorderSizePixel = 0
		Ratio:Clone().Parent = EmoteButton
		local EmoteNumber = Instance.new("TextLabel")
		EmoteNumber.Name = "number"
		EmoteNumber.TextScaled = true
		EmoteNumber.BackgroundTransparency = 1
		EmoteNumber.TextColor3 = Color3.new(1, 1, 1)
		EmoteNumber.BorderSizePixel = 0
		EmoteNumber.AnchorPoint = Vector2.new(0.5, 0.5)
		EmoteNumber.Size = UDim2.new(0.2, 0, 0.2, 0)
		EmoteNumber.Position = UDim2.new(0.1, 0, 0.9, 0)
		EmoteNumber.Text = Emote.sort[CurrentSort]
		EmoteNumber.TextXAlignment = Enum.TextXAlignment.Center
		EmoteNumber.TextYAlignment = Enum.TextYAlignment.Center
		local UIStroke = Instance.new("UIStroke")
		UIStroke.Transparency = 0.5
		UIStroke.Parent = EmoteNumber
		EmoteNumber.Parent = EmoteButton
		EmoteButton.Parent = Frame
		EmoteButton.MouseButton1Click:Connect(function()
			PlayEmote(Emote.name, Emote.id)
		end)
		EmoteButton.MouseEnter:Connect(function()
			EmoteName.Text = Emote.name
		end)
		local Favorite = Instance.new("ImageButton")
		Favorite.Name = "favorite"
		if table.find(FavoritedEmotes, Emote.id) then
			Favorite.Image = FavoriteOn
		else
			Favorite.Image = FavoriteOff
		end
		Favorite.AnchorPoint = Vector2.new(0.5, 0.5)
		Favorite.Size = UDim2.new(0.2, 0, 0.2, 0)
		Favorite.Position = UDim2.new(0.9, 0, 0.9, 0)
		Favorite.BorderSizePixel = 0
		Favorite.BackgroundTransparency = 1
		Favorite.Parent = EmoteButton
		Favorite.MouseButton1Click:Connect(function()
			local index = table.find(FavoritedEmotes, Emote.id)
			if index then
				table.remove(FavoritedEmotes, index)
				Favorite.Image = FavoriteOff
				EmoteButton.LayoutOrder = Emote.sort[CurrentSort] + #Emotes
			else
				table.insert(FavoritedEmotes, Emote.id)
				Favorite.Image = FavoriteOn
				EmoteButton.LayoutOrder = Emote.sort[CurrentSort]
			end
			WriteFileFunc("FavoritedEmotes.txt", HttpService:JSONEncode(FavoritedEmotes))
		end)
	end
	for i=1,9 do
		local EmoteButton = Instance.new("Frame")
		EmoteButton.LayoutOrder = 2147483647
		EmoteButton.Name = "filler"
		EmoteButton.BackgroundTransparency = 1
		EmoteButton.BorderSizePixel = 0
		Ratio:Clone().Parent = EmoteButton
		EmoteButton.Visible = true
		EmoteButton.Parent = Frame
		EmoteButton.MouseEnter:Connect(function()
			EmoteName.Text = "Select an Emote"
		end)
	end
end

if LocalPlayer.Character then
	CharacterAdded(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(CharacterAdded)


--[[ permdeath ]]
replicatesignal(game.Players.LocalPlayer.ConnectDiedSignalBackend)
wait(game.Players.RespawnTime + .1)
game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(15)


--[[ antibang ]]
-- Made by AnthonyIsntHere
-- Modified with simplified head radius detection

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Player = Players.LocalPlayer
local Character, Humanoid, RootPart, Head
local Camera = workspace.CurrentCamera
local IsVoiding = false
local IsEnabled = true

-- Create GUI elements for mobile
local function CreateMobileButton()
    local gui = Instance.new("ScreenGui")
    gui.Name = "VoidProtectionGUI"
    gui.ResetOnSpawn = false
    
    local button = Instance.new("TextButton")
    button.Name = "ToggleButton"
    button.Size = UDim2.new(0, 45, 0, 45)
    button.Position = UDim2.new(0, 20, 1, -70)
    button.AnchorPoint = Vector2.new(0, 1)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.1
    button.Text = "ON"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 14
    button.Font = Enum.Font.GothamBold
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Transparency = 0.8
    stroke.Thickness = 1
    stroke.Parent = button
    
    button.Parent = gui
    gui.Parent = Player:WaitForChild("PlayerGui")
    
    button.MouseButton1Click:Connect(function()
        IsEnabled = not IsEnabled
        button.Text = IsEnabled and "ON" or "OFF"
        button.BackgroundColor3 = IsEnabled and Color3.fromRGB(30, 30, 30) or Color3.fromRGB(180, 40, 40)
    end)
    
    return button
end

-- Simplified head-sitting detection with radius check
local function IsPlayerSittingOnHead()
    if Head then
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= Player then
                local otherCharacter = otherPlayer.Character
                if not otherCharacter then continue end
                
                local otherHumanoid = otherCharacter:FindFirstChildWhichIsA("Humanoid")
                if not otherHumanoid then continue end
                
                -- Only check if they're seated
                if otherHumanoid:GetState() ~= Enum.HumanoidStateType.Seated then continue end
                
                local otherRoot = otherCharacter:FindFirstChild("HumanoidRootPart")
                if not otherRoot then continue end
                
                -- Check if they're within radius of head/upper torso area
                local distance = (otherRoot.Position - Head.Position).Magnitude
                if distance <= 3.5 then  -- Radius check
                    return otherPlayer
                end
            end
        end
    end
    return nil
end

-- Bang animation detection
local function IsUsingBangAnimation()
    if RootPart then
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= Player then
                local otherCharacter = otherPlayer.Character
                local otherHumanoid = otherCharacter and otherCharacter:FindFirstChildWhichIsA("Humanoid")
                local otherRootPart = otherHumanoid and otherHumanoid.RootPart

                if otherRootPart and (RootPart.Position - otherRootPart.Position).Magnitude < 2 then
                    for _, animTrack in ipairs(otherHumanoid:GetPlayingAnimationTracks()) do
                        if animTrack.Animation and (animTrack.Animation.AnimationId:match("148840371") or animTrack.Animation.AnimationId:match("5918726674")) then
                            return otherPlayer
                        end
                    end
                end
            end
        end
    end
    return nil
end

-- Bypass the void limit
workspace.FallenPartsDestroyHeight = 0/0

-- Void teleport function
local function VoidTeleport()
    workspace.Camera.CameraType = Enum.CameraType.Fixed
    
    local HRoot = game:GetService("Players").LocalPlayer.Character.Humanoid.RootPart
    local Pos = HRoot.CFrame
    
    HRoot.CFrame = Pos + Vector3.new(0, -1e3, 0)
    task.wait(0.1)
    HRoot.CFrame = Pos
    
    workspace.Camera.CameraType = Enum.CameraType.Custom
end

-- Create mobile button
local mobileButton = CreateMobileButton()

-- Setup keyboard toggle
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.N then
        IsEnabled = not IsEnabled
        mobileButton.Text = IsEnabled and "ON" or "OFF"
        mobileButton.BackgroundColor3 = IsEnabled and Color3.fromRGB(30, 30, 30) or Color3.fromRGB(180, 40, 40)
    end
end)

-- Main protection loop
while true do
    if IsEnabled then
        Character = Player.Character
        if Character then
            Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
            RootPart = Character:FindFirstChild("HumanoidRootPart")
            Head = Character:FindFirstChild("Head")
            
            local sittingPlayer = IsPlayerSittingOnHead()
            local bangPlayer = IsUsingBangAnimation()
            
            if (sittingPlayer or bangPlayer) and not IsVoiding then
                IsVoiding = true
                local offender = sittingPlayer or bangPlayer
                
                -- Kill the offender
                if offender and offender.Character then
                    local offenderHumanoid = offender.Character:FindFirstChildWhichIsA("Humanoid")
                    if offenderHumanoid then
                        offenderHumanoid.Health = 0
                    end
                end
                
                -- Immediate void teleport
                VoidTeleport()
                IsVoiding = false
            end
        end
    end
    
    task.wait(0.1)
end


--[[ jerk ]]
local player = game.Players.LocalPlayer
local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")

if humanoid and humanoid.RigType == Enum.HumanoidRigType.R6 then
    loadstring(game:HttpGet("https://pastefy.app/wa3v2Vgm/raw"))() 
elseif humanoid and humanoid.RigType == Enum.HumanoidRigType.R15 then
    loadstring(game:HttpGet("https://pastefy.app/YZoglOyJ/raw"))()
end


--[[ touchmanager ]]
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer

-- Create GUI Elements
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ProfessionalTouchGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = game:WaitForChild("CoreGui")

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 300, 0, 400)
mainFrame.Position = UDim2.new(0.5, -150, 0.5, -200)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

-- Add rounded corners
local mainUICorner = Instance.new("UICorner")
mainUICorner.CornerRadius = UDim.new(0, 10)
mainUICorner.Parent = mainFrame

-- Title Bar
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleUICorner = Instance.new("UICorner")
titleUICorner.CornerRadius = UDim.new(0, 10)
titleUICorner.Parent = titleBar

-- Title Text
local titleText = Instance.new("TextLabel")
titleText.Size = UDim2.new(1, -40, 1, 0)
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "TouchInterest Manager"
titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
titleText.TextSize = 16
titleText.Font = Enum.Font.GothamBold
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = titleBar

-- Close Button
local closeButton = Instance.new("ImageButton")
closeButton.Size = UDim2.new(0, 24, 0, 24)
closeButton.Position = UDim2.new(1, -32, 0, 8)
closeButton.BackgroundTransparency = 1
closeButton.Image = "rbxassetid://7743878857"
closeButton.ImageColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Parent = titleBar

-- Search Bar
local searchBar = Instance.new("Frame")
searchBar.Size = UDim2.new(1, -20, 0, 35)
searchBar.Position = UDim2.new(0, 10, 0, 50)
searchBar.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
searchBar.BorderSizePixel = 0
searchBar.Parent = mainFrame

local searchUICorner = Instance.new("UICorner")
searchUICorner.CornerRadius = UDim.new(0, 8)
searchUICorner.Parent = searchBar

local searchBox = Instance.new("TextBox")
searchBox.Size = UDim2.new(1, -16, 1, -8)
searchBox.Position = UDim2.new(0, 8, 0, 4)
searchBox.BackgroundTransparency = 1
searchBox.Text = ""
searchBox.PlaceholderText = "Search TouchInterests..."
searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
searchBox.TextSize = 14
searchBox.Font = Enum.Font.Gotham
searchBox.Parent = searchBar


-- Scroll Container
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -20, 1, -135)
scrollFrame.Position = UDim2.new(0, 10, 0, 130)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 4
scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
scrollFrame.Parent = mainFrame

-- List Layout
local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 8)
listLayout.Parent = scrollFrame

-- Padding
local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 5)
padding.PaddingBottom = UDim.new(0, 5)
padding.Parent = scrollFrame

-- Functions
local function createTouchButton(partName, part)
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(1, 0, 0, 50)
    buttonFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    buttonFrame.BorderSizePixel = 0

    local buttonUICorner = Instance.new("UICorner")
    buttonUICorner.CornerRadius = UDim.new(0, 8)
    buttonUICorner.Parent = buttonFrame

    -- Part Name
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, -100, 1, 0)
    nameLabel.Position = UDim2.new(0, 10, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = partName
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Parent = buttonFrame

    -- Touch Button
    local touchButton = Instance.new("TextButton")
    touchButton.Size = UDim2.new(0, 80, 0, 30)
    touchButton.Position = UDim2.new(1, -90, 0.5, -15)
    touchButton.BackgroundColor3 = Color3.fromRGB(59, 130, 246)
    touchButton.BorderSizePixel = 0
    touchButton.Text = "Touch"
    touchButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    touchButton.TextSize = 14
    touchButton.Font = Enum.Font.GothamBold
    touchButton.Parent = buttonFrame

    local touchUICorner = Instance.new("UICorner")
    touchUICorner.CornerRadius = UDim.new(0, 6)
    touchUICorner.Parent = touchButton

    -- Hover Effect
    local function updateButtonColor(isHovered)
        local targetColor = isHovered and Color3.fromRGB(96, 165, 250) or Color3.fromRGB(59, 130, 246)
        local tweenInfo = TweenInfo.new(0.2)
        local tween = TweenService:Create(touchButton, tweenInfo, {BackgroundColor3 = targetColor})
        tween:Play()
    end

    touchButton.MouseEnter:Connect(function()
        updateButtonColor(true)
    end)

    touchButton.MouseLeave:Connect(function()
        updateButtonColor(false)
    end)

    -- Simulate Touch
    touchButton.MouseButton1Click:Connect(function()
        local touchInterest = part:FindFirstChild("TouchInterest")
        if touchInterest then
            firetouchinterest(part, player.Character.HumanoidRootPart, 0)
            wait()
            firetouchinterest(part, player.Character.HumanoidRootPart, 1)
        end
    end)

    return buttonFrame
end

-- Make GUI draggable
local dragging = false
local dragStart = nil
local startPos = nil

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

-- Close button functionality
closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Search functionality
local function updateSearch()
    local searchText = string.lower(searchBox.Text)
    for _, button in pairs(scrollFrame:GetChildren()) do
        if button:IsA("Frame") then
            local nameLabel = button:FindFirstChild("TextLabel")
            if nameLabel then
                button.Visible = string.find(string.lower(nameLabel.Text), searchText) ~= nil
            end
        end
    end
end

searchBox.Changed:Connect(function(prop)
    if prop == "Text" then
        updateSearch()
    end
end)

-- Load TouchInterests
local function loadTouchInterests()
    for _, object in pairs(workspace:GetDescendants()) do
        if object:FindFirstChild("TouchInterest") then
            local button = createTouchButton(object.Name, object)
            button.Parent = scrollFrame
        end
    end
end

-- Update ScrollFrame canvas size
local function updateCanvasSize()
    local contentSize = listLayout.AbsoluteContentSize
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
end

scrollFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateCanvasSize)
listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateCanvasSize)


-- Delete All Button
local deleteAllButton = Instance.new("TextButton")
deleteAllButton.Size = UDim2.new(1, -20, 0, 30)
deleteAllButton.Position = UDim2.new(0, 10, 0, 90)
deleteAllButton.BackgroundColor3 = Color3.fromRGB(220, 53, 69) -- Reddish color
deleteAllButton.BorderSizePixel = 0
deleteAllButton.Text = "Delete All TouchInterests"
deleteAllButton.TextColor3 = Color3.fromRGB(255, 255, 255)
deleteAllButton.TextSize = 14
deleteAllButton.Font = Enum.Font.GothamBold
deleteAllButton.Parent = mainFrame

local deleteAllUICorner = Instance.new("UICorner")
deleteAllUICorner.CornerRadius = UDim.new(0, 6)
deleteAllUICorner.Parent = deleteAllButton

local function updateDeleteButtonColor(isHovered)
    local targetColor = isHovered and Color3.fromRGB(244, 67, 54) or Color3.fromRGB(220, 53, 69)
    local tweenInfo = TweenInfo.new(0.2)
    local tween = TweenService:Create(deleteAllButton, tweenInfo, {BackgroundColor3 = targetColor})
    tween:Play()
end

deleteAllButton.MouseEnter:Connect(function()
    updateDeleteButtonColor(true)
end)

deleteAllButton.MouseLeave:Connect(function()
    updateDeleteButtonColor(false)
end)


-- Delete All Button Logic
deleteAllButton.MouseButton1Click:Connect(function()
	local allDescendants = workspace:GetDescendants()
	for i = 1, #allDescendants do
        local object = allDescendants[i]
        if object then
			if object:IsA("BasePart") then
				local touchInterest = object:FindFirstChild("TouchInterest")
				if touchInterest then
					touchInterest:Destroy()
				end
                -- Delete also any BasePart that has a name that could be associated with player touch
                local objectNameLower = string.lower(object.Name)
                if string.match(objectNameLower, "touch") or string.match(objectNameLower, "trigger") or string.match(objectNameLower, "area")
                    or string.match(objectNameLower, "damage") or string.match(objectNameLower, "kill") or string.match(objectNameLower, "lava") or string.match(objectNameLower, "acid") then
                   object:Destroy()
                end

            elseif object:IsA("Script") or object:IsA("LocalScript") then
                object:Destroy()
            elseif object:IsA("Fire") or object:IsA("Explosion") or object:IsA("Part") and object.Material == Enum.Material.ForceField then
                --remove any instances that could directly damage you
                object:Destroy()
            end
        end
    end
    for _, child in ipairs(scrollFrame:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
end)


-- Initialize
loadTouchInterests()
updateCanvasSize()


--[[ stopglide ]]
-- Function to adjust the physical properties of character parts
local function passePhysikAn(character)
    -- Iterate over all MeshParts and Parts in the character
    for _, teil in ipairs(character:GetDescendants()) do
        if teil:IsA("MeshPart") or teil:IsA("Part") then
            -- High values for instant stopping and constant speed
            -- Parameters: Density, Friction, Elasticity, FrictionWeight, ElasticityWeight
            local physikalischeEigenschaften = PhysicalProperties.new(5.0, 3.0, 0.05, 3.0, 0.3)
            teil.CustomPhysicalProperties = physikalischeEigenschaften
            
            -- Set linear velocity to a constant based on movement
            teil.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end
    end
end

-- Get the local player
local spieler = game.Players.LocalPlayer

-- Function to continuously update character's velocity
local function aktualisiereGeschwindigkeit(character)
    -- Monitor movement continuously
    game:GetService("RunService").Heartbeat:Connect(function()
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            local zielGeschwindigkeit
            if humanoid.MoveDirection.Magnitude < 0.1 then
                -- Stop immediately if the player tries to halt
                zielGeschwindigkeit = Vector3.new(0, 0, 0)
            else
                -- Set full speed constant when moving
                local geschwindigkeitsMultiplikator = 1
                if humanoid.WalkSpeed > 16 then -- Player is sprinting
                    geschwindigkeitsMultiplikator = 1.5
                end
                zielGeschwindigkeit = humanoid.MoveDirection.Unit * (humanoid.WalkSpeed * geschwindigkeitsMultiplikator)
            end
            
            -- Set the target speed directly for all parts
            for _, teil in ipairs(character:GetDescendants()) do
                if teil:IsA("BasePart") then
                    teil.AssemblyLinearVelocity = Vector3.new(
                        zielGeschwindigkeit.X,
                        teil.AssemblyLinearVelocity.Y,
                        zielGeschwindigkeit.Z
                    )
                end
            end
        end
    end)
end

-- Apply properties if the character already exists
if spieler.Character then
    passePhysikAn(spieler.Character)
    aktualisiereGeschwindigkeit(spieler.Character)
end

-- Apply properties when the character spawns
spieler.CharacterAdded:Connect(function(neuerCharakter)
    passePhysikAn(neuerCharakter)
    aktualisiereGeschwindigkeit(neuerCharakter)
end)


--[[ animcopy ]]
-- Services & vars
-- Services & vars
local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService  = game:GetService("UserInputService")
local TweenService      = game:GetService("TweenService")
local LocalPlayer       = Players.LocalPlayer
local RealAnimate = LocalPlayer.Character.Animate

-- Body parts to mirror
local bodyParts = {
"Head","UpperTorso","LowerTorso",
"LeftUpperArm","LeftLowerArm","LeftHand",
"RightUpperArm","RightLowerArm","RightHand",
"LeftUpperLeg","LeftLowerLeg","LeftFoot",
"RightUpperLeg","RightLowerLeg","RightFoot"
}

-- State
local ghostEnabled      = false
local originalCharacter = nil
local ghostClone        = nil
local originalCFrame    = nil
local originalAnimate   = nil
local updateConn        = nil
local preservedGuis     = {}
local selectedPlayer    = nil
local offsetDistance    = 2 -- studs
local minimized         = false

-- GUI preservation helpers
local function preserveGuis()
local pg = LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
if not pg then return end
for _, gui in ipairs(pg:GetChildren()) do
if gui:IsA("ScreenGui") and gui.Name ~= "ReanimationGui" and gui.ResetOnSpawn then
table.insert(preservedGuis, gui)
gui.ResetOnSpawn = false
end
end
end

local function restoreGuis()
for _, gui in ipairs(preservedGuis) do
if gui and gui.Parent then gui.ResetOnSpawn = true end
end
table.clear(preservedGuis)
end

-- Core sync logic: mirrors all parts with offset
local function updateRagdoll()
if not (ghostEnabled and originalCharacter and ghostClone and selectedPlayer and selectedPlayer.Character) then
if updateConn then updateConn:Disconnect() end; updateConn = nil
return
end

-- Get target and calculate offset
local tgt = selectedPlayer.Character
local hrp = tgt:FindFirstChild("HumanoidRootPart")
local rightOffset = hrp and (hrp.CFrame.RightVector * offsetDistance) or Vector3.new()

-- Make sure HumanoidRootPart is synced first for strong attachment
local originalHRP = originalCharacter:FindFirstChild("HumanoidRootPart")
if originalHRP and hrp then
    originalHRP.CFrame = hrp.CFrame + rightOffset
    originalHRP.AssemblyLinearVelocity = Vector3.zero
    originalHRP.AssemblyAngularVelocity = Vector3.zero
end

-- Update each body part with strong attachment
for _, name in ipairs(bodyParts) do
    local partO = originalCharacter:FindFirstChild(name)
    local partT = tgt:FindFirstChild(name) or hrp
    if partO and partT and partO:IsA("BasePart") and partT:IsA("BasePart") then
        partO.CFrame = partT.CFrame + rightOffset
        partO.AssemblyLinearVelocity = Vector3.zero
        partO.AssemblyAngularVelocity = Vector3.zero
    end
end

-- Instantly snap camera to player with no interpolation (IMPROVED)
if Workspace.CurrentCamera then
    local hum = originalCharacter:FindFirstChildWhichIsA("Humanoid")
    if hum then

    end
end
end

-- Enable/disable reanimation
local function setGhost(state)
ghostEnabled = state
if state then
local ch = LocalPlayer.Character
if not (ch and ch:FindFirstChildWhichIsA("Humanoid") and ch:FindFirstChild("HumanoidRootPart"))
or originalCharacter then return end

-- Store original
    originalCharacter, originalCFrame = ch, ch.HumanoidRootPart.CFrame

    -- Clone to ghost
    ch.Archivable = true
    ghostClone = ch:Clone()
    ch.Archivable = false
    ghostClone.Name = ch.Name .. "_ghost"

    -- Make ghost invisible & physics-only
    local gHum = ghostClone:FindFirstChildWhichIsA("Humanoid")
    if gHum then gHum:ChangeState(Enum.HumanoidStateType.Physics) end
    for _, d in ipairs(ghostClone:GetDescendants()) do
        if d:IsA("BasePart") then d.Transparency, d.Anchored = 1, false
        elseif d:IsA("Decal") then d.Transparency = 1
        elseif d:IsA("Accessory") then
            local h = d:FindFirstChild("Handle")
            if h then h.Transparency = 1 end
        end
    end

    -- Preserve animate script (instead of moving it)
    originalAnimate = ch:FindFirstChild("Animate")
    if originalAnimate then
        originalAnimate.Disabled = true
        originalAnimate:Clone().Parent = ghostClone
    end

    preserveGuis()
    ghostClone.Parent = Workspace
    LocalPlayer.Character = ghostClone
    
    -- Ensure camera instantly snaps to original character

    
    restoreGuis()

    if ReplicatedStorage:FindFirstChild("RagdollEvent") then
        ReplicatedStorage.RagdollEvent:FireServer()
    end

    updateConn = RunService.Heartbeat:Connect(updateRagdoll)
else
    if updateConn then updateConn:Disconnect() end; updateConn = nil
    if ReplicatedStorage:FindFirstChild("UnragdollEvent") then
        for i = 1, 3 do
            ReplicatedStorage.UnragdollEvent:FireServer()
            task.wait(0.1)
        end
    end
    
    -- Don't teleport back to original position, stay at final position
    local endCF = nil
    if ghostClone and ghostClone:FindFirstChild("HumanoidRootPart") then
        endCF = ghostClone.HumanoidRootPart.CFrame
    end
    
    -- Properly restore animations
    if originalAnimate then
        -- First re-enable the original animate script
        originalAnimate.Disabled = false
        
        -- Force animation reset by temporarily disabling and re-enabling
        task.delay(0.1, function()
            if originalAnimate and originalAnimate.Parent then
                -- Briefly disable and re-enable to reset animation state
                originalAnimate.Disabled = true
                task.wait(0.05)
                originalAnimate.Disabled = false
                
                -- Force animation playback
                local hum = originalCharacter and originalCharacter:FindFirstChildWhichIsA("Humanoid")
                if hum then
                    -- Reset animation state and trigger idle animation
                    hum:ChangeState(Enum.HumanoidStateType.Landed)
                    task.wait(0.05)
                    hum:ChangeState(Enum.HumanoidStateType.GettingUp)
                    task.wait(0.05)
                    hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                end
            end
        end)
    end
    
    if ghostClone then
        ghostClone:Destroy()
        ghostClone = nil
    end
    
    if originalCharacter then
        local root = originalCharacter:FindFirstChild("HumanoidRootPart")
        if root and endCF then
            
            root.AssemblyLinearVelocity, root.AssemblyAngularVelocity = Vector3.zero, Vector3.zero
        end
        
        local hum = originalCharacter:FindFirstChildWhichIsA("Humanoid")
        preserveGuis()
        LocalPlayer.Character = originalCharacter
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        restoreGuis()
    end
    
    originalCharacter, originalAnimate = nil, nil
end
end

-- Toggle minimize function
local function toggleMinimize(frame, content)
    minimized = not minimized
    
    -- Create tween info
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    
    -- Target size based on state
    local targetSize = minimized 
        and UDim2.new(0, 280, 0, 36)  -- Taskbar only
        or UDim2.new(0, 280, 0, 460)  -- Full size
        
    -- Create and play tween
    local sizeTween = TweenService:Create(frame, tweenInfo, {Size = targetSize})
    sizeTween:Play()
    
    -- Update content visibility after tween completes
    sizeTween.Completed:Connect(function()
        content.Visible = not minimized
    end)
    
    -- If expanding, show content immediately
    if not minimized then
        content.Visible = true
    end
end

-- Build GUI
local function makeGui()
local pg = LocalPlayer:WaitForChild("PlayerGui")
-- Remove existing GUI if present
local existingGui = pg:FindFirstChild("ReanimationGui")
if existingGui then existingGui:Destroy() end

local gui = Instance.new("ScreenGui")
gui.Name = "ReanimationGui"
gui.ResetOnSpawn = false
gui.DisplayOrder = 10
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = pg

-- Main frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 280, 0, 460)
frame.Position = UDim2.new(0, 20, 0, 50)
frame.BackgroundColor3 = Color3.fromRGB(18,18,18)
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Name = "MainFrame"
frame.Parent = gui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = frame

-- Taskbar/top bar
local taskbar = Instance.new("Frame")
taskbar.Size = UDim2.new(1, 0, 0, 36)
taskbar.Position = UDim2.new(0, 0, 0, 0)
taskbar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
taskbar.BorderSizePixel = 0
taskbar.Name = "Taskbar"
taskbar.Parent = frame

local taskbarCorner = Instance.new("UICorner")
taskbarCorner.CornerRadius = UDim.new(0, 10)
taskbarCorner.Parent = taskbar

-- Fix corners of taskbar
local taskbarFixBottom = Instance.new("Frame")
taskbarFixBottom.Size = UDim2.new(1, 0, 0, 10)
taskbarFixBottom.Position = UDim2.new(0, 0, 1, -10)
taskbarFixBottom.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
taskbarFixBottom.BorderSizePixel = 0
taskbarFixBottom.Parent = taskbar

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -90, 1, 0)  -- Reduced width to make room for minimize button
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Anim Copier"
title.TextColor3 = Color3.fromRGB(240,240,240)
title.Font = Enum.Font.GothamSemibold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = taskbar

-- Minimize button (NEW)
local minBtn = Instance.new("TextButton")
minBtn.Size = UDim2.new(0, 30, 0, 30)
minBtn.Position = UDim2.new(1, -70, 0, 3)
minBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minBtn.Text = "—"
minBtn.TextSize = 18
minBtn.Font = Enum.Font.GothamBold
minBtn.TextColor3 = Color3.fromRGB(240, 240, 240)
minBtn.BorderSizePixel = 0
minBtn.Name = "MinimizeButton"
minBtn.Parent = taskbar

local minBtnCorner = Instance.new("UICorner")
minBtnCorner.CornerRadius = UDim.new(0, 6)
minBtnCorner.Parent = minBtn

-- Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 30, 0, 30)
closeBtn.Position = UDim2.new(1, -35, 0, 3)
closeBtn.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
closeBtn.Text = "×"
closeBtn.TextSize = 24
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextColor3 = Color3.fromRGB(240, 240, 240)
closeBtn.BorderSizePixel = 0
closeBtn.Parent = taskbar

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 6)
closeBtnCorner.Parent = closeBtn

-- Content container
local content = Instance.new("Frame")
content.Size = UDim2.new(1, 0, 1, -36)
content.Position = UDim2.new(0, 0, 0, 36)
content.BackgroundTransparency = 1
content.Name = "Content"
content.Parent = frame

-- Offset slider label
local lblOffset = Instance.new("TextLabel")
lblOffset.Size = UDim2.new(1, -20, 0, 20)
lblOffset.Position = UDim2.new(0, 10, 0, 10)
lblOffset.BackgroundTransparency = 1
lblOffset.Text = string.format("Offset: %.1f studs", offsetDistance)
lblOffset.TextColor3 = Color3.fromRGB(200,200,200)
lblOffset.Font = Enum.Font.Gotham
lblOffset.TextSize = 14
lblOffset.Parent = content

-- Slider
local sliderBg = Instance.new("Frame")
sliderBg.Size = UDim2.new(1, -20, 0, 12)
sliderBg.Position = UDim2.new(0, 10, 0, 36)
sliderBg.BackgroundColor3 = Color3.fromRGB(50,50,50)
sliderBg.BorderSizePixel = 0
sliderBg.Parent = content

local sliderCorner = Instance.new("UICorner")
sliderCorner.CornerRadius = UDim.new(0, 6)
sliderCorner.Parent = sliderBg

local sliderFill = Instance.new("Frame")
sliderFill.Size = UDim2.new(offsetDistance/10, 0, 1, 0)
sliderFill.BorderSizePixel = 0
sliderFill.BackgroundColor3 = Color3.fromRGB(100,180,240)
sliderFill.Parent = sliderBg

local fillCorner = Instance.new("UICorner")
fillCorner.CornerRadius = UDim.new(0, 6)
fillCorner.Parent = sliderFill

local knob = Instance.new("Frame")
knob.Size = UDim2.new(0, 20, 0, 20)
knob.Position = UDim2.new(offsetDistance/10, -10, 0.5, -10)
knob.BackgroundColor3 = Color3.fromRGB(180,180,180)
knob.BorderSizePixel = 0
knob.Parent = sliderBg

local knobCorner = Instance.new("UICorner")
knobCorner.CornerRadius = UDim.new(0, 10)
knobCorner.Parent = knob

-- Improved slider dragging logic to prevent GUI dragging while using slider
local draggingKnob = false

knob.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        draggingKnob = true
        -- Prevent event propagation
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                draggingKnob = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if not draggingKnob then return end
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        local x = math.clamp(input.Position.X - sliderBg.AbsolutePosition.X, 0, sliderBg.AbsoluteSize.X)
        local pct = x / sliderBg.AbsoluteSize.X
        offsetDistance = math.floor((pct * 10)*10+0.5)/10
        lblOffset.Text = string.format("Offset: %.1f studs", offsetDistance)
        sliderFill.Size = UDim2.new(pct, 0, 1, 0)
        knob.Position = UDim2.new(pct, -10, 0.5, -10)
    end
end)

-- Player list container
local scroll = Instance.new("ScrollingFrame")
scroll.Name = "PlayerList"
scroll.Size = UDim2.new(1, -20, 0, 250)
scroll.Position = UDim2.new(0, 10, 0, 66)
scroll.BackgroundTransparency = 1
scroll.BorderSizePixel = 0
scroll.ScrollBarThickness = 6
scroll.ScrollingDirection = Enum.ScrollingDirection.Y
scroll.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
scroll.ElasticBehavior = Enum.ElasticBehavior.Always
scroll.Parent = content

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 6)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = scroll

-- Make sure CanvasSize updates
layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
end)

-- Populate players with thumbnails & names
local function rebuild()
    for _, child in pairs(scroll:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end
    
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer then
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(1, -10, 0, 70)
            btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
            btn.BorderSizePixel = 0
            btn.Text = ""
            btn.LayoutOrder = pl.UserId
            btn.AutoButtonColor = true
            btn.Parent = scroll

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 6)
            btnCorner.Parent = btn

            local img = Instance.new("ImageLabel")
            img.Size = UDim2.new(0, 50, 0, 50)
            img.Position = UDim2.new(0, 10, 0.5, -25)
            img.BackgroundTransparency = 1
            img.Parent = btn
            
            spawn(function()
                pcall(function()
                    local thumb = Players:GetUserThumbnailAsync(pl.UserId,
                        Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48)
                    img.Image = thumb
                end)
            end)

            local nameLbl = Instance.new("TextLabel")
            nameLbl.Text = pl.DisplayName or pl.Name
            nameLbl.Size = UDim2.new(0, 180, 0, 28)
            nameLbl.Position = UDim2.new(0, 70, 0, 12)
            nameLbl.BackgroundTransparency = 1
            nameLbl.TextColor3 = Color3.fromRGB(240,240,240)
            nameLbl.Font = Enum.Font.GothamSemibold
            nameLbl.TextSize = 16
            nameLbl.TextXAlignment = Enum.TextXAlignment.Left
            nameLbl.Parent = btn

            local userLbl = Instance.new("TextLabel")
            userLbl.Text = "@"..pl.Name
            userLbl.Size = UDim2.new(0, 180, 0, 20)
            userLbl.Position = UDim2.new(0, 70, 0, 36)
            userLbl.BackgroundTransparency = 1
            userLbl.TextColor3 = Color3.fromRGB(200,200,200)
            userLbl.Font = Enum.Font.Gotham
            userLbl.TextSize = 12
            userLbl.TextXAlignment = Enum.TextXAlignment.Left
            userLbl.Parent = btn

            btn.MouseButton1Click:Connect(function()
                selectedPlayer = pl
                for _, c in ipairs(scroll:GetChildren()) do
                    if c:IsA("TextButton") then
                        c.BackgroundColor3 = Color3.fromRGB(40,40,40)

                    end
                end
                btn.BackgroundColor3 = Color3.fromRGB(70,70,70)
                
                
                
                -- If already enabled, instantly update camera to the new target
                if ghostEnabled and originalCharacter then
                    local hum = originalCharacter:FindFirstChildWhichIsA("Humanoid")
                    if hum and Workspace.CurrentCamera then
                    end
                end
            end)
        end
    end
    
    -- Update canvas size
    scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
end

-- Copy animation button (added new)
local btnCopy = Instance.new("TextButton")
btnCopy.Size = UDim2.new(1, -20, 0, 40)
btnCopy.Position = UDim2.new(0, 10, 1, -100)
btnCopy.Text = "Copy Target Animation"
btnCopy.Font = Enum.Font.GothamSemibold
btnCopy.TextSize = 16
btnCopy.TextColor3 = Color3.new(1,1,1)
btnCopy.BackgroundColor3 = Color3.fromRGB(33,150,243)
btnCopy.BorderSizePixel = 0
btnCopy.Visible = false  -- Initially hidden until player is selected
btnCopy.Parent = content

local btnCopyCorner = Instance.new("UICorner")
btnCopyCorner.CornerRadius = UDim.new(0, 8)
btnCopyCorner.Parent = btnCopy

btnCopy.MouseButton1Click:Connect(function()
    if not selectedPlayer then return end
    -- Logic for copying target animation would go here
    -- This is just a placeholder - implement real copy function based on game's systems
    print("Copying animation from: " .. selectedPlayer.Name)
end)

-- Toggle button
local btnToggle = Instance.new("TextButton")
btnToggle.Size = UDim2.new(1, -20, 0, 40)
btnToggle.Position = UDim2.new(0, 10, 1, -50)
btnToggle.Text = "Start Animation Copy"
btnToggle.Font = Enum.Font.GothamSemibold
btnToggle.TextSize = 16
btnToggle.TextColor3 = Color3.new(1,1,1)
btnToggle.BackgroundColor3 = Color3.fromRGB(100,100,100)
btnToggle.Transparency = 0.4
btnToggle.Active = false
btnToggle.AutoButtonColor = false
btnToggle.Parent = content

local btnCorner = Instance.new("UICorner")
btnCorner.CornerRadius = UDim.new(0, 8)
btnCorner.Parent = btnToggle

btnToggle.MouseButton1Click:Connect(function()
    if not selectedPlayer then
        btnToggle.Text = "Select a player first."
        wait(1)
        btnToggle.Text = "Start Animation Copy"
        return
     end

    setGhost(not ghostEnabled)
    btnToggle.Text = ghostEnabled and "Stop Animation Copy" or "Start Animation Copy"
    
    if not ghostEnabled then
        RealAnimate.Disabled = true
        RealAnimate.Enabled = false
        wait(0.1)
        RealAnimate.Disabled = false
        RealAnimate.Enabled = true
        wait(0.1)
        RealAnimate.Disabled = true
        RealAnimate.Enabled = false
        wait(0.1)
        RealAnimate.Disabled = false
        RealAnimate.Enabled = true
    end

    btnToggle.BackgroundColor3 = ghostEnabled
        and Color3.fromRGB(211,47,47)
        or Color3.fromRGB(76,175,80)
        if ghostEnabled then
            wait(2)
            game.Workspace.CurrentCamera.CameraSubject = selectedPlayer.Character.UpperTorso
        else
            game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
        end
end)

-- Frame dragging (avoid dragging when using slider)
local dragging, dragInput, dragStart, startPos

frame.InputBegan:Connect(function(input)
    if draggingKnob then return end  -- Skip dragging when using slider
    
    if (input.UserInputType == Enum.UserInputType.MouseButton1 or 
        input.UserInputType == Enum.UserInputType.Touch) then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

frame.InputChanged:Connect(function(input)
    if draggingKnob then return end  -- Skip dragging when using slider
    
    if input.UserInputType == Enum.UserInputType.MouseMovement or
       input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if draggingKnob then return end  -- Skip dragging when using slider
    
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- Set up minimize button behavior (NEW)
minBtn.MouseButton1Click:Connect(function()
    toggleMinimize(frame, content)
end)

closeBtn.MouseButton1Click:Connect(function()
    setGhost(false)
    gui:Destroy()
end)

-- Initialize player list
Players.PlayerAdded:Connect(rebuild)
Players.PlayerRemoving:Connect(function(pl)
    if pl == selectedPlayer then 
        selectedPlayer = nil
        btnToggle.Text = "Start Animation Copy"
        btnToggle.BackgroundColor3 = Color3.fromRGB(100,100,100)
        btnToggle.Transparency = 0.4
        btnToggle.Active = false
        btnToggle.AutoButtonColor = false
        btnCopy.Visible = false
    end
    rebuild()
end)

-- Run the initial rebuild to populate players
task.spawn(rebuild)

return gui
end

local gui = makeGui()

-- Cleanup on destroy
script.Destroying:Connect(function()
if ghostEnabled then setGhost(false) end
if gui then gui:Destroy() end
if updateConn then updateConn:Disconnect() end
end)


--[[ touchfling ]]
-- Professional-Grade Character Physics Manipulation Utility
-- Streamlined control system for character velocity and collision manipulation

-- Core Service Initialization
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Global Configuration
local Config = {
    GUI_COLORS = {
        BACKGROUND = Color3.fromRGB(25, 25, 35),
        BUTTON_OFF = Color3.fromRGB(45, 45, 65),
        BUTTON_ON = Color3.fromRGB(0, 120, 50),
        ACCENT = Color3.fromRGB(65, 105, 225),
        TEXT = Color3.fromRGB(240, 240, 240)
    },
    FLING = {
        STRENGTH = 500000,
        MOVEMENT_DELTA = 0.1
    }
}

-- State Management
local State = {
    isAlive = true,
    isResetting = false,
    flingEnabled = false,
    collisionEnabled = false,
    character = nil,
    root = nil,
    humanoid = nil,
    velocity = nil
}

-- Enhanced UI Components Creation
local function createEnhancedUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "PhysicsControlPanel"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

    -- Main Control Panel
    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 200, 0, 140)
    mainFrame.Position = UDim2.new(0.01, 0, 0.7, 0)
    mainFrame.BackgroundColor3 = Config.GUI_COLORS.BACKGROUND
    mainFrame.BorderSizePixel = 0
    mainFrame.Name = "ControlPanel"
    mainFrame.Active = true
    mainFrame.Draggable = true
    mainFrame.Parent = screenGui

    -- Title Bar
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Config.GUI_COLORS.ACCENT
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame

    local titleText = Instance.new("TextLabel")
    titleText.Size = UDim2.new(1, 0, 1, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "Physics Controller"
    titleText.TextColor3 = Config.GUI_COLORS.TEXT
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 14
    titleText.Parent = titleBar

    -- Rounded Corners
    local function addCorners(instance)
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = instance
    end

    addCorners(mainFrame)
    addCorners(titleBar)

    -- Create Toggle Button Function
    local function createToggleButton(title, position)
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0.9, 0, 0, 35)
        button.Position = position
        button.BackgroundColor3 = Config.GUI_COLORS.BUTTON_OFF
        button.Text = title
        button.TextColor3 = Config.GUI_COLORS.TEXT
        button.Font = Enum.Font.GothamSemibold
        button.TextSize = 14
        button.Parent = mainFrame
        
        local buttonStroke = Instance.new("UIStroke")
        buttonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        buttonStroke.Color = Config.GUI_COLORS.ACCENT
        buttonStroke.Thickness = 1
        buttonStroke.Parent = button
        
        addCorners(button)
        return button
    end

    -- Create Buttons
    local flingButton = createToggleButton("Fling: OFF", UDim2.new(0.05, 0, 0.3, 0))
    local collisionButton = createToggleButton("No-Clip: OFF", UDim2.new(0.05, 0, 0.65, 0))

    return {
        flingButton = flingButton,
        collisionButton = collisionButton
    }
end

-- Button State Management
local function updateButtonState(button, enabled, onText, offText)
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local goal = {
        BackgroundColor3 = enabled and Config.GUI_COLORS.BUTTON_ON or Config.GUI_COLORS.BUTTON_OFF
    }
    
    TweenService:Create(button, tweenInfo, goal):Play()
    button.Text = enabled and onText or offText
end

-- Character Management Functions
local function setupCharacter()
    State.character = Players.LocalPlayer.Character
    if State.character then
        State.root = State.character:FindFirstChild("HumanoidRootPart")
        State.humanoid = State.character:FindFirstChild("Humanoid")
        
        if State.humanoid then
            State.humanoid.Died:Connect(function()
                State.isAlive = false
            end)
        end
    end
end

-- Collision Handler
local function handleCollisions()
    if not State.collisionEnabled then return end
    
    for _, player in next, Players:GetPlayers() do
        if player ~= Players.LocalPlayer and player.Character then
            pcall(function()
                for _, part in next, player.Character:GetChildren() do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                        if part.Name == "Torso" then
                            part.Massless = true
                        end
                        part.Velocity = Vector3.new()
                        part.RotVelocity = Vector3.new()
                    end
                end
            end)
        end
    end
end

-- Fling Handler
local function handleFling()
    if not State.flingEnabled or State.isResetting or not State.isAlive then return end
    
    if not (State.character and State.character.Parent and State.root and State.root.Parent) then return end
    
    if not State.humanoid or State.humanoid.Health <= 0 then
        State.isAlive = false
        return
    end
    
    State.velocity = State.root.Velocity
    State.root.Velocity = State.velocity * Config.FLING.STRENGTH + Vector3.new(0, Config.FLING.STRENGTH, 0)
    RunService.RenderStepped:Wait()
    
    if State.character and State.character.Parent and State.root and State.root.Parent then
        State.root.Velocity = State.velocity
    end
    
    RunService.Stepped:Wait()
    
    if State.character and State.character.Parent and State.root and State.root.Parent then
        State.root.Velocity = State.velocity + Vector3.new(0, Config.FLING.MOVEMENT_DELTA, 0)
        Config.FLING.MOVEMENT_DELTA = Config.FLING.MOVEMENT_DELTA * -1
    end
end

-- Main Initialization
local function initialize()
    local ui = createEnhancedUI()
    
    -- Setup Character
    setupCharacter()
    Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        State.isResetting = true
        wait(0.1)
        if newCharacter == Players.LocalPlayer.Character then
            setupCharacter()
            State.isAlive = true
        end
        State.isResetting = false
    end)
    
    -- Button Event Handlers
    ui.flingButton.MouseButton1Click:Connect(function()
        State.flingEnabled = not State.flingEnabled
        updateButtonState(ui.flingButton, State.flingEnabled, "Fling: ON", "Fling: OFF")
    end)
    
    ui.collisionButton.MouseButton1Click:Connect(function()
        State.collisionEnabled = not State.collisionEnabled
        updateButtonState(ui.collisionButton, State.collisionEnabled, "No-Clip: ON", "No-Clip: OFF")
    end)
    
    -- Main Loop Connections
    RunService.Heartbeat:Connect(handleFling)
    RunService.Stepped:Connect(handleCollisions)
end

-- Execute Initialization
initialize()


--[[ facebang ]]
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local targetHead = nil
local targetPlayer = nil

local FOLLOW_DISTANCE = -0.7
local HEIGHT_OFFSET = 0.8
local MOVEMENT_SPEED = 0.8 -- Same as original
local THRUST_SPEED = 0.8 -- Same as original 
local THRUST_DISTANCE = 1.9 -- Same as original

-- Animation timing constants
local THRUST_FORWARD_TIME = 0.1 -- Fast like original
local THRUST_BACKWARD_TIME = 0.1 -- Fast like original
local ANIMATION_SMOOTHNESS = 60 -- Higher value = smoother animation

-- Walking detection thresholds - we'll keep these for reference but won't use them to change behavior
local WALKING_DETECTION_THRESHOLD = 0.3 -- Minimum distance to consider as walking
local POSITION_HISTORY_SIZE = 5 -- Increased for better detection
local CHECK_INTERVAL = 0.1 -- Time between walk checks in seconds

-- Variables for tracking target walking
local targetPositionHistory = {}
local targetIsWalking = false
local lastWalkCheckTime = 0

getgenv().facefuckactive = false

-- Enhanced function to completely disable all animations
local function disableAllAnimations(character)
    if not character then return end
    
    -- Disable main Animate script
    local animate = character:FindFirstChild("Animate")
    if animate then
        animate.Disabled = true
        
        -- Disable all animation tracks
        for _, child in ipairs(animate:GetChildren()) do
            if child:IsA("StringValue") then
                child.Value = ""
            end
        end
    end
    
    -- Get Humanoid and stop all current animations
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        -- Stop existing animations
        for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
            track:Destroy()
        end
        
        -- Disable default animations
        humanoid.PlatformStand = true
        humanoid.AutoRotate = false
        
        -- Force idle animation state
        humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end
    
    -- Disable individual animation controllers
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("LocalScript") and child.Name:match("Controller") then
            child.Disabled = true
        end
    end
    
    -- Set gravity to 0 to prevent falling animation
    workspace.Gravity = 0
end

-- Function to restore animations
local function enableAllAnimations(character)
    if not character then return end
    
    local animate = character:FindFirstChild("Animate")
    if animate then
        animate.Disabled = false
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
        humanoid.AutoRotate = true
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end
    
    -- Re-enable animation controllers
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("LocalScript") and child.Name:match("Controller") then
            child.Disabled = false
        end
    end
    
    workspace.Gravity = 192.2
end

-- Function to check if target is walking by analyzing position history
-- We'll still use this to track walking state, but won't change behavior based on it
local function updateTargetWalkingState(head)
    if #targetPositionHistory < POSITION_HISTORY_SIZE then
        table.insert(targetPositionHistory, head.Position)
        return false
    end
    
    -- Shift history and add new position
    table.remove(targetPositionHistory, 1)
    table.insert(targetPositionHistory, head.Position)
    
    -- Calculate total movement distance over time window
    local movementDistance = 0
    for i = 1, #targetPositionHistory - 1 do
        local segment = (targetPositionHistory[i+1] - targetPositionHistory[i]).Magnitude
        movementDistance = movementDistance + segment
    end
    
    -- Check if movement exceeds threshold
    return movementDistance > WALKING_DETECTION_THRESHOLD
end

-- Function to track player respawn and handle retargeting
local function setupCharacterTracking()
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        Character = newCharacter
        HumanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
        
        if getgenv().facefuckactive then
            disableAllAnimations(newCharacter)
            targetHead = findNearestPlayer()
            if targetHead then
                -- Reset tracking variables when retargeting
                targetPositionHistory = {}
                targetIsWalking = false
                task.spawn(function()
                    faceBang(targetHead)
                end)
            else
                print("No nearby player found!")
            end
        end
    end)
end

-- Function to find the nearest player
local function findNearestPlayer()
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
        return targetPlayer.Character.Head
    end

    local nearestPlayer = nil
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local head = player.Character:FindFirstChild("Head")
            if head then
                local distance = (HumanoidRootPart.Position - head.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestPlayer = head
                    targetPlayer = player
                end
            end
        end
    end

    if targetPlayer then
        targetPlayer.CharacterAdded:Connect(function(newCharacter)
            if getgenv().facefuckactive then
                local head = newCharacter:WaitForChild("Head")
                targetHead = head
                -- Reset tracking variables when character respawns
                targetPositionHistory = {}
                targetIsWalking = false
                faceBang(head)
            end
        end)
    end

    return nearestPlayer
end

-- Continuous animation prevention
local function setupAnimationPrevention()
    RunService.Heartbeat:Connect(function()
        if getgenv().facefuckactive and LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                -- Stop any new animations that might play
                for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                    track:Stop()
                end
                
                -- Maintain physics state
                humanoid.PlatformStand = true
                humanoid:ChangeState(Enum.HumanoidStateType.Physics)
            end
        end
    end)
end

-- Improved easing functions for smoother animation
local function easeInOutSine(t)
    return -(math.cos(math.pi * t) - 1) / 2
end

local function easeInOutQuad(t)
    return t < 0.5 and 2 * t * t or 1 - (-2 * t + 2)^2 / 2
end

-- Enhanced lerp function with easing
local function smoothLerp(start, target, alpha, easingFunc)
    local easedAlpha = easingFunc(alpha)
    return start:Lerp(target, easedAlpha)
end

-- Enhanced fast teleport for distant targets
local function fastTeleportIfDistant(currentPosition, targetPosition)
    local distance = (currentPosition.Position - targetPosition.Position).Magnitude
    
    -- If really far away, teleport closer
    if distance > 15 then
        return targetPosition * CFrame.new(0, 0, 3), true
    end
    
    return targetPosition, false
end

-- Function to get a smoothed target position to reduce jitter
local function getSmoothedTargetPosition(head)
    -- Calculate average position from history
    if #targetPositionHistory < 3 then
        return head.CFrame
    end
    
    -- Use more recent positions with higher weight
    local weightedPosition = head.Position * 0.6
    weightedPosition = weightedPosition + targetPositionHistory[#targetPositionHistory] * 0.25
    weightedPosition = weightedPosition + targetPositionHistory[#targetPositionHistory-1] * 0.15
    
    -- Create a CFrame with the averaged position but use the current rotation
    return CFrame.new(weightedPosition) * (head.CFrame - head.CFrame.Position)
end

-- Modified function for smoother thrusting animation
local function faceBang(head)
    local lastUpdate = tick()
    targetPositionHistory = {}
    targetIsWalking = false
    
    while getgenv().facefuckactive do
        if not head or not head:IsDescendantOf(workspace) then
            if targetPlayer and targetPlayer.Character then
                head = targetPlayer.Character:WaitForChild("Head")
                targetHead = head
                -- Reset tracking variables when retargeting
                targetPositionHistory = {}
                targetIsWalking = false
            else
                print("Target lost! Retargeting...")
                head = findNearestPlayer()
                if not head then
                    print("No nearby player found!")
                    task.wait(1)
                    continue
                end
            end
        end

        disableAllAnimations(LocalPlayer.Character)

        local distanceToTarget = (head.Position - HumanoidRootPart.Position).Magnitude
        local isTooFar = distanceToTarget > 10 -- Only teleport when really far
        local currentTime = tick()
        local deltaTime = currentTime - lastUpdate
        lastUpdate = currentTime
        
        -- Update walking state
        if currentTime - lastWalkCheckTime >= CHECK_INTERVAL then
            targetIsWalking = updateTargetWalkingState(head)
            lastWalkCheckTime = currentTime
        end

        -- Handle teleporting if too far away
        if isTooFar then
            local approachCFrame = head.CFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE + 1) * CFrame.Angles(0, math.rad(180), 0)
            HumanoidRootPart.CFrame = approachCFrame
            RunService.RenderStepped:Wait()
            continue
        end
        
        -- Get a smoothed target position to reduce jitter
        local smoothedHeadCFrame = getSmoothedTargetPosition(head)
        
        -- Get the base position that follows the target
        local basePosition = smoothedHeadCFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE) * CFrame.Angles(0, math.rad(180), 0)
        
        -- Perform the thrust animation from the current position
        local thrustPosition = smoothedHeadCFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE - THRUST_DISTANCE) * CFrame.Angles(0, math.rad(180), 0)
        
        -- Thrust forward with improved smoothing but faster
        local thrustStartTime = tick()
        local thrustDuration = THRUST_FORWARD_TIME
        while (tick() - thrustStartTime) < thrustDuration and getgenv().facefuckactive do
            -- Update for target movement
            smoothedHeadCFrame = getSmoothedTargetPosition(head)
            basePosition = smoothedHeadCFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE) * CFrame.Angles(0, math.rad(180), 0)
            thrustPosition = smoothedHeadCFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE - THRUST_DISTANCE) * CFrame.Angles(0, math.rad(180), 0)
            
            local progress = math.min((tick() - thrustStartTime) / thrustDuration, 1)
            
            -- Use easing function for smoother motion
            local currentThrust = smoothLerp(basePosition, thrustPosition, progress, easeInOutSine)
            HumanoidRootPart.CFrame = currentThrust
            
            -- Use RenderStepped for faster updates
            RunService.RenderStepped:Wait()
        end
        
        -- Remove pause to maintain original speed
        
        -- Thrust backward with improved smoothing but faster
        local returnStartTime = tick()
        local returnDuration = THRUST_BACKWARD_TIME
        while (tick() - returnStartTime) < returnDuration and getgenv().facefuckactive do
            -- Update for target movement
            smoothedHeadCFrame = getSmoothedTargetPosition(head)
            basePosition = smoothedHeadCFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE) * CFrame.Angles(0, math.rad(180), 0)
            thrustPosition = smoothedHeadCFrame * CFrame.new(0, HEIGHT_OFFSET, FOLLOW_DISTANCE - THRUST_DISTANCE) * CFrame.Angles(0, math.rad(180), 0)
            
            local progress = math.min((tick() - returnStartTime) / returnDuration, 1)
            
            -- Use easing function for smoother motion
            local currentReturn = smoothLerp(thrustPosition, basePosition, progress, easeInOutSine)
            HumanoidRootPart.CFrame = currentReturn
            
            -- Use RenderStepped for faster updates
            RunService.RenderStepped:Wait()
        end
    end

    enableAllAnimations(LocalPlayer.Character)
end

-- Function to toggle movement
local function toggleMovement()
    if not getgenv().facefuckactive then
        targetPlayer = nil
        targetHead = findNearestPlayer()
        
        if targetHead then
            getgenv().facefuckactive = true
            disableAllAnimations(LocalPlayer.Character)
            -- Reset tracking variables
            targetPositionHistory = {}
            targetIsWalking = false
            lastWalkCheckTime = tick()
            task.spawn(function()
                faceBang(targetHead)
            end)
        else
            print("No nearby player found!")
        end
    else
        getgenv().facefuckactive = false
        targetPlayer = nil
        targetHead = nil
        enableAllAnimations(LocalPlayer.Character)
    end
end

-- Enhanced function to create a modern GUI button
local function createMobileGUI()
    -- Create GUI for both mobile and PC users
    if PlayerGui:FindFirstChild("FaceBangGui") then
        PlayerGui.FaceBangGui:Destroy()
    end

    -- Create main ScreenGui
    local screengui = Instance.new("ScreenGui")
    screengui.Name = "FaceBangGui"
    screengui.ResetOnSpawn = false
    screengui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screengui.Parent = PlayerGui

    -- Create main container
    local shadowcontainer = Instance.new("Frame")
    shadowcontainer.Name = "ShadowContainer"
    shadowcontainer.Size = UDim2.new(0, 60, 0, 60)
    shadowcontainer.Position = UDim2.new(0.95, -30, 0.05, 30)
    shadowcontainer.BackgroundTransparency = 1
    shadowcontainer.Parent = screengui

    -- Create main button container
    local container = Instance.new("Frame")
    container.Name = "ButtonContainer"
    container.Size = UDim2.new(0, 56, 0, 56)
    container.Position = UDim2.new(0.5, 0, 0.5, 0)
    container.AnchorPoint = Vector2.new(0.5, 0.5)
    container.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
    container.BorderSizePixel = 0
    container.ZIndex = 2
    container.Parent = shadowcontainer

    -- Add corner radius to container
    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0.3, 0)
    containerCorner.Parent = container

    -- Add gradient to container
    local containerGradient = Instance.new("UIGradient")
    containerGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 60, 75)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(40, 40, 50))
    })
    containerGradient.Rotation = 45
    containerGradient.Parent = container

    -- Add stroke to container for better visibility
    local containerStroke = Instance.new("UIStroke")
    containerStroke.Color = Color3.fromRGB(70, 70, 85)
    containerStroke.Thickness = 1
    containerStroke.Parent = container
    
    -- Create button
    local button = Instance.new("TextButton")
    button.Name = "ToggleButton"
    button.Size = UDim2.new(0.85, 0, 0.85, 0)
    button.Position = UDim2.new(0.5, 0, 0.5, 0)
    button.AnchorPoint = Vector2.new(0.5, 0.5)
    button.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    button.TextColor3 = Color3.fromRGB(230, 230, 250)
    button.Text = "F"
    button.TextSize = 22
    button.Font = Enum.Font.GothamBold
    button.BorderSizePixel = 0
    button.ZIndex = 3
    button.AutoButtonColor = false
    button.Parent = container

    -- Add corner radius to button
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0.3, 0)
    buttonCorner.Parent = button

    -- Add gradient to button
    local buttonGradient = Instance.new("UIGradient")
    buttonGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 120)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 60, 90))
    })
    containerGradient.Rotation = 45
    buttonGradient.Parent = button

    -- Add stroke to button
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(100, 100, 150)
    buttonStroke.Thickness = 1
    buttonStroke.Parent = button

    -- Create status indicator
    local statusContainer = Instance.new("Frame")
    statusContainer.Name = "StatusContainer"
    statusContainer.Size = UDim2.new(0, 18, 0, 18)
    statusContainer.Position = UDim2.new(0.9, 0, 0.1, 0)
    statusContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    statusContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    statusContainer.BorderSizePixel = 0
    statusContainer.ZIndex = 4
    statusContainer.Parent = container

    -- Add corner radius to status container
    local statusContainerCorner = Instance.new("UICorner")
    statusContainerCorner.CornerRadius = UDim.new(1, 0)
    statusContainerCorner.Parent = statusContainer

    -- Add stroke to status container
    local statusContainerStroke = Instance.new("UIStroke")
    statusContainerStroke.Color = Color3.fromRGB(40, 40, 40)
    statusContainerStroke.Thickness = 1
    statusContainerStroke.Parent = statusContainer

    -- Create status indicator light
    local status = Instance.new("Frame")
    status.Name = "StatusLight"
    status.Size = UDim2.new(0.7, 0, 0.7, 0)
    status.Position = UDim2.new(0.5, 0, 0.5, 0)
    status.AnchorPoint = Vector2.new(0.5, 0.5)
    status.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
    status.BorderSizePixel = 0
    status.ZIndex = 5
    status.Parent = statusContainer

    -- Add corner radius to status light
    local statusCorner = Instance.new("UICorner")
    statusCorner.CornerRadius = UDim.new(1, 0)
    statusCorner.Parent = status

    -- Add tooltip with hotkey info (appears on hover)
    local tooltip = Instance.new("Frame")
    tooltip.Name = "Tooltip"
    tooltip.Size = UDim2.new(0, 120, 0, 30)
    tooltip.Position = UDim2.new(0, -130, 0.5, 0)
    tooltip.AnchorPoint = Vector2.new(0, 0.5)
    tooltip.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    tooltip.BorderSizePixel = 0
    tooltip.ZIndex = 10
    tooltip.Visible = false
    tooltip.Parent = container

    -- Add corner radius to tooltip
    local tooltipCorner = Instance.new("UICorner")
    tooltipCorner.CornerRadius = UDim.new(0.2, 0)
    tooltipCorner.Parent = tooltip

    -- Add tooltip text
    local tooltipText = Instance.new("TextLabel")
    tooltipText.Name = "TooltipText"
    tooltipText.Size = UDim2.new(1, -10, 1, 0)
    tooltipText.Position = UDim2.new(0.5, 0, 0.5, 0)
    tooltipText.AnchorPoint = Vector2.new(0.5, 0.5)
    tooltipText.BackgroundTransparency = 1
    tooltipText.TextColor3 = Color3.fromRGB(230, 230, 250)
    tooltipText.Text = "Hotkey: Z"
    tooltipText.TextSize = 14
    tooltipText.Font = Enum.Font.Gotham
    tooltipText.ZIndex = 11
    tooltipText.Parent = tooltip

    -- Add tooltip pointer
    local tooltipPointer = Instance.new("Frame")
    tooltipPointer.Name = "Pointer"
    tooltipPointer.Size = UDim2.new(0, 10, 0, 10)
    tooltipPointer.Position = UDim2.new(1, 0, 0.5, 0)
    tooltipPointer.AnchorPoint = Vector2.new(0.5, 0.5)
    tooltipPointer.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    tooltipPointer.BorderSizePixel = 0
    tooltipPointer.Rotation = 45
    tooltipPointer.ZIndex = 10
    tooltipPointer.Parent = tooltip

    -- Create hovering animation effect
    local floatingSequence = {
        TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        UDim2.new(0.95, -30, 0.05, 35)  -- Slightly higher position
    }
    
    local floatingTween = TweenService:Create(
        shadowcontainer,
        floatingSequence[1],
        {Position = floatingSequence[2]}
    )
    floatingTween:Play()

    -- Button hover effects
    button.MouseEnter:Connect(function()
        -- Show tooltip
        tooltip.Visible = true
        
        -- Button glow effect
        TweenService:Create(
            button,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {BackgroundColor3 = Color3.fromRGB(90, 90, 130)}
        ):Play()
        
        TweenService:Create(
            buttonGradient, 
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Offset = Vector2.new(0, -0.1)}
        ):Play()
    end)

    button.MouseLeave:Connect(function()
        -- Hide tooltip
        tooltip.Visible = false
        
        -- Restore button appearance
        TweenService:Create(
            button,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {BackgroundColor3 = Color3.fromRGB(60, 60, 80)}
        ):Play()
        
        TweenService:Create(
            buttonGradient, 
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Offset = Vector2.new(0, 0)}
        ):Play()
    end)

    -- Button press effects
    button.MouseButton1Down:Connect(function()
        TweenService:Create(
            button,
            TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.8, 0, 0.8, 0)}
        ):Play()
    end)

    button.MouseButton1Up:Connect(function()
        TweenService:Create(
            button,
            TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.85, 0, 0.85, 0)}
        ):Play()
    end)

    -- Toggle functionality
    button.MouseButton1Click:Connect(function()
        toggleMovement()
        
        -- Update status light color with animation
        local targetColor = getgenv().facefuckactive and Color3.fromRGB(80, 255, 80) or Color3.fromRGB(255, 80, 80)
        
        -- Animate status indicator
        TweenService:Create(
            status,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {BackgroundColor3 = targetColor}
        ):Play()
        
        -- Pulse animation when activated
        if getgenv().facefuckactive then
            -- Create pulse effect
            local statusPulse = TweenService:Create(
                status,
                TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
                {BackgroundTransparency = 0.3}
            )
            statusPulse:Play()
        else
            -- Stop pulsing when deactivated
            TweenService:Create(
                status,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {BackgroundTransparency = 0}
            ):Play()
        end
        
        -- Button press animation
        TweenService:Create(
            button,
            TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
            {Size = UDim2.new(0.85, 0, 0.85, 0)}
        ):Play()
    end)
    
    -- Dragable functionality for the button
    local dragStart
    local startPos
    local dragging = false
    
    shadowcontainer.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = shadowcontainer.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            shadowcontainer.Position = UDim2.new(
                startPos.X.Scale, 
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    -- Create ripple effect for button click
    local function createRipple(x, y)
        local ripple = Instance.new("Frame")
        ripple.Name = "Ripple"
        ripple.Position = UDim2.new(0, x, 0, y)
        ripple.Size = UDim2.new(0, 0, 0, 0)
        ripple.AnchorPoint = Vector2.new(0.5, 0.5)
        ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        ripple.BackgroundTransparency = 0.7
        ripple.BorderSizePixel = 0
        ripple.ZIndex = 2
        ripple.Parent = button
        
        local rippleCorner = Instance.newBridged("UICorner")
        rippleCorner.CornerRadius = UDim.new(1, 0)
        rippleCorner.Parent = ripple
        
        local maxSize = math.max(button.AbsoluteSize.X, button.AbsoluteSize.Y) * 2
        
        -- Animate ripple
        TweenService:Create(
            ripple,
            TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {
                Size = UDim2.new(0, maxSize, 0, maxSize),
                BackgroundTransparency = 1
            }
        ):Play()
        
        -- Remove after animation
        task.delay(0.5, function()
            ripple:Destroy()
        end)
    end
    
    button.MouseButton1Down:Connect(function(x, y)
        local buttonPosition = button.AbsolutePosition
        local relativeX = x - buttonPosition.X
        local relativeY = y - buttonPosition.Y
        createRipple(relativeX, relativeY)
    end)
    
    -- Initialize status indicator
    if getgenv().facefuckactive then
        status.BackgroundColor3 = Color3.fromRGB(80, 255, 80)
        
        -- Create active pulse animation
        local statusPulse = TweenService:Create(
            status,
            TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            {BackgroundTransparency = 0.3}
        )
        statusPulse:Play()
    end
    
    -- Add notification for feedback
    local function showNotification(message, duration)
        local notification = Instance.new("Frame")
        notification.Name = "Notification"
        notification.Size = UDim2.new(0, 200, 0, 40)
        notification.Position = UDim2.new(0.5, 0, 0.8, 0)
        notification.AnchorPoint = Vector2.new(0.5, 0.5)
        notification.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
        notification.BorderSizePixel = 0
        notification.ZIndex = 20
        notification.Parent = screengui
        
        local notificationCorner = Instance.new("UICorner")
        notificationCorner.CornerRadius = UDim.new(0.2, 0)
        notificationCorner.Parent = notification
        
        local notificationText = Instance.new("TextLabel")
        notificationText.Size = UDim2.new(1, -20, 1, 0)
        notificationText.Position = UDim2.new(0.5, 0, 0.5, 0)
        notificationText.AnchorPoint = Vector2.new(0.5, 0.5)
        notificationText.BackgroundTransparency = 1
        notificationText.TextColor3 = Color3.fromRGB(230, 230, 250)
        notificationText.Text = message
        notificationText.TextSize = 16
        notificationText.Font = Enum.Font.Gotham
        notificationText.ZIndex = 21
        notificationText.Parent = notification
        
        -- Animate in
        notification.Size = UDim2.new(0, 0, 0, 0)
        notification.BackgroundTransparency = 1
        notificationText.TextTransparency = 1
        
        TweenService:Create(
            notification,
            TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
            {
                Size = UDim2.new(0, 200, 0, 40),
                BackgroundTransparency = 0
            }
        ):Play()
        
        TweenService:Create(
            notificationText,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {TextTransparency = 0}
        ):Play()
        
        -- Animate out and destroy
        task.delay(duration or 2, function()
            TweenService:Create(
                notification,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
                {
                    Size = UDim2.new(0, 0, 0, 0),
                    BackgroundTransparency = 1
                }
            ):Play()
            
            TweenService:Create(
                notificationText,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
                {TextTransparency = 1}
            ):Play()
            
            task.delay(0.3, function()
                notification:Destroy()
            end)
        end)
    end
    
    -- Display welcome notification
    showNotification("Press Z or click button to toggle", 3)
end

-- Add keybind for PC users
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.Z then
        toggleMovement()
        -- Update mobile GUI status if it exists
        local gui = PlayerGui:FindFirstChild("FaceBangGui")
        if gui then
            local statusContainer = gui.ShadowContainer.ButtonContainer:FindFirstChild("StatusContainer")
            if statusContainer then
                local status = statusContainer:FindFirstChild("StatusLight")
                
                local targetColor = getgenv().facefuckactive and Color3.fromRGB(80, 255, 80) or Color3.fromRGB(255, 80, 80)
                
                TweenService:Create(
                    status,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {BackgroundColor3 = targetColor}
                ):Play()
                
                if getgenv().facefuckactive then
                    -- Wipe any existing tweens
                    for _, descendant in ipairs(statusContainer:GetDescendants()) do
                        if descendant:IsA("Frame") or descendant:IsA("ImageLabel") then
                            TweenService:Create(
                                descendant,
                                TweenInfo.new(0),
                                {BackgroundTransparency = descendant.BackgroundTransparency}
                            ):Play()
                        end
                    end
                    -- Create active pulse animation
                    local statusPulse = TweenService:Create(
                        status,
                        TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
                        {BackgroundTransparency = 0.3}
                    )
                    statusPulse:Play()
                else
                    -- Wipe any existing tweens
                    for _, descendant in ipairs(statusContainer:GetDescendants()) do
                        if descendant:IsA("Frame") or descendant:IsA("ImageLabel") then
                            TweenService:Create(
                                descendant,
                                TweenInfo.new(0),
                                {BackgroundTransparency = descendant.BackgroundTransparency}
                            ):Play()
                        end
                    end
                    TweenService:Create(
                        status,
                        TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                        {BackgroundTransparency = 0}
                    ):Play()
                end
            end
        end
    end
end)

-- Initialize everything
setupCharacterTracking()
setupAnimationPrevention()
createMobileGUI()


--[[ antilog ]]
-- This basically makes roblox unable to log your chat messages sent in-game. Meaning if you get reported for saying something bad, you won't get banned!
-- Store the loadstring (line 5) in your autoexec folder into a text/lua file to receive automatic updates [remove the "--"" part when you paste it into the text file]
-- Credits: AnthonyIsntHere

loadstring(game:HttpGet("https://raw.githubusercontent.com/AnthonyIsntHere/anthonysrepository/main/scripts/AntiChatLogger.lua", true))()

-- 4/1/2023 - Rewritten
-- 4/4/2023 - Fixed scrollbar visibility issue
-- 4/15/2023 - Fixed Adonis anti-cheat kicking issue
-- 4/26/2023 - Fixed tick loaded format
-- 4/28/2023 - Added support for Fluxus users (hookmetamethod issue seems to have gotten fixed)
-- 6/14/2023 - Added support for Evon users (checkcaller isuse)
-- 7/7/2023 - Added support for Valyse users "FLAG IS NOT EXIST" LMFAO
-- 7/22/2023 - Added global for universal scripts (mainly chat bypasses)
-- 8/24/2023 - Now supports Player.Chatted signal event for clientside (highly requested)
-- 8/25/2023 - Fully fixed (i was high when editing it yesterday sorry guys)
-- 9/1/2023 - Fixed issue with /e command not working sometimes (mainly when joining a game)

if not game:IsLoaded() then
    game.Loaded:wait()
end

local ACL_LoadTime = tick()
local NotificationTitle = "Anthony's ACL"

local OldCoreTypeSettings = {}
local WhitelistedCoreTypes = {
    "Chat",
    "All",
    Enum.CoreGuiType.Chat,
    Enum.CoreGuiType.All
}

local OldCoreSetting = nil

local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")

local Player = Players.LocalPlayer

local Notify = function(_Title, _Text , Time)
    StarterGui:SetCore("SendNotification", {Title = _Title, Text = _Text, Icon = "rbxassetid://2541869220", Duration = Time})
end

local Tween = function(Object, Time, Style, Direction, Property)
    return TweenService:Create(Object, TweenInfo.new(Time, Enum.EasingStyle[Style], Enum.EasingDirection[Direction]), Property)
end

local PlayerGui = Player:FindFirstChildWhichIsA("PlayerGui") do
    if not PlayerGui then
        local Timer = tick() + 5
        repeat task.wait() until Player:FindFirstChildWhichIsA("PlayerGui") or (tick() > Timer)
        PlayerGui = Player:FindFirstChildWhichIsA("PlayerGui") or false
        if not PlayerGui then
            return Notify(NotificationTitle, "Failed to find PlayerGui!", 10)
        end
    end
end

if getgenv().AntiChatLogger then
    return Notify(NotificationTitle, "Anti Chat & Screenshot Logger already loaded!", 15)
else
    getgenv().AntiChatLogger = true
end

local Metatable = getrawmetatable(StarterGui)
setreadonly(Metatable, false)

local MessageEvent = Instance.new("BindableEvent")

if hookmetamethod then
    local CoreHook do
        CoreHook = hookmetamethod(StarterGui, "__namecall", newcclosure(function(self, ...)
            local Method = getnamecallmethod()
            local Arguments = {...}
            
            if self == StarterGui and not checkcaller() then
                if Method == "SetCoreGuiEnabled" then
                    local CoreType = Arguments[1]
                    local Enabled = Arguments[2]
                    
                    if table.find(WhitelistedCoreTypes, CoreType) and Enabled == false then -- Thanks Harun for correcting me on the second argument
                        OldCoreTypeSettings[CoreType] = Enabled
                        return
                    end
                elseif Method == "SetCore" then
                    local Core = Arguments[1]
                    local Connection = Arguments[2]
                    
                    if Core == "CoreGuiChatConnections" then
                        OldCoreSetting = Connection
                        return
                    end
                end
            end
            
            return CoreHook(self, ...)
        end))
    end

    if not getgenv().ChattedFix then
        getgenv().ChattedFix = true

        local ChattedFix do
            ChattedFix = hookmetamethod(Player, "__index", newcclosure(function(self, index)
                if self == Player and tostring(index):lower():match("chatted") and MessageEvent.Event then
                    return MessageEvent.Event
                end

                return ChattedFix(self, index)
            end))
        end

        local AnimateChattedFix = task.spawn(function()
            local ChattedSignal = false

            for _, x in next, getgc() do
                if type(x) == "function" and getfenv(x).script ~= nil and tostring(getfenv(x).script) == "Animate" then
                    if islclosure(x) then
                        local Constants = getconstants(x)

                        for _, v in next, Constants do
                            if v == "Chatted" then
                                ChattedSignal = x
                            end
                        end
                    end
                end
            end

            if ChattedSignal then
                ChattedSignal()
            end
        end)
    end
end

local EnabledChat = task.spawn(function()
    repeat
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
        task.wait()
    until StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat)
end)

local WarningGuiThread = task.spawn(function()
    WarningUI = Instance.new("ScreenGui")
    Main = Instance.new("Frame")
    BackgroundHolder = Instance.new("Frame")
    Background = Instance.new("Frame")
    TopBar = Instance.new("Frame")
    UIGradient = Instance.new("UIGradient")
    TitleHolder = Instance.new("Frame")
    Title = Instance.new("TextLabel")
    Holder = Instance.new("Frame")
    UIListLayout = Instance.new("UIListLayout")
    Reason_1 = Instance.new("TextLabel")
    Reason_2 = Instance.new("TextLabel")
    Reason_3 = Instance.new("TextLabel")
    WarningText = Instance.new("TextLabel")
    Exit = Instance.new("TextButton")
    ImageLabel = Instance.new("ImageLabel")
    
    WarningUI.Enabled = false
    WarningUI.Name = "WarningUI"
    WarningUI.Parent = CoreGui
    
    Main.Name = "Main"
    Main.Parent = WarningUI
    Main.AnchorPoint = Vector2.new(.5, .5)
    Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Main.BackgroundTransparency = 1
    Main.Position = UDim2.new(.5, 0, .5, 0)
    Main.Size = UDim2.new(0, 400, 0, 400)
    
    BackgroundHolder.Name = "BackgroundHolder"
    BackgroundHolder.Parent = Main
    BackgroundHolder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    BackgroundHolder.BackgroundTransparency = .25
    BackgroundHolder.BorderSizePixel = 0
    BackgroundHolder.Size = UDim2.new(1, 0, 1, 0)
    
    Background.Name = "Background"
    Background.Parent = BackgroundHolder
    Background.AnchorPoint = Vector2.new(.5, .5)
    Background.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Background.BorderSizePixel = 0
    Background.Position = UDim2.new(.5, 0, .5, 0)
    Background.Size = UDim2.new(.96, 0, .96, 0)
    
    TopBar.Name = "TopBar"
    TopBar.Parent = Background
    TopBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TopBar.BorderSizePixel = 0
    TopBar.Size = UDim2.new(1, 0, 0, 2)
    
    UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(53, 149, 146)), ColorSequenceKeypoint.new(.29, Color3.fromRGB(93, 86, 141)), ColorSequenceKeypoint.new(.50, Color3.fromRGB(126, 64, 138)), ColorSequenceKeypoint.new(.75, Color3.fromRGB(143, 112, 112)), ColorSequenceKeypoint.new(1, Color3.fromRGB(159, 159, 80))}
    UIGradient.Parent = TopBar
    
    TitleHolder.Name = "TitleHolder"
    TitleHolder.Parent = Background
    TitleHolder.AnchorPoint = Vector2.new(.5, .5)
    TitleHolder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    TitleHolder.BorderColor3 = Color3.fromRGB(44, 44, 44)
    TitleHolder.BorderSizePixel = 2
    TitleHolder.Position = UDim2.new(.5, 0, .5, 0)
    TitleHolder.Size = UDim2.new(.9, 0, .9, 0)
    
    Title.Name = "Title"
    Title.Parent = TitleHolder
    Title.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Title.BorderSizePixel = 0
    Title.Position = UDim2.new(0, 15, 0, -12)
    Title.Size = UDim2.new(0, 75, 0, 20)
    Title.Font = Enum.Font.SourceSansBold
    Title.Text = "Warning"
    Title.TextColor3 = Color3.fromRGB(235, 235, 235)
    Title.TextScaled = true
    Title.TextWrapped = true
    
    Holder.Name = "Holder"
    Holder.Parent = TitleHolder
    Holder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Holder.BackgroundTransparency = 1
    Holder.Position = UDim2.new(0, 30, .125, 0)
    Holder.Size = UDim2.new(1, -30, .875, 0)
    
    UIListLayout.Parent = Holder
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    Reason_1.Name = "Reason_1"
    Reason_1.Parent = Holder
    Reason_1.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Reason_1.BackgroundTransparency = 1
    Reason_1.BorderSizePixel = 0
    Reason_1.Size = UDim2.new(1, 0, 0, 20)
    Reason_1.Font = Enum.Font.SourceSans
    Reason_1.Text = "- TextChatService is enabled"
    Reason_1.TextColor3 = Color3.fromRGB(199, 40, 42)
    Reason_1.TextScaled = true
    Reason_1.TextWrapped = true
    Reason_1.TextXAlignment = Enum.TextXAlignment.Left
    Reason_1.Visible = false
    
    Reason_2.Name = "Reason_2"
    Reason_2.Parent = Holder
    Reason_2.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Reason_2.BackgroundTransparency = 1
    Reason_2.BorderSizePixel = 0
    Reason_2.Size = UDim2.new(1, 0, 0, 20)
    Reason_2.Font = Enum.Font.SourceSans
    Reason_2.Text = "- Legacy chat module was not found"
    Reason_2.TextColor3 = Color3.fromRGB(199, 40, 42)
    Reason_2.TextScaled = true
    Reason_2.TextWrapped = true
    Reason_2.TextXAlignment = Enum.TextXAlignment.Left
    Reason_2.Visible = false
    
    Reason_3.Name = "Reason_3"
    Reason_3.Parent = Holder
    Reason_3.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Reason_3.BackgroundTransparency = 1
    Reason_3.BorderSizePixel = 0
    Reason_3.Size = UDim2.new(1, 0, 0, 20)
    Reason_3.Font = Enum.Font.SourceSans
    Reason_3.Text = "- MessagePosted function was not found"
    Reason_3.TextColor3 = Color3.fromRGB(199, 40, 42)
    Reason_3.TextScaled = true
    Reason_3.TextWrapped = true
    Reason_3.TextXAlignment = Enum.TextXAlignment.Left
    Reason_3.Visible = false
    
    WarningText.Name = "WarningText"
    WarningText.Parent = TitleHolder
    WarningText.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    WarningText.BackgroundTransparency = 1
    WarningText.BorderSizePixel = 0
    WarningText.Position = UDim2.new(0, 30, .05, 0)
    WarningText.RichText = true
    WarningText.Size = UDim2.new(1, -30, 0, 20)
    WarningText.Font = Enum.Font.SourceSans
    WarningText.Text = "> Anti-<font color=\"#6ea644\">Chat Logger</font> will not work here!"
    WarningText.TextColor3 = Color3.fromRGB(255, 255, 255)
    WarningText.TextScaled = true
    WarningText.TextWrapped = true
    WarningText.TextXAlignment = Enum.TextXAlignment.Left
    
    Exit.Name = "Exit"
    Exit.Parent = TitleHolder
    Exit.AnchorPoint = Vector2.new(.5, .5)
    Exit.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
    Exit.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Exit.Position = UDim2.new(.5, 0, .899999976, 0)
    Exit.Size = UDim2.new(0, 250, 0, 20)
    Exit.Font = Enum.Font.SourceSans
    Exit.Text = "Ok"
    Exit.TextColor3 = Color3.fromRGB(255, 255, 255)
    Exit.TextScaled = true
    Exit.TextWrapped = true
    
    ImageLabel.Parent = TitleHolder
    ImageLabel.AnchorPoint = Vector2.new(.5, .5)
    ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ImageLabel.BackgroundTransparency = 1
    ImageLabel.Position = UDim2.new(.5, 0, .6, 0)
    ImageLabel.Size = UDim2.new(.3, 0, .3, 0)
    ImageLabel.ZIndex = 1
    ImageLabel.Image = "rbxassetid://12969025384"
    ImageLabel.ImageColor3 = Color3.fromRGB(40, 40, 40)
    ImageLabel.ImageTransparency = .5
    
    Exit.MouseButton1Down:Connect(function()
        WarningUI:Destroy()
    end)
end)

if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    WarningUI.Enabled = true
    Reason_1.Visible = true
    return
end

local PlayerScripts = Player:WaitForChild("PlayerScripts")
local ChatMain = PlayerScripts:FindFirstChild("ChatMain", true) or false

if not ChatMain then
    local Timer = tick()
    
    repeat task.wait() until PlayerScripts:FindFirstChild("ChatMain", true) or tick() > (Timer + 3)
    ChatMain = PlayerScripts:FindFirstChild("ChatMain", true)
    
    if not ChatMain then
        WarningUI.Enabled = true
        Reason_2.Visible = true
        return
    end
end

local PostMessage = require(ChatMain).MessagePosted

if not PostMessage then
    WarningUI.Enabled = true
    Reason_3.Visible = true
    return
end

local OldFunctionHook; OldFunctionHook = hookfunction(PostMessage.fire, function(self, Message)
    if self == PostMessage then
        MessageEvent:Fire(Message)
        return
    end
    return OldFunctionHook(self, Message)
end)

if setfflag then
    pcall(function()
        setfflag("AbuseReportScreenshot", "False")
        setfflag("AbuseReportScreenshotPercentage", "0")
    end)
end -- To prevent roblox from taking screenshots of your client.

local Credits = task.spawn(function()
    local UserIds = {
        1414978355
    }
    
    if table.find(UserIds, Player.UserId) then
        return
    end
    
    local Tag = Instance.new("BillboardGui")
    local Title = Instance.new("TextLabel", Tag)
    local Rank = Instance.new("TextLabel", Tag)
    local Gradient = Instance.new("UIGradient", Title)
    
    Tag.Brightness = 2
    Tag.Size = UDim2.new(4, 0, 1, 0)
    Tag.StudsOffsetWorldSpace = Vector3.new(0, 5, 0)
    
    Title.BackgroundTransparency = 1
    Title.Size = UDim2.new(1, 0, .6, 0)
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextScaled = true
    
    Rank.AnchorPoint = Vector2.new(.5, 0)
    Rank.BackgroundTransparency = 1
    Rank.Position = UDim2.new(.5, 0, .65, 0)
    Rank.Size = UDim2.new(.75, 0, .5, 0)
    Rank.TextColor3 = Color3.fromRGB(0, 0, 0)
    Rank.TextScaled = true
    Rank.Text = "< Anti Chat-Logger >"
    
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(.75, .75, .75)),
        ColorSequenceKeypoint.new(.27, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(.5, Color3.new(.3, 0, .5)),
        ColorSequenceKeypoint.new(0.78, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(.75, .75, .75))
    })
    Gradient.Offset = Vector2.new(-1, 0)
    
    local GradientTeen = Tween(Gradient, 2, "Circular", "Out", {Offset = Vector2.new(1, 0)})
    
    function PlayAnimation()
    	GradientTeen:Play()
    	GradientTeen.Completed:Wait()
    	Gradient.Offset = Vector2.new(-1, 0)
    	task.wait(.75)
    	PlayAnimation()
    end
    
    local AddTitle = function(Character)
        repeat task.wait() until Character
        
        local Humanoid = Character and Character:WaitForChild("Humanoid")
        local RootPart = Humanoid and Humanoid.RootPart
        
        if Humanoid then
            Humanoid:GetPropertyChangedSignal("RootPart"):Connect(function()
                if Humanoid.RootPart then
                    Tag.Adornee = RootPart
                end
            end)
        end
        
        if RootPart then
            Tag.Adornee = RootPart
        end
    end
    
    task.spawn(PlayAnimation)
    
    for _, x in next, Players:GetPlayers() do
        if table.find(UserIds, x.UserId) then
            Tag.Parent = workspace.Terrain
            Title.Text = x.Name
            AddTitle(x.Character)
            x.CharacterAdded:Connect(AddTitle)
        end
    end
    
    Players.PlayerAdded:Connect(function(x)
        if table.find(UserIds, x.UserId) then
            Tag.Parent = workspace.Terrain
            Title.Text = x.Name
            x.CharacterAdded:Connect(AddTitle)
        end
    end)
    
    Players.PlayerRemoving:Connect(function(x)
        if table.find(UserIds, x.UserId) then
            Tag.Parent = game
        end
    end)
end)

task.delay(1, function() WarningUI:Destroy() end)

for _, x in next, OldCoreTypeSettings do
    if not x then
        StarterGui:SetCore("ChatActive", false)
    end
    StarterGui:SetCoreGuiEnabled(_, x)
end

if OldCoreSetting then
    StarterGui:SetCore("CoreGuiChatConnections", OldCoreSetting)
end

if StarterGui:GetCore("ChatActive") then
    StarterGui:SetCore("ChatActive", false)
    StarterGui:SetCore("ChatActive", true)
end

--Metatable.__namecall = CoreHook
if CoreHook then
    setmetatable(Metatable, {__namecall = CoreHook}) 
end
setreadonly(Metatable, true)

Notify(NotificationTitle, "Anti Chat & Screenshot Logger Loaded!", 15)
print(string.format("AnthonyIsntHere's Anti Chat-Logger has loaded in %s seconds.", string.format("%.2f", tostring(tick() - ACL_LoadTime))))


--[[ lagserver ]]
local localPlayer = game.Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ToolManagerGUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 200, 0, 120)
mainFrame.Position = UDim2.new(0.8, 0, 0.5, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui
mainFrame.BackgroundTransparency = 0.5

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 10)
uiCorner.Parent = mainFrame

local titleText = Instance.new("TextLabel")
titleText.Name = "TitleText"
titleText.Size = UDim2.new(0, 100, 0, 30)
titleText.Position = UDim2.new(0, 10, 0, 5)
titleText.BackgroundTransparency = 1
titleText.Text = "Lag Server"
titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 14
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = mainFrame

local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Size = UDim2.new(0, 24, 0, 24)
minimizeButton.Position = UDim2.new(1, -52, 0, 8)
minimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
minimizeButton.BorderSizePixel = 0
minimizeButton.Text = "_"
minimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
minimizeButton.Font = Enum.Font.GothamBold
minimizeButton.TextSize = 14
minimizeButton.Parent = mainFrame

local minimizeCorner = Instance.new("UICorner")
minimizeCorner.CornerRadius = UDim.new(0, 6)
minimizeCorner.Parent = minimizeButton

local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 24, 0, 24)
closeButton.Position = UDim2.new(1, -26, 0, 8)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
closeButton.BorderSizePixel = 0
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 14
closeButton.Parent = mainFrame

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 6)
closeCorner.Parent = closeButton

local contentFrame = Instance.new("Frame")
contentFrame.Name = "ContentFrame"
contentFrame.Size = UDim2.new(1, -20, 1, -40)
contentFrame.Position = UDim2.new(0, 10, 0, 35)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local toggleButton = Instance.new("TextButton")
toggleButton.Name = "ToggleButton"
toggleButton.Size = UDim2.new(0, 180, 0, 30)
toggleButton.Position = UDim2.new(0.5, -90, 0, 5)
toggleButton.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
toggleButton.BorderSizePixel = 0
toggleButton.Text = "OFF"
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.GothamSemibold
toggleButton.TextSize = 14
toggleButton.Parent = contentFrame

local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 6)
buttonCorner.Parent = toggleButton

local auraFrame = Instance.new("Frame")
auraFrame.Name = "AuraFrame"
auraFrame.Size = UDim2.new(1, 0, 0, 30)
auraFrame.Position = UDim2.new(0, 0, 0, 45)
auraFrame.BackgroundTransparency = 1
auraFrame.Parent = contentFrame

local auraCheckbox = Instance.new("Frame")
auraCheckbox.Name = "AuraCheckbox"
auraCheckbox.Size = UDim2.new(0, 24, 0, 24)
auraCheckbox.Position = UDim2.new(0, 0, 0.5, -12)
auraCheckbox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
auraCheckbox.BorderSizePixel = 0
auraCheckbox.Parent = auraFrame

local checkboxCorner = Instance.new("UICorner")
checkboxCorner.CornerRadius = UDim.new(0, 4)
checkboxCorner.Parent = auraCheckbox

local checkboxIndicator = Instance.new("Frame")
checkboxIndicator.Name = "CheckboxIndicator"
checkboxIndicator.Size = UDim2.new(0.7, 0, 0.7, 0)
checkboxIndicator.Position = UDim2.new(0.5, 0, 0.5, 0)
checkboxIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
checkboxIndicator.BackgroundColor3 = Color3.fromRGB(40, 180, 120)
checkboxIndicator.BorderSizePixel = 0
checkboxIndicator.Visible = false
checkboxIndicator.Parent = auraCheckbox

local indicatorCorner = Instance.new("UICorner")
indicatorCorner.CornerRadius = UDim.new(0, 2)
indicatorCorner.Parent = checkboxIndicator

local auraLabel = Instance.new("TextLabel")
auraLabel.Name = "AuraLabel"
auraLabel.Size = UDim2.new(1, -34, 1, 0)
auraLabel.Position = UDim2.new(0, 34, 0, 0)
auraLabel.BackgroundTransparency = 1
auraLabel.Text = "Anti Lag"
auraLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
auraLabel.Font = Enum.Font.Gotham
auraLabel.TextSize = 14
auraLabel.TextXAlignment = Enum.TextXAlignment.Left
auraLabel.Parent = auraFrame

local statusText = Instance.new("TextLabel")
statusText.Name = "StatusText"
statusText.Size = UDim2.new(0.7, 0, 0, 15)
statusText.Position = UDim2.new(0.3, 0, 1, -18)
statusText.BackgroundTransparency = 1
statusText.Text = "Ready"
statusText.TextColor3 = Color3.fromRGB(150, 150, 150)
statusText.Font = Enum.Font.Gotham
statusText.TextSize = 10
statusText.Parent = contentFrame

local minimizedFrame = Instance.new("Frame")
minimizedFrame.Name = "MinimizedFrame"
minimizedFrame.Size = UDim2.new(0, 120, 0, 30)
minimizedFrame.Position = UDim2.new(0.8, 0, 0.5, 0)
minimizedFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
minimizedFrame.BorderSizePixel = 0
minimizedFrame.Visible = false
minimizedFrame.Parent = screenGui

local minimizedCorner = Instance.new("UICorner")
minimizedCorner.CornerRadius = UDim.new(0, 8)
minimizedCorner.Parent = minimizedFrame

local minimizedText = Instance.new("TextLabel")
minimizedText.Name = "MinimizedText"
minimizedText.Size = UDim2.new(0.7, 0, 1, 0)
minimizedText.BackgroundTransparency = 1
minimizedText.Text = "Lag Server"
minimizedText.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizedText.Font = Enum.Font.GothamBold
minimizedText.TextSize = 12
minimizedText.Parent = minimizedFrame

local restoreButton = Instance.new("TextButton")
restoreButton.Name = "RestoreButton"
restoreButton.Size = UDim2.new(0, 24, 0, 24)
restoreButton.Position = UDim2.new(1, -26, 0.5, -12)
restoreButton.AnchorPoint = Vector2.new(0, 0)
restoreButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
restoreButton.BorderSizePixel = 0
restoreButton.Text = "▢"
restoreButton.TextColor3 = Color3.fromRGB(200, 200, 200)
restoreButton.Font = Enum.Font.GothamBold
restoreButton.TextSize = 14
restoreButton.Parent = minimizedFrame

local restoreCorner = Instance.new("UICorner")
restoreCorner.CornerRadius = UDim.new(0, 6)
restoreCorner.Parent = restoreButton

local toolsEquipped = false
local removeAuras = false
local tools = {}
local auraRemovalConnection
local isMinimized = false
local originalCameraType
local teleportConnection
local originalPosition
local teleportFrameCounter = 0
local teleportTickInterval = 15

local fixedPosition
local yaw
local pitch
local inputConnection
local heartbeatConnection

local MIN_X = -500000 
local MAX_X = 500000  
local MIN_Z = -500000 
local MAX_Z = 500000  
local MIN_Y = 50000  
local MAX_Y = 100000 

local ModifyUsername
local toolEvent
local ToggleDisallowEvent
local ModifyUserEvent
local targetModifiedUsername = "YournothimbuddyXD"

pcall(function()
    ModifyUsername = ReplicatedStorage:WaitForChild("ModifyUsername", 10)
end)

pcall(function()
    toolEvent = ReplicatedStorage:WaitForChild("ToolEvent", 10)
end)

pcall(function()
    ToggleDisallowEvent = ReplicatedStorage:WaitForChild("ToggleDisallowEvent", 10)
end)

pcall(function()
    ModifyUserEvent = ReplicatedStorage:WaitForChild("ModifyUserEvent", 10)
end)

local titleDragArea = Instance.new("Frame")
titleDragArea.Name = "TitleDragArea"
titleDragArea.Size = UDim2.new(1, -80, 0, 35)
titleDragArea.Position = UDim2.new(0, 0, 0, 0)
titleDragArea.BackgroundTransparency = 1
titleDragArea.Parent = mainFrame

local dragging = false
local dragInput
local dragStart
local startPos
local minimizedDragging = false
local minimizedDragStart
local minimizedStartPos

local function updateDrag(input, object, dragStartPos, startPosition)
    local delta = input.Position - dragStartPos
    local newPosition = UDim2.new(
        startPosition.X.Scale, 
        startPosition.X.Offset + delta.X,
        startPosition.Y.Scale, 
        startPosition.Y.Offset + delta.Y
    )
    
    local tweenService = game:GetService("TweenService")
    local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = tweenService:Create(object, tweenInfo, {Position = newPosition})
    tween:Play()
end

titleDragArea.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            titleDragArea.Parent.BackgroundTransparency = 0.6
        end
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                titleDragArea.Parent.BackgroundTransparency = 0.5
            end
        end)
    end
end)

minimizedFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        local inputPosition = input.Position
        local guiObjects = screenGui:GetGuiObjectsAtPosition(inputPosition.X, inputPosition.Y)
        
        local canDrag = true
        for _, obj in pairs(guiObjects) do
            if obj == restoreButton then
                canDrag = false
                break
            end
        end
        
        if canDrag then
            minimizedDragging = true
            minimizedDragStart = input.Position
            minimizedStartPos = minimizedFrame.Position
            
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                minimizedFrame.BackgroundTransparency = 0.1
            end
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    minimizedDragging = false
                    minimizedFrame.BackgroundTransparency = 0
                end
            end)
        end
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        if dragging then
            updateDrag(input, mainFrame, dragStart, startPos)
        end
        
        if minimizedDragging then
            updateDrag(input, minimizedFrame, minimizedDragStart, minimizedStartPos)
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
        minimizedDragging = false
        mainFrame.BackgroundTransparency = 0.5
        minimizedFrame.BackgroundTransparency = 0
    end
end)

local function removeAuraItems()
    if not removeAuras or not localPlayer.Character then return end
    
    local auraItemsFound = false
    for _, item in pairs(localPlayer.Character:GetChildren()) do
        if item:IsA("Accessory") or item:IsA("Tool") or item:IsA("BasePart") or item:IsA("Shirt") or item:IsA("Pants") then
            if string.find(string.lower(item.Name), "aura") then
                item:Destroy()
                auraItemsFound = true
            end
        end
    end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= localPlayer and otherPlayer.Character then
            for _, item in pairs(otherPlayer.Character:GetChildren()) do
                if item:IsA("Accessory") or item:IsA("Tool") or item:IsA("BasePart") or item:IsA("Shirt") or item:IsA("Pants") then
                    if string.find(string.lower(item.Name), "aura") then
                        item:Destroy()
                        auraItemsFound = true
                    end
                end
            end
        end
    end
    
    if auraItemsFound then
        statusText.Text = "Aura items removed"
        statusText.TextColor3 = Color3.fromRGB(255, 100, 100)
        task.wait(0.01)
        statusText.Text = toolsEquipped and "Running" or "Ready"
        statusText.TextColor3 = toolsEquipped and Color3.fromRGB(40, 180, 120) or Color3.fromRGB(150, 150, 150)
    end
end

local function startAuraRemoval()
    if auraRemovalConnection then
        auraRemovalConnection:Disconnect()
    end
    
    auraRemovalConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if removeAuras then
            removeAuraItems()
        end
    end)
end

startAuraRemoval()

auraCheckbox.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        removeAuras = not removeAuras
        checkboxIndicator.Visible = removeAuras
        
        if removeAuras then
            statusText.Text = "Anti Lag active"
            statusText.TextColor3 = Color3.fromRGB(40, 180, 120)
        else
            statusText.Text = "Anti Lag off"
            statusText.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
        task.wait(0.01)
        if toolsEquipped then
            statusText.Text = "Running"
            statusText.TextColor3 = Color3.fromRGB(40, 180, 120)
        else
            statusText.Text = "Ready"
            statusText.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
    end
end)

auraLabel.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        removeAuras = not removeAuras
        checkboxIndicator.Visible = removeAuras
        
        if removeAuras then
            statusText.Text = "Anti Lag active"
            statusText.TextColor3 = Color3.fromRGB(40, 180, 120)
        else
            statusText.Text = "Anti Lag off"
            statusText.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
        task.wait(0.01)
        if toolsEquipped then
            statusText.Text = "Running"
            statusText.TextColor3 = Color3.fromRGB(40, 180, 120)
        else
            statusText.Text = "Ready"
            statusText.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
    end
end)

minimizeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    minimizedFrame.Visible = true
    isMinimized = true
    minimizedFrame.Position = UDim2.new(mainFrame.Position.X.Scale, mainFrame.Position.X.Offset, mainFrame.Position.Y.Scale, mainFrame.Position.Y.Offset)
end)

restoreButton.MouseButton1Click:Connect(function()
    minimizedFrame.Visible = false
    mainFrame.Visible = true
    isMinimized = false
    mainFrame.Position = UDim2.new(minimizedFrame.Position.X.Scale, minimizedFrame.Position.X.Offset, minimizedFrame.Position.Y.Scale, minimizedFrame.Position.Y.Offset)
end)

closeButton.MouseButton1Click:Connect(function()
    if teleportConnection then
        teleportConnection:Disconnect()
    end
    
    if auraRemovalConnection then
        auraRemovalConnection:Disconnect()
    end
    
    if toolsEquipped then
        workspace.FallenPartsDestroyHeight = -500
        if originalCameraType then
            workspace.Camera.CameraType = originalCameraType
        end
        
        if localPlayer.Character and originalPosition then
            localPlayer.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
        end
    end
    
    screenGui:Destroy()
    toolsEquipped = false
end)

local function fireModifyUsername()
    if not ModifyUsername or typeof(ModifyUsername) ~= "Instance" or not ModifyUsername:IsA("RemoteEvent") then
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("ModifyUsername", 2)
        end)
        if success and result then
            ModifyUsername = result
        else
            return false
        end
    end
    
    local success = pcall(function()
        local args = {
            [1] = "24k_mxtty1"
        }
        ModifyUsername:FireServer(unpack(args))
    end)
    
    return success
end

local function fireToolEvent(toolName)
    if not toolEvent or typeof(toolEvent) ~= "Instance" or not toolEvent:IsA("RemoteEvent") then
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("ToolEvent", 2)
        end)
        if success and result then
            toolEvent = result
        else
            return false
        end
    end
    
    local success = pcall(function()
        local args = {
            [1] = toolName
        }
        toolEvent:FireServer(unpack(args))
    end)
    
    return success
end

local function fireToggleDisallowEvent()
    if not ToggleDisallowEvent or typeof(ToggleDisallowEvent) ~= "Instance" or not ToggleDisallowEvent:IsA("RemoteEvent") then
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("ToggleDisallowEvent", 2)
        end)
        if success and result then
            ToggleDisallowEvent = result
        else
            return false
        end
    end
    
    local success = pcall(function()
        ToggleDisallowEvent:FireServer()
    end)
    
    return success
end

local function fireModifyUserEvent(username)
    if not ModifyUserEvent or typeof(ModifyUserEvent) ~= "Instance" or not ModifyUserEvent:IsA("RemoteEvent") then
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("ModifyUserEvent", 2)
        end)
        if success and result then
            ModifyUserEvent = result
        else
            return false
        end
    end
    
    local success = pcall(function()
        ModifyUserEvent:FireServer(username)
    end)
    
    return success
end

local function startVoidTeleporting()
    if teleportConnection then
        teleportConnection:Disconnect() 
    end
    
    teleportFrameCounter = 0
    local hasTeleportedOnce = false

    teleportConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not toolsEquipped or not localPlayer.Character or not localPlayer.Character.PrimaryPart then return end
        
        teleportFrameCounter = teleportFrameCounter + 1
        
        if teleportFrameCounter >= teleportTickInterval then
            teleportFrameCounter = 0 
            
            local randomX = math.random(MIN_X, MAX_X)
            local randomY = math.random(MIN_Y, MAX_Y) 
            local randomZ = math.random(MIN_Z, MAX_Z)
            local randomPosition = Vector3.new(randomX, randomY, randomZ)
            
            if localPlayer.Character and localPlayer.Character.PrimaryPart then
                localPlayer.Character:SetPrimaryPartCFrame(CFrame.new(randomPosition))

                local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                if hrp and hrp:IsA("BasePart") then
                    local wasAnchored = hrp.Anchored
                    hrp.Anchored = true
                    task.wait(0.001) 
                    hrp.Anchored = wasAnchored
                end

                if not hasTeleportedOnce and toolsEquipped then
                    hasTeleportedOnce = true 
                    task.spawn(function()
                        while toolsEquipped do
                            fireModifyUsername()
                            
                            tools = {}
                            for _, tool in pairs(localPlayer.Backpack:GetChildren()) do
                                if tool:IsA("Tool") then
                                    table.insert(tools, tool)
                                end
                            end
                            
                            if #tools > 0 and localPlayer.Character then
                                for _, tool in pairs(tools) do
                                    if not toolsEquipped then break end
                                    tool.Parent = localPlayer.Character
                                end
                            end
                            
                            if localPlayer.Character then
                                for _, tool in pairs(localPlayer.Character:GetChildren()) do
                                    if not toolsEquipped then break end
                                    if tool:IsA("Tool") then
                                        tool.Parent = localPlayer.Backpack
                                    end
                                end
                            end
                            
                            task.wait(0.05)
                        end
                    end)
                end
            end
        end
    end)
end

local function safelyReturnToPosition()
    if not localPlayer.Character then return end
    
    local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
    
    if not hrp or not humanoid then return end
    
    local stabilizationLoop = RunService.Heartbeat:Connect(function()
        if hrp then
            hrp.Velocity = Vector3.new(0, 0, 0)
            hrp.RotVelocity = Vector3.new(0, 0, 0)
            hrp.Anchored = true
        end
        
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    
    hrp.CFrame = CFrame.new(originalPosition)
    
    task.wait(0.5)
    
    for i = 1, 6 do
        if hrp then
            hrp.CFrame = CFrame.new(originalPosition)
        end
        task.wait(0.1)
    end
    
    if stabilizationLoop then stabilizationLoop:Disconnect() end
    
    if hrp then
        hrp.Anchored = false
    end
    
    if humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end
end

toggleButton.MouseButton1Click:Connect(function()
    toolsEquipped = not toolsEquipped
    
    if toolsEquipped then
        toggleButton.Text = "ON"
        toggleButton.BackgroundColor3 = Color3.fromRGB(40, 180, 120)
        statusText.Text = "Running"
        statusText.TextColor3 = Color3.fromRGB(40, 180, 120)
        
        if localPlayer.Character and localPlayer.Character.PrimaryPart then
            originalPosition = localPlayer.Character.PrimaryPart.Position
        end
        
        originalCameraType = workspace.Camera.CameraType
        fixedPosition = workspace.Camera.CFrame.Position
        local x, y, z = workspace.Camera.CFrame:ToEulerAnglesYXZ()
        pitch = math.deg(x)
        yaw = math.deg(y)
        
        workspace.Camera.CameraType = Enum.CameraType.Scriptable
        
        inputConnection = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Delta
                yaw = yaw - delta.X * 0.1
                pitch = math.clamp(pitch - delta.Y * 0.1, -89, 89)
            end
        end)
        
        heartbeatConnection = RunService.Heartbeat:Connect(function()
            if toolsEquipped then
                local rotationCFrame = CFrame.Angles(0, math.rad(yaw), 0) * CFrame.Angles(math.rad(pitch), 0, 0)
                workspace.Camera.CFrame = CFrame.new(fixedPosition) * rotationCFrame
            end
        end)
        
        workspace.FallenPartsDestroyHeight = math.huge * -1
        
        startVoidTeleporting()
        fireModifyUsername()
        fireToolEvent("Motor")
        
    else
        toggleButton.Text = "OFF"
        toggleButton.BackgroundColor3 = Color3.fromRGB(65, 105, 225)
        statusText.Text = "Returning..."
        statusText.TextColor3 = Color3.fromRGB(255, 165, 0)
        
        if inputConnection then inputConnection:Disconnect() end
        if heartbeatConnection then heartbeatConnection:Disconnect() end
        if teleportConnection then teleportConnection:Disconnect() end
        
        workspace.FallenPartsDestroyHeight = -500
        
        if originalCameraType then
            workspace.Camera.CameraType = originalCameraType
        end
        
        safelyReturnToPosition()
        
        fireToggleDisallowEvent()
        fireModifyUserEvent(localPlayer.Name)
        task.wait(0.5)
        fireToggleDisallowEvent()
        
        statusText.Text = "Ready"
        statusText.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
end)

local replicatedStorage = game:GetService("ReplicatedStorage")
local ToggleDisallowEvent = replicatedStorage:WaitForChild("ToggleDisallowEvent")

ToggleDisallowEvent:FireServer()


--[[ errornotify ]]
-- Professional Error Notification System
-- Optimized for Roblox Studio
-- Place in StarterPlayerScripts

local NotificationSystem = {}

-- Services
local Players = game:GetService("Players")
local LogService = game:GetService("LogService")
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

-- Constants
local NOTIFICATION_CONFIG = {
    FRIEND_REQUEST_POSITION = UDim2.new(0.5, 0, 0.08, 0),
    ANIMATION_DURATION = 0.65,
    DISPLAY_DURATION = 12,
    MAX_QUEUE_SIZE = 5,
    SPACING = UDim2.new(0, 0, 0.12, 0),
    MAX_WIDTH = UDim2.new(0.7, 0, 0, 0),
    MIN_WIDTH = UDim2.new(0.35, 0, 0, 0)
}

local THEME = {
    BACKGROUND = Color3.fromRGB(40, 44, 52),
    ACCENT = Color3.fromRGB(65, 105, 225),
    ERROR = Color3.fromRGB(220, 53, 69),
    TEXT_PRIMARY = Color3.fromRGB(255, 255, 255),
    TEXT_SECONDARY = Color3.fromRGB(200, 200, 200),
    BUTTON_HOVER = Color3.fromRGB(45, 45, 50),
    SHADOW = Color3.fromRGB(0, 0, 0)
}

-- Local Variables
local player = Players.LocalPlayer
local notificationQueue = {}
local activeNotifications = {}
local screenGui
local soundEffects = {}
local errorDebounceTable = {}

-- Utility Functions
local function CreateDropShadow(parent)
    local shadow = Instance.new("ImageLabel")
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://7131316275"
    shadow.ImageColor3 = THEME.SHADOW
    shadow.ImageTransparency = 0.5
    shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
    shadow.Size = UDim2.new(1, 15, 1, 15)
    shadow.ZIndex = parent.ZIndex - 1
    shadow.Parent = parent
    return shadow
end

-- Initialize Sound Effects
local function InitializeSounds()
    soundEffects.show = Instance.new("Sound")
    soundEffects.show.SoundId = "rbxassetid://6518811702"
    soundEffects.show.Volume = 0.3

    soundEffects.hide = Instance.new("Sound")
    soundEffects.hide.SoundId = "rbxassetid://6518811702"
    soundEffects.hide.Volume = 0.2
    soundEffects.hide.PlaybackSpeed = 0.8

    for _, sound in pairs(soundEffects) do
        sound.Parent = screenGui
    end
end

-- Create Professional GUI Components
local function CreateNotificationFrame()
    local notificationFrame = Instance.new("Frame")
    notificationFrame.Size = NOTIFICATION_CONFIG.MIN_WIDTH + UDim2.new(0, 0, 0, 130)
    notificationFrame.Position = UDim2.new(0.5, 0.08, 0, 0)
    notificationFrame.AnchorPoint = Vector2.new(0.5, 0)
    notificationFrame.BackgroundColor3 = THEME.BACKGROUND
    notificationFrame.BorderSizePixel = 0
    notificationFrame.ZIndex = 10

    -- Add modern rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = notificationFrame

    -- Add gradient effect
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, THEME.BACKGROUND),
        ColorSequenceKeypoint.new(1, THEME.BACKGROUND:Lerp(Color3.new(1, 1, 1), 0.05))
    })
    gradient.Rotation = 45
    gradient.Parent = notificationFrame

    -- Add professional stroke effect
    local stroke = Instance.new("UIStroke")
    stroke.Color = THEME.ACCENT
    stroke.Thickness = 1.5
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Parent = notificationFrame

    -- Add drop shadow
    CreateDropShadow(notificationFrame)

    return notificationFrame
end

local function CreateContentComponents(parent)
    -- Error Icon
    local iconLabel = Instance.new("ImageLabel")
    iconLabel.Size = UDim2.new(0, 30, 0, 30) -- Fixed size
    iconLabel.Position = UDim2.new(0.02, 0, 0.02, 0)
    iconLabel.BackgroundTransparency = 1
    iconLabel.Image = "rbxassetid://11401835376"
    iconLabel.ImageColor3 = THEME.ERROR
    iconLabel.Parent = parent

    -- Title with custom font
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(0.85, 0, 0.2, 0)
    titleLabel.Position = UDim2.new(0.1, 0, 0.02, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextColor3 = THEME.TEXT_PRIMARY
    titleLabel.TextSize = 18
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Text = "Runtime Error Detected"
    titleLabel.Parent = parent

    -- Message with automatic text scaling
    local messageLabel = Instance.new("TextLabel")
    messageLabel.Size = UDim2.new(0.9, 0, 0, 70) -- Initial height for message
    messageLabel.Position = UDim2.new(0.05, 0, 0.3, 0)
    messageLabel.BackgroundTransparency = 1
    messageLabel.Font = Enum.Font.Gotham
    messageLabel.TextColor3 = THEME.TEXT_SECONDARY
    messageLabel.TextSize = 14
    messageLabel.TextWrapped = true
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextYAlignment = Enum.TextYAlignment.Top
    messageLabel.Parent = parent

    return titleLabel, messageLabel
end

local function CreateInteractiveButtons(parent, messageLabel)
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Size = UDim2.new(0.9, 0, 0.2, 0)
    buttonContainer.Position = UDim2.new(0.05, 0, 0.8, 0)
    buttonContainer.BackgroundTransparency = 1
    buttonContainer.Parent = parent

    -- Modern Copy Button
    local copyButton = Instance.new("TextButton")
    copyButton.Size = UDim2.new(0.45, 0, 0.8, 0)
    copyButton.Position = UDim2.new(0, 0, 0, 0)
    copyButton.BackgroundColor3 = THEME.BACKGROUND:Lerp(Color3.new(1, 1, 1), 0.1)
    copyButton.Text = "Copy Details"
    copyButton.TextColor3 = THEME.TEXT_PRIMARY
    copyButton.Font = Enum.Font.GothamBold
    copyButton.TextSize = 14
    copyButton.AutoButtonColor = false
    copyButton.Parent = buttonContainer

    local copyCorner = Instance.new("UICorner")
    copyCorner.CornerRadius = UDim.new(0, 8)
    copyCorner.Parent = copyButton

    local copyStroke = Instance.new("UIStroke")
    copyStroke.Color = THEME.ACCENT
    copyStroke.Thickness = 1.5
    copyStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    copyStroke.Parent = copyButton

    -- Dismiss Button
    local dismissButton = Instance.new("TextButton")
    dismissButton.Size = UDim2.new(0.45, 0, 0.8, 0)
    dismissButton.Position = UDim2.new(0.5, 0, 0, 0)
    dismissButton.BackgroundColor3 = THEME.ACCENT
    dismissButton.Text = "Dismiss"
    dismissButton.TextColor3 = THEME.TEXT_PRIMARY
    dismissButton.Font = Enum.Font.GothamBold
    dismissButton.TextSize = 14
    dismissButton.AutoButtonColor = false
    dismissButton.Parent = buttonContainer

    local dismissCorner = Instance.new("UICorner")
    dismissCorner.CornerRadius = UDim.new(0, 8)
    dismissCorner.Parent = dismissButton

    -- Button functionality
    copyButton.MouseButton1Click:Connect(function()
        if setclipboard then
            setclipboard(messageLabel.Text)
            -- Show copy confirmation effect
            local originalText = copyButton.Text
            copyButton.Text = "Copied!"
            task.delay(1, function()
                copyButton.Text = originalText
            end)
        end
    end)

    dismissButton.MouseButton1Click:Connect(function()
        NotificationSystem.DismissNotification(parent)
    end)

    return copyButton, dismissButton
end

-- Notification System Functions
local function InitializeNotificationSystem()
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "EnhancedErrorNotifier"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    -- Handle DisplayOrder to ensure notifications appear on top
    screenGui.DisplayOrder = 999

    -- Parent to PlayerGui
    screenGui.Parent = game.CoreGui
    -- Initialize sound effects
    InitializeSounds()
end

local function CreateNotification(errorMessage, stackTrace)
    local notificationFrame = CreateNotificationFrame()

    notificationFrame.Parent = screenGui

    local title, messageLabel = CreateContentComponents(notificationFrame)
    messageLabel.Text = errorMessage .. "\n" .. stackTrace

    -- Calculate dimensions based on the text content
    local textSize = TextService:GetTextSize(
        messageLabel.Text,
        messageLabel.TextSize,
        messageLabel.Font,
        Vector2.new(1000, math.huge)
    )

    local adjustedHeight = textSize.Y + 100 -- Includes space for buttons and padding
    local adjustedWidth = math.min(textSize.X + 60, workspace.CurrentCamera.ViewportSize.X * 0.7) -- Adapt to viewport size

    notificationFrame.Size = UDim2.new(
        0, adjustedWidth,
        0, adjustedHeight
    )

    CreateInteractiveButtons(notificationFrame, messageLabel)

    return notificationFrame
end

function NotificationSystem.ShowNotification(errorMessage, stackTrace)
    -- Ensure notifications don't spam
    local currentTime = tick()
    if errorDebounceTable[errorMessage] and currentTime - errorDebounceTable[errorMessage] < NOTIFICATION_CONFIG.DISPLAY_DURATION then
        return
    end

    errorDebounceTable[errorMessage] = currentTime

    if #activeNotifications >= NOTIFICATION_CONFIG.MAX_QUEUE_SIZE then
        NotificationSystem.DismissNotification(activeNotifications[1])
    end

    local notificationFrame = CreateNotification(errorMessage, stackTrace)
    table.insert(activeNotifications, notificationFrame)

    -- Position and animate notification
    notificationFrame.Position = NOTIFICATION_CONFIG.FRIEND_REQUEST_POSITION +
        UDim2.new(0, 0, -0.5, 0)

    soundEffects.show:Play()

    -- Smooth entrance animation
    local tweenInfo = TweenInfo.new(
        NOTIFICATION_CONFIG.ANIMATION_DURATION,
        Enum.EasingStyle.Elastic,
        Enum.EasingDirection.Out
    )

    TweenService:Create(notificationFrame, tweenInfo, {
        Position = NOTIFICATION_CONFIG.FRIEND_REQUEST_POSITION
    }):Play()

    -- Auto-dismiss after the delay
    task.delay(NOTIFICATION_CONFIG.DISPLAY_DURATION, function()
        if table.find(activeNotifications, notificationFrame) then
            NotificationSystem.DismissNotification(notificationFrame)
        end
    end)

    -- Update positions of other active notifications
    task.defer(NotificationSystem.UpdateNotificationPositions)
end

function NotificationSystem.DismissNotification(notificationFrame)
    local index = table.find(activeNotifications, notificationFrame)
    if not index then return end

    table.remove(activeNotifications, index)
    soundEffects.hide:Play()

    -- Smooth exit animation
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
    local tween = TweenService:Create(notificationFrame, tweenInfo, {
        Position = notificationFrame.Position + UDim2.new(0, 0, -0.5, 0),
        BackgroundTransparency = 1,
        Transparency = 1
    })

    tween.Completed:Connect(function()
        notificationFrame:Destroy()
    end)

    tween:Play()

    -- Update positions of remaining notifications
    task.defer(NotificationSystem.UpdateNotificationPositions)
end

function NotificationSystem.UpdateNotificationPositions()
    for i, notificationFrame in ipairs(activeNotifications) do
        local targetPosition = NOTIFICATION_CONFIG.FRIEND_REQUEST_POSITION + UDim2.new(0, 0, NOTIFICATION_CONFIG.SPACING.Y.Scale * (i - 1), NOTIFICATION_CONFIG.SPACING.Y.Offset * (i - 1))

        -- Ensure the position update is error-free
        pcall(function()
            TweenService:Create(notificationFrame,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                { Position = targetPosition }
            ):Play()
        end)
    end
end

-- Initialize the system
InitializeNotificationSystem()

-- Connect to LogService
LogService.MessageOut:Connect(function(message, messageType)
    if messageType == Enum.MessageType.MessageError then
        -- Extract stack trace from message
        local stackTrace = string.match(message, "\nStack Begin\n(.-)\nStack End")
        if not stackTrace then stackTrace = "No stack trace available" end

        local errorMessage = message:gsub("\nStack Begin\n(.-)\nStack End", "")

        NotificationSystem.ShowNotification(errorMessage, stackTrace)
    end
end)

return NotificationSystem


--[[ rizzlines ]]
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- Create the ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "PickupLinesGui"
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

-- Create the main frame
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 250, 0, 300)  -- Reduced Size
MainFrame.Position = UDim2.new(0.5, -125, 0.5, -150) -- Adjusted position for smaller size
MainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
MainFrame.BackgroundTransparency = 0.6
MainFrame.BorderSizePixel = 0
MainFrame.ClipsDescendants = true
MainFrame.Parent = ScreenGui

-- Add rounded corners
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = MainFrame

-- Add glass effect
local UIGradient = Instance.new("UIGradient")
UIGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0.3),
	NumberSequenceKeypoint.new(1, 0.4)
})
UIGradient.Rotation = 45
UIGradient.Parent = MainFrame

-- Create title bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 30)  -- Reduced title bar size
TitleBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
TitleBar.BackgroundTransparency = 0.25
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

-- Add rounded corners to title bar
local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 10)
TitleCorner.Parent = TitleBar

-- Create title text
local TitleText = Instance.new("TextLabel")
TitleText.Name = "TitleText"
TitleText.Size = UDim2.new(1, -70, 1, 0) -- Adjusted size for smaller title bar
TitleText.Position = UDim2.new(0, 10, 0, 0)
TitleText.BackgroundTransparency = 1
TitleText.Text = "Smooth Pickup Lines"
TitleText.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleText.TextSize = 16 -- Reduced text size
TitleText.Font = Enum.Font.GothamBold
TitleText.Parent = TitleBar

-- Create minimize button
local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 25, 0, 25) -- Reduced button size
MinimizeButton.Position = UDim2.new(1, -60, 0, 3)  -- Adjusted button position
MinimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
MinimizeButton.BackgroundTransparency = 0.4
MinimizeButton.Text = "-"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 18 -- Reduced text size
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Parent = TitleBar

-- Add rounded corners to minimize button
local MinimizeCorner = Instance.new("UICorner")
MinimizeCorner.CornerRadius = UDim.new(0, 5)
MinimizeCorner.Parent = MinimizeButton

-- Create close button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 25, 0, 25) -- Reduced button size
CloseButton.Position = UDim2.new(1, -30, 0, 3) -- Adjusted button position
CloseButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
CloseButton.BackgroundTransparency = 0.4
CloseButton.Text = "×"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 18 -- Reduced text size
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Parent = TitleBar

-- Add rounded corners to close button
local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 5)
CloseCorner.Parent = CloseButton

-- Create ScrollingFrame for pickup lines
local ScrollFrame = Instance.new("ScrollingFrame")
ScrollFrame.Name = "ScrollFrame"
ScrollFrame.Size = UDim2.new(1, -10, 1, -40) -- Adjusted size to fit smaller main frame
ScrollFrame.Position = UDim2.new(0, 5, 0, 35) -- Adjusted position for smaller titlebar
ScrollFrame.BackgroundTransparency = 1
ScrollFrame.BorderSizePixel = 0
ScrollFrame.ScrollBarThickness = 4
ScrollFrame.ClipsDescendants = true
ScrollFrame.Parent = MainFrame

-- Add more pickup lines
local pickupLines = {
    "Are you a magician? Because whenever I look at you, everyone else disappears.",
    "Do you have a map? I keep getting lost in your eyes.",
    "Is your name Google? Because you've got everything I've been searching for.",
    "Are you a WiFi signal? Because I'm feeling a strong connection.",
	"Do you like science? Because I've got my ion you.",
    "Are you French? Because Eiffel for you.",
    "Is your name Autumn? Because you're making me fall for you.",
    "Are you a camera? Because every time I look at you, I smile.",
    "Do you believe in love at first sight, or should I walk by again?",
    "Are you a parking ticket? Because you've got FINE written all over you.",
    "Is your name Spotify? Because you're the hottest single around.",
    "Are you a bank loan? Because you've got my interest.",
    "Do you play Minecraft? Because you're mine-crafted perfectly.",
    "Are you a campfire? Because you are hot and I want s'more.",
    "Is this the Hogwarts Express? Because Platform 9 and 3/4 isn't the only thing making me crash into walls.",
    "Are you made of copper and tellurium? Because you're Cu-Te.",
    "Do you have a pencil? Because I want to erase your past and write our future.",
    "Is your name Wifi? Because I'm really feeling a connection.",
    "Are you a dictionary? Because you're adding meaning to my life.",
    "Do you have a map? Because I just keep getting lost in your eyes.",
	 "Is your name Microsoft? Because you're exactly what I need.",
    "Are you a photographer? Because I can picture us together.",
    "Do you have a bandaid? Because I scraped my knee falling for you.",
    "Is your father a boxer? Because you're a knockout!",
    "Are you a time traveler? Because I see you in my future.",
	"Do you like math? Because I can add you to my life.",
	"Is your name Waldo? Because someone like you is hard to find.",
    "Are you a cat? Because you're purr-fect.",
    "Do you have a sunburn, or are you always this hot?",
    "Is this a library? Because I keep checking you out.",
	"Are you an interior decorator? Because when I saw you, the room became beautiful.",
    "Do you play soccer? Because you're a keeper.",
    "Is your name Winter? Because you'll be snow problem for me.",
    "Are you a drum? Because I can't beat spending time with you.",
    "Do you have a name, or can I call you mine?",
    "Is this seat taken? Because my heart just skipped a beat.",
	"Are you a magician? Because you just made my heart skip a beat.",
	 "Do you have a quarter? I need to call my mom and tell her I met the one.",
    "Is your name Summer? Because you're hot as can be.",
    "Are you a gardener? Because you've planted yourself in my heart.",
    "Do you like raisins? How about a date instead?",
	"Is your name NASA? Because you're out of this world.",
    "Are you a campfire? Because you're hot and I want s'more.",
    "Do you have a map? I keep getting lost in your smile.",
    "Is your dad an art thief? Because you're a masterpiece.",
	"Are you a keyboard? Because you're just my type.",
    "Do you like science? Because we've got chemistry.",
    "Is your name Gravity? Because I keep falling for you.",
    "Are you a star? Because you light up my world.",
	 "Do you have a Band-Aid? I just scraped my knee falling for you.",
    "Is this a dream? Because you're too good to be true.",
    "Are you an alien? Because you're out of this world.",
    "Do you believe in fate? Because I think we were meant to meet.",
	"Is your name Art? Because you're a masterpiece.",
    "Are you a baker? Because you're making my heart rise.",
	"Do you have a compass? Because I keep getting lost in your eyes.",
    "Is your name Google? Because you've got everything I'm searching for.",
    "Are you a charger? Because I'm dying without you.",
    "Do you have a name tag? I keep forgetting my name around you.",
	 "Is your name WiFi? Because I'm feeling a strong connection."
}


local function chat(txt)
	if game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents") then
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(txt,"All")
	else
		game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(txt)
	end
end

-- Create pickup line buttons
local function createPickupLineButtons()
	local buttonHeight = 40  -- Reduced button height
	local padding = 5

	for i, line in ipairs(pickupLines) do
		local Button = Instance.new("TextButton")
		Button.Name = "PickupLine" .. i
		Button.Size = UDim2.new(1, -10, 0, buttonHeight)
		Button.Position = UDim2.new(0, 5, 0, (i-1) * (buttonHeight + padding))
		Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		Button.BackgroundTransparency = 0.4
		Button.Text = line
		Button.TextColor3 = Color3.fromRGB(255, 255, 255)
		Button.TextSize = 14  -- Reduced text size
		Button.Font = Enum.Font.Gotham
		Button.TextWrapped = true
		Button.Parent = ScrollFrame

		-- Add rounded corners to button
		local ButtonCorner = Instance.new("UICorner")
		ButtonCorner.CornerRadius = UDim.new(0, 5)
		ButtonCorner.Parent = Button

		-- Button hover effect
		Button.MouseEnter:Connect(function()
			TweenService:Create(Button, TweenInfo.new(0.3), {
				BackgroundTransparency = 0.2
			}):Play()
		end)

		Button.MouseLeave:Connect(function()
			TweenService:Create(Button, TweenInfo.new(0.3), {
				BackgroundTransparency = 0.4
			}):Play()
		end)

		-- Button click handler
		Button.MouseButton1Click:Connect(function()
			local clickAnimation = TweenService:Create(Button, TweenInfo.new(0.1), {
				BackgroundTransparency = 0
			})
			clickAnimation:Play()

			-- Chat the pickup line
			chat(line)
			wait(0.1)
			TweenService:Create(Button, TweenInfo.new(0.1), {
				BackgroundTransparency = 0.4
			}):Play()
		end)
	end
	ScrollFrame.CanvasSize = UDim2.new(0, 0, 0, #pickupLines * (buttonHeight + padding))
end

-- Make the frame draggable
local isDragging = false
local dragInput
local dragStart
local startPos

local function updateDrag(input)
	local delta = input.Position - dragStart
	MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

TitleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		isDragging = true
		dragStart = input.Position
		startPos = MainFrame.Position

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				isDragging = false
			end
		end)
	end
end)

TitleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and isDragging then
		updateDrag(input)
	end
end)

-- Create minimize/maximize animation
local isMinimized = false
MinimizeButton.MouseButton1Click:Connect(function()
	isMinimized = not isMinimized
	local targetSize = isMinimized and UDim2.new(0, 250, 0, 30) or UDim2.new(0, 250, 0, 300) -- Adjusted minimized size

	TweenService:Create(MainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {
		Size = targetSize
	}):Play()

	if isMinimized then
		ScrollFrame.Visible = false
	else
		wait(0.2)
		ScrollFrame.Visible = true
	end
end)

-- Create close animation
CloseButton.MouseButton1Click:Connect(function()
	local closeAnimation = TweenService:Create(MainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
		BackgroundTransparency = 1
	})

	closeAnimation:Play()
	closeAnimation.Completed:Connect(function()
        ScreenGui:Destroy()
	end)
end)

-- Initialize the GUI
createPickupLineButtons()


--[[ voidoof ]]
local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")

local function forceResetToVoid()
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        character = player.CharacterAdded:Wait()
    end
    
    -- Save current position and camera settings
    local savedPosition = character.HumanoidRootPart.CFrame
    local savedCameraSubject = camera.CameraSubject
    local savedCameraType = camera.CameraType
	-- Use the fixed offset here
    local savedCameraOffset = Vector3.new(0, -50000, 0)
    local savedCameraOrientation = camera.CFrame - camera.CFrame.Position  -- Capture the orientation part of the camera

    -- Freeze camera
    camera.CameraType = Enum.CameraType.Scriptable
    
    -- Teleport to an even lower position in the void (lower Y-coordinate)
    character:SetPrimaryPartCFrame(CFrame.new(80, -448, -35) - Vector3.new(0, 50, 0))  -- Further lowered Y-coordinate
    
    -- Set up respawn handler
    local connection
    connection = player.CharacterAdded:Connect(function(newCharacter)
        connection:Disconnect()
        
        -- Wait for essential parts
        local humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
        local humanoid = newCharacter:WaitForChild("Humanoid")
        
        -- Ensure character is fully loaded
        task.wait(0.1)
        
        -- Teleport back
        newCharacter:SetPrimaryPartCFrame(savedPosition)
        
        -- Reset camera properly
        task.wait(0.1)
        
        -- Restore camera settings
        camera.CameraType = savedCameraType
        camera.CameraSubject = humanoid
        
        -- Smooth camera transition without changing orientation
        local function smoothCameraReset()
            local startCFrame = camera.CFrame
            local endCFrame = savedPosition * CFrame.new(savedCameraOffset)
            
            -- Keep the same orientation, but lerp position
            local startOrientation = startCFrame - startCFrame.Position
            local endOrientation = savedCameraOrientation
            
            for i = 0, 1, 0.1 do
                if not newCharacter:IsDescendantOf(workspace) then break end
                camera.CFrame = startOrientation:Lerp(endOrientation, i) * CFrame.new(camera.CFrame.Position:Lerp(endCFrame.Position, i))
                task.wait()
            end
            
            -- Final position with orientation
            camera.CFrame = endOrientation * CFrame.new(endCFrame.Position)
        end
        
        -- Run the smooth transition
        task.spawn(smoothCameraReset)
        
        -- Lock mouse if it was locked before
        if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
        end
    end)
    
    -- Force the reset
    task.wait(0.5)
end

-- Function to manually fix camera if needed
local function fixCamera()
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        camera.CameraSubject = character.Humanoid
        camera.CameraType = Enum.CameraType.Custom
    end
end

-- Call the main function
forceResetToVoid()

-- Expose fix camera function
return {
    forceResetToVoid = forceResetToVoid,
    fixCamera = fixCamera
}


--[[ ak admin tag system ]]
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local TextService = game:GetService("TextService")
local HttpService = game:GetService("HttpService")
local crequest = syn and syn.request or request or fluxus and fluxus.request or http and http.request or http_request or sentinel and sentinel.request  or http_request or http.request or http and http.request or http_request or (crypt and crypt.request) or request or (SENTINEL_LOADED and request) or (syn and syn.request)  or (typeof(request) == "function" and request) or (typeof(http) == "table" and http.request)
local JSON_URL = "https://ichfickdeinemutta.pages.dev/Tags.json"
local MAX_RETRIES = 3

local function fetchJson(url2, maxRetries)
    local retries = 0
    local tagConfig = {}
    while retries < maxRetries do
        local success, result = pcall(function()
            return crequest({
                Url = url2,
                method = "GET"
            })
        end)
        if success then
            local decodeSuccess, decoded = pcall(function()
                return HttpService:JSONDecode(result.Body)
            end)
            if decodeSuccess then
                return true, decoded
            else
            end
        else
        end
        retries = retries + 1
        if retries < maxRetries then
            local delay = 2 ^ (retries - 1)
            task.wait(delay)
        end
    end
    return false, tagConfig
end

-- Initialize tagConfig and playerToTag
local success, tagConfig = fetchJson(JSON_URL, MAX_RETRIES)
if not success then
else
end


local tagOrder = {
    "AK OWNER",
    "AK CO OWNER",
    "AK DADDY",
    "AK STAFF",
    "AK ADVERTISER",
    "AK HELPER",
    "AK LUCKYGOD",
    "AK BOOSTER",
    "AK SUPPORT",
    "AK BADDIE",
    "AK REAPER",
    "AK MONEYMAKER",
    "AK GODMODE",
    "AK FEMBOY",
    "AK ASIAN",
    "AK TERMINATOR",
    "AK CEO",
    "AK E-SEXLOVER",
    "AK MOMMY",
    "AK DEX",
    "AK SNIPERMASK",
    "AK E-KITTEN",
    "AK FREAK",
    "AK AZER",
    "AK HUSTLA",
    "AK HOLLOWFLAME",
    "AK FENNEC",
    "AK DRAGON",
    "AK FEDERAL",
    "AK ARCTURUS",
    "AK GOODBOY",
    "AK WARRIOR",
    "AK KAWAII",
    "AK POTATO",
    "AK TWISTED",
    "AK PHROGSPLOIT",
    "AK DOGGYFUCKER",
    "AK DOGGYFUCKA",
    "AK HORNYBOY",
    "AK PERKZ",
    "AK MOMMY KITTY",
    "AK RYZA",
    "AK CONTENT CREATOR",
    "AK GOONER",
    "AK VORTEX",
    "AK DADDYTWIZZY",
    "AK SHROOMIE",
    "AK DANCER",
    "AK HUNTER",
    "AK VETERAN",
    "AK SEEKER",
    "AK ELITE",
    "AK LEGEND",
    "AK MASTER",
    "AK MYTHIC",
    "AK EXPLORER",
    "AK CHALLENGER",
    "AK ASCENDED",
    "AK ROOKIE",
    "AK ALLMIGHTY",
    "AK GOD",
    "AK FEETLOVER",
    "AK NIGGER",
    "AK LOCKED",
    "AK BIBS",
    "AK YAMAHA_R1",
    "AK SCYTHZ",
    "AK KILLA",
    "AK STAR",
    "AK PWNED",
    "AK IM YOUR DADDY"
}


local playerToTag = {}
for _, tag in ipairs(tagOrder) do
    local users = tagConfig[tag]
    if users then
        for _, user in ipairs(users) do
            local userLower = user:lower()
            if not playerToTag[userLower] then
                playerToTag[userLower] = tag
            end
        end
    end
end

local function containsIgnoreCase(tbl, name)
    if not name then return false end
    name = name:lower()
    for _, v in ipairs(tbl) do
        if v:lower() == name then
            return true
        end
    end
    return false
end

local CONFIG = {
    TAG_SIZE = UDim2.new(0, 0, 0, 32),
    TAG_OFFSET = Vector3.new(0, 2.0, 0),
    MAX_DISTANCE = 200000,
    DISTANCE_THRESHOLD = 50,
    HYSTERESIS = 5,
    CORNER_RADIUS = UDim.new(0, 10),
    PARTICLE_COUNT = 100,
    PARTICLE_SPEED = 1,
    GLOW_INTENSITY = 0.3,
    TELEPORT_DISTANCE = 5,
    TELEPORT_HEIGHT = 0.5,
}

local RankData = {
    ["AK OWNER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(120, 66, 245),
        emoji = "👑",
        image = "http://www.roblox.com/asset/?id=115097330925898"
    },
    ["AK CO OWNER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(61, 126, 255),
        emoji = "⚡",
        image = "http://www.roblox.com/asset/?id=134980103242776"
    },
    ["AK DADDY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(0, 191, 255),
        emoji = "💎",
        image = ""
    },
    ["AK VORTEX"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(0, 191, 255),
        emoji = "🌪️",
        image = ""
    },
    ["AK NIGGA"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 255, 255),
        emoji = "🤬",
        image = ""
    },
    ["AK STAFF"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(0, 0, 0),
        emoji = "🔰",
        image = "http://www.roblox.com/asset/?id=71948587278990"
    },
    ["AK ADVERTISER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 69, 0),
        emoji = "📢",
        image = ""
    },
    ["AK HELPER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(169, 169, 169),
        emoji = "📢",
        image = ""
    },
    ["AK USER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(200, 160, 255),
        emoji = "♦️",
        image = "http://www.roblox.com/asset/?id=70624191793136"
    },
    ["OG BUYER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 105, 180),
        emoji = "∞",
        image = ""
    },
    ["AK LUCKYGOD"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(124, 252, 0),
        emoji = "🍀",
        image = ""
    },
    ["AK BOOSTER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(75, 0, 130),
        emoji = "🚀",
        image = "http://www.roblox.com/asset/?id=135821614322331"
    },
    ["AK SUPPORT"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(0, 150, 0),
        emoji = "🔨",
        image = "http://www.roblox.com/asset/?id=78056611932628"
    },
    ["AK BADDIE"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 105, 180),
        emoji = "👅",
        image = ""
    },
    ["AK REAPER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(0, 0, 0),
        emoji = "🧿",
        image = ""
    },
    ["AK MONEYMAKER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(152, 255, 152),
        emoji = "💰",
        image = ""
    },
    ["AK GODMODE"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 215, 0),
        emoji = "🤫",
        image = ""
    },
    ["AK FEMBOY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 105, 180),
        emoji = "💖",
        image = ""
    },
    ["AK ASIAN"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(64, 224, 208),
        emoji = "🍜",
        image = ""
    },
    ["AK TERMINATOR"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 102, 102),
        emoji = "👁️",
        image = ""
    },
    ["AK CEO"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(200, 162, 200),
        emoji = "👑",
        image = ""
    },
    ["AK E-SEXLOVER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 105, 180),
        emoji = "💋",
        image = ""
    },
    ["AK MOMMY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(144, 31, 242),
        emoji = "🍄",
        image = ""
    },
    ["AK DEX"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(0, 0, 0),
        emoji = "🐺",
        image = ""
    },
    ["AK SNIPERMASK"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(138, 3, 3),
        emoji = "👁️‍🗨️",
        image = ""
    },
    ["AK E-KITTEN"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 105, 180),
        emoji = "🍑",
        image = ""
    },
    ["AK FREAK"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(255, 255, 255),
        emoji = "🍆",
        image = "http://www.roblox.com/asset/?id=94349052077192"
    },
    ["AK AZER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 255, 255),
        emoji = "🩸",
        image = ""
    },
    ["AK HUSTLA"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(0, 160, 190),
        emoji = "🦈",
        image = ""
    },
    ["AK HOLLOWFLAME"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 85, 0),
        emoji = "🎃",
        image = ""
    },
    ["AK FENNEC"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 140, 0),
        emoji = "🦊",
        image = "http://www.roblox.com/asset/?id=78056611932628"
    },
    ["AK DRAGON"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(139, 0, 0),
        emoji = "🍓",
        image = ""
    },
    ["AK FEDERAL"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "🚨",
        image = ""
    },
    ["AK ARCTURUS"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 165, 0),
        emoji = "♦️",
        image = "http://www.roblox.com/asset/?id=106859219117319"
    },
    ["AK GOODBOY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "🥵",
        image = ""
    },
    ["AK WARRIOR"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(252, 11, 3),
        emoji = "♦️",
        image = "http://www.roblox.com/asset/?id=74203319792453"
    },
    ["AK KAWAII"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 105, 180),
        emoji = "♦️",
        image = "http://www.roblox.com/asset/?id=120305713055340"
    },
    ["AK POTATO"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 165, 0),
        emoji = "♦️",
        image = "http://www.roblox.com/asset/?id=115679774469788"
    },
    ["AK TWISTED"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "🤤",
        image = ""
    },
    ["AK PHROGSPLOIT"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(59, 255, 111),
        emoji = "🐸",
        image = ""
    },
    ["AK DOGGYFUCKER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(255, 102, 102),
        emoji = "🐸",
        image = "http://www.roblox.com/asset/?id=87817403228848"
    },
    ["AK DOGGYFUCKA"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(0, 255, 255),
        emoji = "🐸",
        image = "http://www.roblox.com/asset/?id=97511041552708"
    },
    ["AK HORNYBOY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(242, 66, 245),
        emoji = "🦝",
        image = ""
    },
    ["AK PERKZ"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(124, 252, 0),
        emoji = "💰",
        image = ""
    },
    ["AK MOMMY KITTY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 255, 255),
        emoji = "🐸",
        image = "http://www.roblox.com/asset/?id=110726191381486"
    },
    ["AK RYZA"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(255, 102, 102),
        emoji = "🐸",
        image = "http://www.roblox.com/asset/?id=71284892747793"
    },
    ["AK ROOKIE"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(135, 206, 235),
        emoji = "",
        image = ""
    },
    ["AK EXPLORER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(100, 149, 237),
        emoji = "",
        image = ""
    },
    ["AK CHALLENGER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(60, 179, 113),
        emoji = "",
        image = ""
    },
    ["AK SEEKER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 165, 0),
        emoji = "",
        image = ""
    },
    ["AK VETERAN"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 99, 71),
        emoji = "",
        image = ""
    },
    ["AK ELITE"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(218, 112, 214),
        emoji = "",
        image = ""
    },
    ["AK MASTER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(138, 43, 226),
        emoji = "",
        image = ""
    },
    ["AK MYTHIC"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 20, 147),
        emoji = "",
        image = ""
    },
    ["AK ASCENDED"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(72, 209, 204),
        emoji = "",
        image = ""
    },
    ["AK LEGEND"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 215, 0),
        emoji = "",
        image = ""
    },
    ["AK CONTENT CREATOR"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=107024412860531"
    },
    ["AK GOONER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(64, 224, 208),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=140562758794416"
    },
    ["AK DADDYTWIZZY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=86892372545965"
    },
    ["AK DANCER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(64, 224, 208),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=98712039214761"
    },
    ["AK SHROOMIE"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = true,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=108669167178355"
    },
    ["AK HUNTER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(0, 0, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=105980186269437"
   },
   ["AK ALLMIGHTY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=91662218502917"
    },
   ["AK GOD"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(75, 0, 130),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=78254662550564"
    },
   ["AK FEETLOVER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(0, 255, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=112177669514014"
    },
   ["AK LOCKED"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(75, 0, 130),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=129081149538265"
    },
   ["AK BIBS"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        JumpLetters = false,
        GlitchName = false,
        UseImage = true,
        accent = Color3.fromRGB(0, 0, 0),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=84422083508078"
    },
   ["AK YAMAHA_R1"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = true,
        UseImage = true,
        accent = Color3.fromRGB(20, 40, 160),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=127219903298526"
    },
   ["AK SCYTHZ"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(173, 66, 245),
        emoji = "😏",
        image = ""
    },
   ["AK KILLA"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 0, 0),
        emoji = "👑",
        image = ""
    },
    ["AK STAR"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(255, 217, 0),
        emoji = "⭐",
        image = ""
    },
    ["AK PWNED"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        JumpLetters = false,
        GlitchName = false,
        UseImage = false,
        accent = Color3.fromRGB(83, 59, 129),
        emoji = "👾",
        image = ""
    },
    ["AK IM YOUR DADDY"] = {
	primary = Color3.fromRGB(20, 20, 20),
	AnimateName = false,
	JumpLetters = false,
	GlitchName = true,
	UseImage = false,
	accent = Color3.fromRGB(0, 187, 255),
	emoji = "🍆🍑",
	image = ""
    }
}


local ChatWhitelist = {}

local function modifyString(randomText)
    local modified = ""
    for char in randomText:gmatch(".") do
        if char ~= " " then
            modified = modified .. char
        end
    end
    return modified
end

local message = "imusing-AKADMIN!"
local modifiedMessage = modifyString(message)

spawn(function()
    while true do
        for i = 1, 5 do
            Players:Chat(modifiedMessage)
            wait(8)
        end
    end
end)

local function createParticles(tag, parent, accentColor)
    for i = 1, CONFIG.PARTICLE_COUNT do
        local particle = Instance.new("Frame")
        particle.Name = "Particle_" .. i
        particle.Size = UDim2.new(0, math.random(1, 6), 0, math.random(1, 6))
        particle.Position = UDim2.new(math.random(), math.random(-10, 10), 1 + math.random() * 0.5, 0)
        particle.BackgroundColor3 = accentColor
        particle.BackgroundTransparency = math.random(0, 0.4)
        particle.BorderSizePixel = 0
        local pCorner = Instance.new("UICorner")
        pCorner.CornerRadius = UDim.new(1, 10)
        pCorner.Parent = particle
        particle.Parent = parent
        spawn(function()
            while tag and tag.Parent do
                local startX = math.random()
                local startOffsetX = math.random(-10, 10)
                particle.Position = UDim2.new(startX, startOffsetX, 1 + math.random() * 0.5, 0)
                particle.Size = UDim2.new(0, math.random(1, 6), 0, math.random(1, 6))
                particle.BackgroundTransparency = math.random(0, 0.4)
                local duration = math.random(10, 40) / (CONFIG.PARTICLE_SPEED * 10)
                local endX = startX + (math.random() - 0.5) * 0.3
                local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(particle, tweenInfo, {
                    Position = UDim2.new(endX, startOffsetX, -0.5, math.random(-20, 20)),
                    BackgroundTransparency = 1,
                    Size = UDim2.new(0, 0, 0, 0)
                })
                tween:Play()
                task.wait(duration)
            end
        end)
    end
end

local function teleportToPlayer(targetPlayer)
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character
    local targetCharacter = targetPlayer.Character
    if not (character and targetCharacter) then return end
    local humanoid = character:FindFirstChild("Humanoid")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetCharacter:FindFirstChild("UpperTorso") or targetCharacter:FindFirstChild("HumanoidRootPart")
    if not (humanoid and hrp and targetHRP) then return end
    local targetCFrame = targetHRP.CFrame
    local teleportPosition = targetCFrame.Position - (targetCFrame.LookVector * CONFIG.TELEPORT_DISTANCE)
    teleportPosition = teleportPosition + Vector3.new(0, CONFIG.TELEPORT_HEIGHT, 0)
    local particlepart = Instance.new("Part", workspace)
    particlepart.Transparency = 1
    particlepart.Anchored = true
    particlepart.CanCollide = false
    particlepart.Position = hrp.Position
    local transmitter1 = Instance.new("ParticleEmitter")
    transmitter1.Texture = "http://www.roblox.com/asset/?id=89296104222585"
    transmitter1.Size = NumberSequence.new(4)
    transmitter1.Lifetime = NumberRange.new(0.15, 0.15)
    transmitter1.Rate = 100
    transmitter1.TimeScale = 0.25
    transmitter1.VelocityInheritance = 1
    transmitter1.Drag = 5
    transmitter1.Parent = particlepart
    local particlepart2 = Instance.new("Part", workspace)
    particlepart2.Transparency = 1
    particlepart2.Anchored = true
    particlepart2.CanCollide = false
    particlepart2.Position = teleportPosition
    local transmitter2 = Instance.new("ParticleEmitter")
    transmitter2.Texture = "http://www.roblox.com/asset/?id=89296104222585"
    transmitter2.Size = NumberSequence.new(4)
    transmitter2.Lifetime = NumberRange.new(0.15, 0.15)
    transmitter2.Rate = 100
    transmitter2.TimeScale = 0.25
    transmitter2.VelocityInheritance = 1
    transmitter2.Drag = 5
    transmitter2.Parent = particlepart2
    local fadeTime = 0.1
    local tweenInfo = TweenInfo.new(fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local meshParts = {}
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("MeshPart") or part:IsA("Part") then
            table.insert(meshParts, part)
        end
    end
    for _, part in ipairs(meshParts) do
		if part.Name == "HumanoidRootPart" then continue end
        local tween = TweenService:Create(part, tweenInfo, {Transparency = 1})
        tween:Play()
    end
    task.wait(fadeTime)
    hrp.CFrame = CFrame.new(teleportPosition, targetHRP.Position)
    local teleportSound = Instance.new("Sound")
    teleportSound.SoundId = "rbxassetid://5066021887"
    teleportSound.Parent = hrp
    teleportSound.Volume = 0.5
    teleportSound:Play()
    for _, part in ipairs(meshParts) do
		if part.Name == "HumanoidRootPart" then continue end
        local tween = TweenService:Create(part, tweenInfo, {Transparency = 0})
        tween:Play()
    end
    game.Debris:AddItem(teleportSound, 2)
    game.Debris:AddItem(particlepart, 1)
    game.Debris:AddItem(particlepart2, 1)
end

local function getTextWidth(text, font, textSize)
    local size = TextService:GetTextSize(text, textSize, font, Vector2.new(2000, CONFIG.TAG_SIZE.Y.Offset))
    return math.ceil(size.X)
end

local function attachTagToHead(character, player, rankText)
    local head = character:FindFirstChild("Head")
    if not head then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    end
    for _, child in ipairs(head:GetChildren()) do
        if child.Name == "RankTag" then
            child:Destroy()
        end
    end
    local rankData = RankData[rankText] or { primary = Color3.fromRGB(20, 20, 20), AnimateName = false, JumpLetters = false, GlitchName = false, accent = Color3.fromRGB(114, 47, 55), emoji = "⭐", image = "" }
    local tag = Instance.new("BillboardGui")
    tag.Name = "RankTag"
    tag.Adornee = head
    tag.Size = CONFIG.TAG_SIZE
    tag.StudsOffset = CONFIG.TAG_OFFSET
    tag.AlwaysOnTop = true
    tag.MaxDistance = CONFIG.MAX_DISTANCE
    tag.LightInfluence = 0
    tag.ResetOnSpawn = false
    tag.Active = true
    local container = Instance.new("Frame")
    container.Name = "TagContainer"
    container.Size = UDim2.new(1, 0, 1, 0)
    container.BackgroundColor3 = rankData.primary
    container.BackgroundTransparency = 0.15
    container.BorderSizePixel = 0
    container.ClipsDescendants = true
    container.Parent = tag
    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = CONFIG.CORNER_RADIUS
    containerCorner.Parent = container
    local border = Instance.new("UIStroke")
    border.Color = rankData.accent
    border.Thickness = 2
    border.Transparency = 0.2
    border.Parent = container
    local clickButton = Instance.new("TextButton")
    clickButton.Name = "ClickButton"
    clickButton.Size = UDim2.new(1, 0, 1, 0)
    clickButton.BackgroundTransparency = 1
    clickButton.Text = ""
    clickButton.ZIndex = 10
    clickButton.AutoButtonColor = false
    clickButton.Active = true
    clickButton.Parent = container
    if player ~= Players.LocalPlayer then
        clickButton.MouseButton1Click:Connect(function()
            teleportToPlayer(player)
        end)
        clickButton.MouseEnter:Connect(function()
            TweenService:Create(container, TweenInfo.new(0.3), {BackgroundTransparency = 0}):Play()
        end)
        clickButton.MouseLeave:Connect(function()
            TweenService:Create(container, TweenInfo.new(0.3), {BackgroundTransparency = 0.15}):Play()
        end)
    end
    local particlesContainer = Instance.new("Frame")
    particlesContainer.Name = "ParticlesContainer"
    particlesContainer.Size = UDim2.new(1, 0, 1, 0)
    particlesContainer.BackgroundTransparency = 1
    particlesContainer.ZIndex = 2
    particlesContainer.ClipsDescendants = true
    particlesContainer.Parent = container
    local pContainerCorner = Instance.new("UICorner")
    pContainerCorner.CornerRadius = UDim.new(1, 0)
    pContainerCorner.Parent = particlesContainer
    createParticles(tag, particlesContainer, rankData.accent)
    local emojiLabel
    if rankData.UseImage and rankData.image ~= "" then
        emojiLabel = Instance.new("ImageLabel")
        emojiLabel.Name = "EmojiLabel"
        emojiLabel.Size = UDim2.new(0, 30, 0, 30)
        emojiLabel.Position = UDim2.new(0, 8, 0.5, -15)
        emojiLabel.BackgroundTransparency = 1
        emojiLabel.Image = rankData.image
        emojiLabel.ScaleType = Enum.ScaleType.Fit
        emojiLabel.ZIndex = 5
        emojiLabel.Parent = container
    else
        emojiLabel = Instance.new("TextLabel")
        emojiLabel.Name = "EmojiLabel"
        emojiLabel.Size = UDim2.new(0, 30, 0, 30)
        emojiLabel.Position = UDim2.new(0, 8, 0.5, -15)
        emojiLabel.BackgroundTransparency = 1
        emojiLabel.Text = rankData.emoji
        emojiLabel.TextSize = 22
        emojiLabel.Font = Enum.Font.GothamBold
        emojiLabel.TextColor3 = Color3.new(1, 1, 1)
        emojiLabel.ZIndex = 5
        emojiLabel.Parent = container
    end
    local displayNameLabel = Instance.new("TextLabel")
    displayNameLabel.Name = "DisplayNameLabel"
    displayNameLabel.BackgroundTransparency = 1
    local fullDisplayName = player.DisplayName or player.Name
    displayNameLabel.Text = "<font color='rgb(" .. math.floor(rankData.accent.R * 255) .. "," .. math.floor(rankData.accent.G * 255) .. "," .. math.floor(rankData.accent.B * 255) .. ")'>@" .. fullDisplayName .. "</font>"
    displayNameLabel.RichText = true
    displayNameLabel.TextSize = 10
    displayNameLabel.Font = Enum.Font.GothamBold
    displayNameLabel.TextXAlignment = Enum.TextXAlignment.Left
    displayNameLabel.ZIndex = 5
    local rankLabel = Instance.new("TextLabel")
    rankLabel.Name = "RankLabel"
    rankLabel.BackgroundTransparency = 1
    rankLabel.Text = rankText
    rankLabel.TextSize = 14
    rankLabel.Font = Enum.Font.GothamBold
    rankLabel.TextColor3 = rankData.accent
    rankLabel.TextXAlignment = Enum.TextXAlignment.Left
    rankLabel.ZIndex = 5
    spawn(function()
        while tag and tag.Parent do
            if rankData.AnimateName then
                local name = rankText
                local blinkCount = 5
                local typingDelay = 0.1
                local blinkDelay = 0.5
                for i = 1, #name do
                    rankLabel.Text = string.sub(name, 1, i) .. "|"
                    wait(typingDelay)
                end
                for i = 1, blinkCount do
                    rankLabel.Text = name .. "|"
                    wait(blinkDelay)
                    rankLabel.Text = name
                    wait(blinkDelay)
                end
                for i = #name, 1, -1 do
                    rankLabel.Text = string.sub(name, 1, i) .. "|"
                    wait(typingDelay)
                end
                for i = 1, blinkCount do
                    rankLabel.Text = "|"
                    wait(blinkDelay)
                    rankLabel.Text = ""
                    wait(blinkDelay)
                end
            elseif rankData.JumpLetters then
                local text = rankText
                local jumpDuration = 0.2
                local pauseDuration = 0.5
                local jumpIterations = 3
                for iteration = 1, jumpIterations do
                    for i = 1, #text do
                        local before = string.sub(text, 1, i-1)
                        local current = string.sub(text, i, i)
                        local after = string.sub(text, i+1)
                        rankLabel.Text = before .. string.lower(current) .. after
                        wait(jumpDuration)
                        rankLabel.Text = text
                        wait(jumpDuration)
                    end
                    wait(pauseDuration)
                end
            elseif rankData.GlitchName then
                local text = rankText
                local glitchDuration = 0.05
                local normalDuration = 0.3
                local glitchCycles = 5
                local glitchIntensity = 3
                local glitchChars = {"@", "#", "$", "%", "&", "!"}
                for cycle = 1, glitchCycles do
                    rankLabel.Text = text
                    wait(normalDuration)
                    for artifact = 1, glitchIntensity do
                        local glitchedText = ""
                        for i = 1, #text do
                            if math.random() < 0.3 then
                                local randomChoice = math.random(1, 10)
                                if randomChoice <= 7 then
                                    glitchedText = glitchedText .. glitchChars[math.random(1, #glitchChars)]
                                elseif randomChoice <= 9 then
                                    local char = string.sub(text, i, i)
                                    if char == string.upper(char) then
                                        glitchedText = glitchedText .. string.lower(char)
                                    else
                                        glitchedText = glitchedText .. string.upper(char)
                                    end
                                else
                                    glitchedText = glitchedText .. " "
                                end
                            else
                                glitchedText = glitchedText .. string.sub(text, i, i)
                            end
                        end
                        if math.random() < 0.3 then
                            local spaces = string.rep(" ", math.random(1, 3))
                            glitchedText = spaces .. glitchedText
                        end
                        if math.random() < 0.3 then
                            local extraGlitch = ""
                            for i = 1, math.random(1, 3) do
                                extraGlitch = extraGlitch .. glitchChars[math.random(1, #glitchChars)]
                            end
                            glitchedText = glitchedText .. extraGlitch
                        end
                        rankLabel.Text = glitchedText
                        wait(glitchDuration)
                    end
                    rankLabel.Text = text
                    wait(normalDuration * 2)
                end
                rankLabel.Text = text
                wait(normalDuration * 3)
            else
                rankLabel.Text = rankText
                wait(1)
            end
        end
    end)
    local sidePadding = 16
    local emojiWidth = 36
    local emojiLabelWidth = 30
    local emojiLeftPadding = 8
    local rankWidthActual = getTextWidth(rankLabel.Text, rankLabel.Font, rankLabel.TextSize)
    local displayNameWidthActual = getTextWidth("@" .. fullDisplayName, displayNameLabel.Font, displayNameLabel.TextSize)
    local maxTextWidth = math.max(rankWidthActual, displayNameWidthActual)
    local totalWidth = emojiLeftPadding + emojiLabelWidth + sidePadding + maxTextWidth + sidePadding
    tag.Size = UDim2.new(0, totalWidth, 0, CONFIG.TAG_SIZE.Y.Offset)
    container.Size = UDim2.new(1, 0, 1, 0)
    emojiLabel.Position = UDim2.new(0, emojiLeftPadding, 0.5, -15)
    emojiLabel.Size = UDim2.new(0, emojiLabelWidth, 0, 30)
    local textBlockXOffset = emojiLeftPadding + emojiLabelWidth + sidePadding
    rankLabel.Position = UDim2.new(0, textBlockXOffset, 0, 3)
    rankLabel.Size = UDim2.new(0, rankWidthActual, 0, 16)
    rankLabel.Parent = container
    displayNameLabel.Position = UDim2.new(0, textBlockXOffset, 0, 17)
    displayNameLabel.Size = UDim2.new(0, displayNameWidthActual, 0, 16)
    displayNameLabel.Parent = container
    local isMinimized = false
    local FULL_SIZE = UDim2.new(0, totalWidth, 0, CONFIG.TAG_SIZE.Y.Offset)
    local MINI_SIZE = UDim2.new(0, 40, 0, 40)
    local MINI_OFFSET = Vector3.new(0, 1.0, 0)
    local activeTween = true
    spawn(function()
        while activeTween and tag and tag.Parent do
            if character and head and head.Parent and Players.LocalPlayer and Players.LocalPlayer.Character then
                local localHead = Players.LocalPlayer.Character:FindFirstChild("Head")
                if localHead then
                    local distance = (head.Position - localHead.Position).Magnitude
                    if distance > (CONFIG.DISTANCE_THRESHOLD + CONFIG.HYSTERESIS) and not isMinimized then
                        isMinimized = true
                        TweenService:Create(tag, TweenInfo.new(0.5), { Size = MINI_SIZE, StudsOffset = MINI_OFFSET }):Play()
                        TweenService:Create(rankLabel, TweenInfo.new(0.5), { TextTransparency = 1 }):Play()
                        TweenService:Create(displayNameLabel, TweenInfo.new(0.5), { TextTransparency = 1 }):Play()
                        TweenService:Create(emojiLabel, TweenInfo.new(0.5), { Position = UDim2.new(0.5, -15, 0.5, -15), Size = UDim2.new(0, 30, 0, 30)}):Play()
                        TweenService:Create(containerCorner, TweenInfo.new(0.5), { CornerRadius = UDim.new(1, 0) }):Play()
                    elseif distance < (CONFIG.DISTANCE_THRESHOLD - CONFIG.HYSTERESIS) and isMinimized then
                        isMinimized = false
                        TweenService:Create(tag, TweenInfo.new(0.5), { Size = FULL_SIZE, StudsOffset = CONFIG.TAG_OFFSET }):Play()
                        TweenService:Create(rankLabel, TweenInfo.new(0.5), { TextTransparency = 0 }):Play()
                        TweenService:Create(displayNameLabel, TweenInfo.new(0.5), { TextTransparency = 0 }):Play()
                        TweenService:Create(emojiLabel, TweenInfo.new(0.5), { Position = UDim2.new(0, 8, 0.5, -15), Size = UDim2.new(0, 30, 0, 30)}):Play()
                        TweenService:Create(containerCorner, TweenInfo.new(0.5), { CornerRadius = CONFIG.CORNER_RADIUS }):Play()
                    end
                end
            else
                activeTween = false
            end
            task.wait(0.2)
        end
    end)
    tag.AncestryChanged:Connect(function(_, parent)
        if not parent then
            activeTween = false
        end
    end)
    Players.PlayerRemoving:Connect(function(removedPlayer)
        if removedPlayer == player then
            if tag and tag.Parent then
                tag:Destroy()
            end
            activeTween = false
        end
    end)
    tag.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return tag
end

local localTagChoice = nil

local function showAKAdminNotification(player)
    local playerName = player.Name
    local notifMessage = "@" .. playerName .. " Has executed AK ADMIN"
    local success, thumb = pcall(function()
        return Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size100x100)
    end)
    if not success then thumb = "" end
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AKAdminNotificationGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    local frame = Instance.new("Frame")
    frame.Name = "NotificationFrame"
    frame.Size = UDim2.new(0, 250, 0, 60) -- MODIFIED LINE: Smaller size
    frame.Position = UDim2.new(1, 10, 1, 10) 
    frame.BackgroundColor3 = Color3.fromRGB(180, 160, 220) -- MODIFIED LINE: Light purple background
    frame.BackgroundTransparency = 0.1
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 20) 
    uiCorner.Parent = frame
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Transparency = 0.8
    stroke.Thickness = 0.5
    stroke.Parent = frame
    local imageLabel = Instance.new("ImageLabel")
    imageLabel.Name = "ProfilePic"
    imageLabel.Size = UDim2.new(0, 50, 0, 50)
    imageLabel.Position = UDim2.new(0, 10, 0, 5) -- MODIFIED LINE: Adjusted Y position for new height
    imageLabel.BackgroundTransparency = 1
    imageLabel.Image = thumb
    imageLabel.Parent = frame
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "NotificationText"
    textLabel.Size = UDim2.new(1, -70, 1, 0)
    textLabel.Position = UDim2.new(0, 60, 0, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = notifMessage
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 16
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextWrapped = true
    textLabel.TextXAlignment = Enum.TextXAlignment.Center
    textLabel.Parent = frame
    local tweenIn = TweenService:Create(frame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Position = UDim2.new(1, -260, 1, -70)}) -- MODIFIED LINE: Adjusted tween-in position for new size
    tweenIn:Play()
    tweenIn.Completed:Wait()
    task.wait(3)
    local tweenOut = TweenService:Create(frame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
        {Position = UDim2.new(1, 10, 1, 10)}) 
    tweenOut:Play()
    tweenOut.Completed:Wait()
    screenGui:Destroy()
end

local function createNotificationUI()
    if game:GetService("CoreGui"):FindFirstChild("TagNotification") or localTagChoice ~= nil then
        return nil, nil, nil, nil
    end
    local gui = Instance.new("ScreenGui")
    gui.Name = "TagNotification"
    gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local frame = Instance.new("Frame")
    frame.Name = "Frame"
    frame.Size = UDim2.new(0, 280, 0, 140)
    frame.Position = UDim2.new(0.5, -140, 0.5, -70)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BackgroundTransparency = 0
    frame.BorderSizePixel = 0
    frame.Parent = gui
    local notifCorner = Instance.new("UICorner")
    notifCorner.CornerRadius = UDim.new(0, 8)
    notifCorner.Parent = frame
    local blur = Instance.new("BlurEffect")
    blur.Size = 10
    blur.Parent = Lighting
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Transparency = 0.8
    stroke.Thickness = 1
    stroke.Parent = frame
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 35)
    title.Position = UDim2.new(0, 0, 0, 10)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextColor3 = Color3.new(1, 1, 1)
    title.TextSize = 16
    title.Text = "Tag Visibility Settings"
    title.Parent = frame
    local messageLabel = Instance.new("TextLabel")
    messageLabel.Size = UDim2.new(0.9, 0, 0, 40)
    messageLabel.Position = UDim2.new(0.05, 0, 0.35, 0)
    messageLabel.BackgroundTransparency = 1
    messageLabel.Font = Enum.Font.Gotham
    messageLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9)
    messageLabel.TextSize = 14
    messageLabel.TextWrapped = true
    messageLabel.Text = "Would you like to display your rank tag above your character?"
    messageLabel.Parent = frame
    local function createButton(text, position, color)
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0.35, 0, 0, 30)
        button.Position = position
        button.BackgroundColor3 = color
        button.BorderSizePixel = 0
        button.Font = Enum.Font.GothamBold
        button.TextColor3 = Color3.new(1, 1, 1)
        button.TextSize = 14
        button.Text = text
        button.AutoButtonColor = false
        button.BackgroundTransparency = 0
        button.Parent = frame
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 6)
        buttonCorner.Parent = button
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.15), {BackgroundTransparency = 0.2}):Play()
        end)
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.15), {BackgroundTransparency = 0}):Play()
        end)
        return button
    end
    local yesButton = createButton("Yes", UDim2.new(0.1, 0, 0.7, 0), Color3.fromRGB(46, 204, 113))
    local noButton = createButton("No", UDim2.new(0.55, 0, 0.7, 0), Color3.fromRGB(231, 76, 60))
    return gui, yesButton, noButton, blur
end

local charAddedConn
local notificationGuiVisible = false

local function attachTagAndConnect(player, rankText)
    if player.Character then
        attachTagToHead(player.Character, player, rankText)
    end
    if charAddedConn then charAddedConn:Disconnect() end
    charAddedConn = player.CharacterAdded:Connect(function(character)
        task.wait()
        attachTagToHead(character, player, rankText)
    end)
    local playerRemovingConn
    playerRemovingConn = Players.PlayerRemoving:Connect(function(leavingPlayer)
        if leavingPlayer == player then
            if charAddedConn then charAddedConn:Disconnect() end
            if playerRemovingConn then playerRemovingConn:Disconnect() end
        end
    end)
end

local function cleanupNotificationUI(gui, blur, yesConn, noConn)
    if yesConn then yesConn:Disconnect() end
    if noConn then noConn:Disconnect() end
    if gui then gui:Destroy() end
    if blur and blur.Parent then
        blur:Destroy()
    end
    notificationGuiVisible = false
end

local function handleUserChoice(player, rankText, choice)
    if choice then
        attachTagAndConnect(player, rankText)
    end
    localTagChoice = choice
end

local function createTag(player, rankText, showPrompt)
    if showPrompt and player == Players.LocalPlayer then
        if localTagChoice ~= nil then
            if localTagChoice then
                attachTagAndConnect(player, rankText)
            end
            return
        end
        if notificationGuiVisible then
            return
        end
        local gui, yesButton, noButton, blur = createNotificationUI()
        if not gui then return end
        local playerGui = player:WaitForChild("PlayerGui", 5)
        if not playerGui then
            if blur then blur:Destroy() end
            if gui then gui:Destroy() end
            return
        end
        gui.Parent = playerGui
        notificationGuiVisible = true
        local yesConn, noConn
        yesConn = yesButton.MouseButton1Click:Connect(function()
            handleUserChoice(player, rankText, true)
            cleanupNotificationUI(gui, blur, yesConn, noConn)
        end)
        noConn = noButton.MouseButton1Click:Connect(function()
            handleUserChoice(player, rankText, false)
            cleanupNotificationUI(gui, blur, yesConn, noConn)
        end)
    else
        attachTagAndConnect(player, rankText)
    end
end

local function applyPlayerTag(player)
    if not player or not player:IsDescendantOf(Players) then
        return
    end
    local showPrompt = (player == Players.LocalPlayer)
    local assignedTag = nil
    local playerNameLower = player.Name:lower()

    -- Prioritize rank from playerToTag
    if playerToTag[playerNameLower] then
        assignedTag = playerToTag[playerNameLower]
    elseif ChatWhitelist[playerNameLower] then
        assignedTag = "AK USER"
    else
    end

    -- Clean up existing tags
    local localPlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    if player.Character and player.Character:FindFirstChild("Head") then
        local head = player.Character.Head
        for _, child in ipairs(head:GetChildren()) do
            if child:IsA("BillboardGui") and child.Name == "RankTag" then
                child:Destroy()
            end
        end
        for _, gui in ipairs(localPlayerGui:GetChildren()) do
            if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == head then
                gui:Destroy()
            end
        end
    end

    -- Apply the assigned tag if it exists
    if assignedTag then
        createTag(player, assignedTag, showPrompt)
    end
end

local chatConnections = {}

local function setupChatListener(player)
    if chatConnections[player] then
        return
    end
	
    local conn = player.Chatted:Connect(function(msg)
        if not player or not player:IsDescendantOf(Players) then
            if chatConnections[player] then
                chatConnections[player]:Disconnect()
            end
            chatConnections[player] = nil
            return
        end
        if modifyString(msg:lower()) == modifiedMessage:lower() then
            local playerNameLower = player.Name:lower()
            -- Only add to ChatWhitelist if no rank in playerToTag
            if not playerToTag[playerNameLower] and not ChatWhitelist[playerNameLower] then
                ChatWhitelist[playerNameLower] = true
                applyPlayerTag(player)
                showAKAdminNotification(player)
            else
            end
        end
    end)
    chatConnections[player] = conn
end

local localPlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

spawn(function()
    while task.wait(2) do
        local validAdornees = {}
        local currentPlayers = Players:GetPlayers()
        for _, player in ipairs(currentPlayers) do
            if player.Character and player.Character:FindFirstChild("Head") then
                table.insert(validAdornees, player.Character.Head)
                local hasTag = false
                for _, gui in ipairs(localPlayerGui:GetChildren()) do
                    if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == player.Character.Head then
                        hasTag = true
                        break
                    end
                end
                local shouldHaveTag = playerToTag[player.Name:lower()] or ChatWhitelist[player.Name:lower()]
                if shouldHaveTag and not hasTag then
                    applyPlayerTag(player)
                end
            end
        end
        for _, gui in ipairs(localPlayerGui:GetChildren()) do
            if gui:IsA("BillboardGui") and gui.Name == "RankTag" then
                local adornee = gui.Adornee
                if not adornee or not adornee:IsDescendantOf(workspace) or not table.find(validAdornees, adornee) then
                    gui:Destroy()
                end
            end
        end
    end
end)

for _, player in ipairs(Players:GetPlayers()) do
    task.spawn(applyPlayerTag, player)
    task.spawn(setupChatListener, player)
end

Players.PlayerAdded:Connect(function(player)
    task.wait(0.5)
    task.spawn(setupChatListener, player)
    task.spawn(applyPlayerTag, player)
end)

Players.PlayerRemoving:Connect(function(player)
    if chatConnections[player] then
        chatConnections[player]:Disconnect()
        chatConnections[player] = nil
    end
    local playerHead = player.Character and player.Character:FindFirstChild("Head")
    if playerHead then
        for _, gui in ipairs(localPlayerGui:GetChildren()) do
            if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == playerHead then
                gui:Destroy()
            end
        end
    end
    if player == Players.LocalPlayer then
        local playerGui = player:FindFirstChild("PlayerGui")
        if playerGui then
            local notification = playerGui:FindFirstChild("TagNotification")
            if notification then
                notification:Destroy()
                local blur = Lighting:FindFirstChild("BlurEffect")
                if blur then
                    blur:Destroy()
                end
            end
        end
        localTagChoice = nil
    end
end)

return {
    refreshTags = function()
        for _, player in ipairs(Players:GetPlayers()) do
            task.spawn(applyPlayerTag, player)
        end
    end,
    forceTag = function(player, rankType)
        if not player or not player:IsDescendantOf(Players) then
            return false
        end
        if RankData[rankType] then
            if player.Character and player.Character:FindFirstChild("Head") then
                local head = player.Character.Head
                for _, child in ipairs(head:GetChildren()) do
                    if child.Name == "RankTag" then
                        child:Destroy()
                    end
                end
            end
            for _, gui in ipairs(localPlayerGui:GetChildren()) do
                if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee and gui.Adornee.Parent == player.Character then
                    gui:Destroy()
                end
            end
            createTag(player, rankType, player == Players.LocalPlayer)
            return true
        else
            return false
        end
    end
}


--[[ trip ]]
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")  -- (if you need tweens later; not used here)
local StarterGui = game:GetService("StarterGui")

local Player = Players.LocalPlayer

-------------------------------------------------
-- Core Notification: Display Trip Action Instructions
-------------------------------------------------
StarterGui:SetCore("SendNotification", {
    Title = "Trip Action Instructions",
    Text = "Press T on PC or tap the button on mobile to trip!",
    Duration = 5
})

-------------------------------------------------
-- Trip Function: Changes state and sets velocity to simulate a trip.
-------------------------------------------------
local function trip()
    local character = Player.Character or Player.CharacterAdded:Wait()
    local hum = character:FindFirstChildOfClass("Humanoid")
    local root = character:FindFirstChild("HumanoidRootPart")
    if hum and root then
        hum:ChangeState(0)
        root.Velocity = root.CFrame.LookVector * 35
    end
end

-------------------------------------------------
-- PC Users: Bind the T key to trigger the trip.
-------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.T then
        trip()
    end
end)

-------------------------------------------------
-- Mobile Users: Create a GUI button if touch is enabled.
-------------------------------------------------
if UserInputService.TouchEnabled then
    local PlayerGui = Player:WaitForChild("PlayerGui")
    
    -- Create a ScreenGui to hold the button.
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "TripGui"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = PlayerGui

    -- Create the Trip button.
    local TripButton = Instance.new("TextButton")
    TripButton.Name = "TripButton"
    TripButton.Size = UDim2.new(0, 60, 0, 60)
    -- The position is adjusted to 0.78 on the X-axis to move it slightly to the right.
    TripButton.Position = UDim2.new(0.78, 0, 0.7, 0)
    TripButton.BackgroundColor3 = Color3.fromRGB(128, 128, 128)
    TripButton.BackgroundTransparency = 0.3
    TripButton.Text = "🚀"
    TripButton.TextSize = 28
    TripButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    TripButton.Parent = ScreenGui

    -- Make the button round.
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(1, 0)
    UICorner.Parent = TripButton

    -- Bind the trip action to the button click.
    TripButton.MouseButton1Click:Connect(trip)
end


--[[ antiall ]]


local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character, Humanoid, RootPart
local Camera = workspace.CurrentCamera
local IsVoiding = false

-- Prevent objects from being destroyed by the void
workspace.FallenPartsDestroyHeight = math.huge * -1 -- Removes the void destruction limit

-- Create GUI Elements
local ScreenGui = Instance.new("ScreenGui")
local Button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local UIStroke = Instance.new("UIStroke")

ScreenGui.Parent = Player:WaitForChild("PlayerGui")
ScreenGui.Name = "VoidGui"

-- Button Setup
Button.Parent = ScreenGui
Button.Name = "VoidButton"
Button.Size = UDim2.new(0, 50, 0, 50) -- Small circle button
Button.Position = UDim2.new(1, -60, 0.5, -25) -- Middle right of the screen
Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Dark gray
Button.BackgroundTransparency = 0.5 -- Semi-transparent button
Button.BorderSizePixel = 0
Button.Text = "V" -- Simple "V" for Void
Button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
Button.Font = Enum.Font.GothamBold
Button.TextSize = 20
Button.Active = true
Button.Draggable = true -- Allows dragging on PC

-- Add Rounded Corners and Outline
UICorner.Parent = Button
UICorner.CornerRadius = UDim.new(1, 0) -- Makes the button a perfect circle

UIStroke.Parent = Button
UIStroke.Color = Color3.fromRGB(255, 255, 255) -- White border
UIStroke.Thickness = 1

-- Make it Draggable for All Devices
local dragging = false
local dragInput, dragStart, startPos

Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = Button.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- Voiding Function

-- Camera stuff
local function VoidTeleport()
    workspace.Camera.CameraType = Enum.CameraType.Fixed;

    local HRoot = game:GetService("Players").LocalPlayer.Character.Humanoid.RootPart;
    local Pos = HRoot.CFrame;
    HRoot.CFrame = Pos + Vector3.new(0, -1e3, 0);
    task.wait(.1) -- try messing with this value
    HRoot.CFrame = Pos;

    workspace.Camera.CameraType = Enum.CameraType.Custom;
end

local function VoidAndReturn()
    Character = Player.Character
    Humanoid = Character and Character:FindFirstChildWhichIsA("Humanoid")
    RootPart = Humanoid and Humanoid.RootPart

    if RootPart and Humanoid and not IsVoiding then
        IsVoiding = true

        -- Teleport yourself to the void
        VoidTeleport()

        IsVoiding = false
    end
end


-- Connect Button Click to Void Function
Button.MouseButton1Click:Connect(VoidAndReturn)


--[[ bodyletter ]]
-- BodyLetter; everything from German to Englisch. Also make the gui smaller and rounded cornered

-- SERVICES
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- Configuration: All body parts are used automatically
local bodyParts = { "Head", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand", "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot", "RightUpperLeg", "RightLowerLeg", "RightFoot", "HumanoidRootPart" }

-- Global Variables and State
local ghostEnabled = false
local originalCharacter
local ghostClone
local originalCFrame
local originalAnimateScript
local updateConnection
local renderStepConnection
local previousPositions = {}
local lastUpdateTime = 0

-- Scaling factor for the letter shape (adjustable via GUI slider)
local letterSize = 5 -- Default value
-- The currently selected letter (as a string, e.g., "A", "B", etc.)
local selectedLetter = "A"

-- Variables for text animation
local animationText = ""
local isAnimationPlaying = false
local animationSpeed = 2.0 -- Seconds per letter
local animationIndex = 1
local animationConnection

-- LETTER SHAPES (Revised for better representation)
local letterShapes = {
    ["A"] = {
        Vector2.new(-0.5, -0.5), Vector2.new(0, 0.5), Vector2.new(0.5, -0.5), -- Base shape
        Vector2.new(0.25, -0.1), Vector2.new(-0.25, -0.1) -- Middle bar
    },
    ["B"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.5), -- Left stroke
        Vector2.new(-0.5, -0.5), Vector2.new(0.1, -0.5), -- Bottom horizontal line
        Vector2.new(0.1, -0.5), Vector2.new(0.4, -0.4), Vector2.new(0.5, -0.25), Vector2.new(0.4, -0.1), Vector2.new(0.1, 0), -- Lower bow
        Vector2.new(-0.5, 0), Vector2.new(0.1, 0), -- Middle line
        Vector2.new(0.1, 0), Vector2.new(0.4, 0.1), Vector2.new(0.5, 0.25), Vector2.new(0.4, 0.4), Vector2.new(0.1, 0.5), -- Upper bow
        Vector2.new(0.1, 0.5), Vector2.new(-0.5, 0.5) -- Top horizontal line
    },
    ["C"] = {
        Vector2.new(0.5, 0.3), Vector2.new(0.3, 0.5), Vector2.new(-0.3, 0.5), -- Top curve
        Vector2.new(-0.5, 0.3), Vector2.new(-0.5, -0.3), -- Left side
        Vector2.new(-0.3, -0.5), Vector2.new(0.3, -0.5), Vector2.new(0.5, -0.3) -- Bottom curve
    },
    ["D"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.5), -- Left stroke
        Vector2.new(0.2, -0.5), Vector2.new(0.5, -0.2), -- Bottom curve
        Vector2.new(0.5, 0.2), Vector2.new(0.2, 0.5), -- Top curve
        Vector2.new(-0.5, 0.5) -- Back to start
    },
    ["E"] = {
        Vector2.new(0.5, 0.5), Vector2.new(-0.5, 0.5), -- Top line
        Vector2.new(-0.5, 0), Vector2.new(0.3, 0), -- Middle line
        Vector2.new(-0.5, 0), Vector2.new(-0.5, -0.5), -- Left line bottom
        Vector2.new(0.5, -0.5) -- Bottom line
    },
    ["F"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(0.5, 0.5), -- Top line
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.5), -- Left line continuous
        Vector2.new(-0.5, 0.1), Vector2.new(0.3, 0.1) -- Middle line (slightly shifted up)
    },
    ["G"] = {
        Vector2.new(0.5, 0.3), Vector2.new(0.3, 0.5), Vector2.new(-0.2, 0.5), Vector2.new(-0.4, 0.4), -- Top curve
        Vector2.new(-0.5, 0.2), Vector2.new(-0.5, -0.2), Vector2.new(-0.4, -0.4), Vector2.new(-0.2, -0.5), -- Left/bottom curve
        Vector2.new(0.2, -0.5), Vector2.new(0.4, -0.4), Vector2.new(0.5, -0.2), -- Bottom right curve
        Vector2.new(0.5, 0), Vector2.new(0.5, -0.1), -- Right line
        Vector2.new(0.5, 0), Vector2.new(0.1, 0) -- Horizontal stroke left
    },
    ["H"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.5), -- Left line
        Vector2.new(-0.5, 0), Vector2.new(-0.3, 0), -- Left part of middle line
        Vector2.new(-0.3, 0), Vector2.new(0.3, 0), -- Middle part of middle line
        Vector2.new(0.3, 0), Vector2.new(0.5, 0), -- Right part of middle line
        Vector2.new(0.5, 0.5), Vector2.new(0.5, -0.5) -- Right line
    },
    ["I"] = {
        Vector2.new(-0.2, 0.5), Vector2.new(0.2, 0.5), -- Top line
        Vector2.new(0, 0.5), Vector2.new(0, -0.5), -- Middle line
        Vector2.new(-0.2, -0.5), Vector2.new(0.2, -0.5) -- Bottom line
    },
    ["J"] = {
        Vector2.new(-0.2, 0.5), Vector2.new(0.2, 0.5), -- Top line
        Vector2.new(0.2, 0.5), Vector2.new(0.2, -0.3), -- Right line
        Vector2.new(0.2, -0.3), Vector2.new(0, -0.5), Vector2.new(-0.2, -0.3), -- Bottom curve
        Vector2.new(-0.2, -0.3), Vector2.new(-0.2, -0.1) -- Left hook
    },
    ["K"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.5), -- Left stroke
        Vector2.new(-0.5, 0.1), Vector2.new(-0.3, 0.1), -- Middle line start
        Vector2.new(-0.3, 0.1), Vector2.new(0, 0.3), -- Middle part up
        Vector2.new(0, 0.3), Vector2.new(0.5, 0.5), -- Top stroke end
        Vector2.new(-0.3, 0.1), Vector2.new(0, -0.1), -- Middle part down
        Vector2.new(0, -0.1), Vector2.new(0.5, -0.5) -- Bottom stroke end
    },
    ["L"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.5), -- Left stroke
        Vector2.new(-0.5, -0.5), Vector2.new(0.5, -0.5) -- Bottom stroke
    },
    ["M"] = {
        Vector2.new(-0.5, -0.5), Vector2.new(-0.5, 0.5), -- Left stroke
        Vector2.new(-0.5, 0.5), Vector2.new(0, 0), -- Left diagonal
        Vector2.new(0, 0), Vector2.new(0.5, 0.5), -- Right diagonal
        Vector2.new(0.5, 0.5), Vector2.new(0.5, -0.5) -- Right stroke
    },
    ["N"] = {
        Vector2.new(-0.5, -0.5), Vector2.new(-0.5, 0.5), -- Left stroke
        Vector2.new(-0.5, 0.5), Vector2.new(0.5, -0.5), -- Diagonal
        Vector2.new(0.5, -0.5), Vector2.new(0.5, 0.5) -- Right stroke
    },
    ["O"] = {
        Vector2.new(0, 0.5), Vector2.new(-0.3, 0.4), Vector2.new(-0.5, 0.2), -- Top left curve
        Vector2.new(-0.5, -0.2), Vector2.new(-0.3, -0.4), Vector2.new(0, -0.5), -- Bottom left curve
        Vector2.new(0.3, -0.4), Vector2.new(0.5, -0.2), -- Bottom right curve
        Vector2.new(0.5, 0.2), Vector2.new(0.3, 0.4), Vector2.new(0, 0.5) -- Top right curve
    },
    ["P"] = {
        Vector2.new(-0.5, -0.5), Vector2.new(-0.5, 0.5), -- Left stroke
        Vector2.new(-0.5, 0.5), Vector2.new(0.2, 0.5), -- Top line
        Vector2.new(0.2, 0.5), Vector2.new(0.4, 0.3), Vector2.new(0.4, 0.1), Vector2.new(0.2, 0), -- Bow
        Vector2.new(0.2, 0), Vector2.new(-0.5, 0) -- Back to stroke
    },
    ["Q"] = {
        Vector2.new(0, 0.5), Vector2.new(-0.3, 0.4), Vector2.new(-0.5, 0.2), -- Top left curve
        Vector2.new(-0.5, -0.2), Vector2.new(-0.3, -0.4), Vector2.new(0, -0.5), -- Bottom left curve
        Vector2.new(0.3, -0.4), Vector2.new(0.5, -0.2), -- Bottom right curve
        Vector2.new(0.5, 0.2), Vector2.new(0.3, 0.4), Vector2.new(0, 0.5), -- Top right curve
        Vector2.new(0.1, -0.3), Vector2.new(0.5, -0.6) -- Tail
    },
    ["R"] = {
        Vector2.new(-0.5, -0.5), Vector2.new(-0.5, 0.5), -- Left stroke
        Vector2.new(-0.5, 0.5), Vector2.new(0.2, 0.5), -- Top line
        Vector2.new(0.2, 0.5), Vector2.new(0.4, 0.3), Vector2.new(0.4, 0.1), Vector2.new(0.2, 0), -- Bow
        Vector2.new(0.2, 0), Vector2.new(-0.5, 0), -- Back to stroke
        Vector2.new(0.2, 0), Vector2.new(0.5, -0.5) -- Right leg
    },
    ["S"] = {
        Vector2.new(0.4, 0.5), Vector2.new(0, 0.5), Vector2.new(-0.4, 0.3), -- Top curve
        Vector2.new(-0.4, 0.3), Vector2.new(-0.2, 0), -- Top middle
        Vector2.new(-0.2, 0), Vector2.new(0.2, 0), -- Middle part
        Vector2.new(0.2, 0), Vector2.new(0.4, -0.3), -- Bottom middle
        Vector2.new(0.4, -0.3), Vector2.new(0, -0.5), Vector2.new(-0.4, -0.5) -- Bottom curve
    },
    ["T"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(0.5, 0.5), -- Top line
        Vector2.new(0, 0.5), Vector2.new(0, -0.5) -- Middle line
    },
    ["U"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.5, -0.3), -- Left line
        Vector2.new(-0.5, -0.3), Vector2.new(-0.3, -0.5), Vector2.new(0.3, -0.5), -- Bottom curve
        Vector2.new(0.3, -0.5), Vector2.new(0.5, -0.3), Vector2.new(0.5, 0.5) -- Right line
    },
    ["V"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(0, -0.5), Vector2.new(0.5, 0.5)
    },
    ["W"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(-0.3, -0.5), -- Left outer line
        Vector2.new(-0.3, -0.5), Vector2.new(0, 0), -- Left inner line
        Vector2.new(0, 0), Vector2.new(0.3, -0.5), -- Right inner line
        Vector2.new(0.3, -0.5), Vector2.new(0.5, 0.5) -- Right outer line
    },
    ["X"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(0.5, -0.5), -- Diagonal top-left to bottom-right
        Vector2.new(-0.5, -0.5), Vector2.new(0.5, 0.5) -- Diagonal bottom-left to top-right
    },
    ["Y"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(0, 0), -- Left top stroke
        Vector2.new(0.5, 0.5), Vector2.new(0, 0), -- Right top stroke
        Vector2.new(0, 0), Vector2.new(0, -0.5) -- Bottom stroke
    },
    ["Z"] = {
        Vector2.new(-0.5, 0.5), Vector2.new(0.5, 0.5), -- Top line
        Vector2.new(0.5, 0.5), Vector2.new(-0.5, -0.5), -- Diagonal
        Vector2.new(-0.5, -0.5), Vector2.new(0.5, -0.5) -- Bottom line
    },
    ["Ä"] = {},
    ["Ö"] = {},
    ["Ü"] = {}
}

-- Helper function: Returns the letter shape for the requested letter.
local function getLetterShape(letter)
    local upper = string.upper(letter)
    return letterShapes[upper] or {}
end

-- Helper function: Linear interpolation (Lerp) for Vector2
local function lerpVector2(a, b, t)
    return a + (b - a) * t
end

-- Helper function: Generates numSamples points, evenly distributed along the path.
local function sampleLetterPoints(points, numSamples)
    local samples = {}
    if #points < 1 then
        for i = 1, numSamples do table.insert(samples, Vector2.new(0,0)) end
        return samples
    elseif #points == 1 then
        for i = 1, numSamples do table.insert(samples, points[1]) end
        return samples
    end

    local segments = {}
    local totalLength = 0
    for i = 1, #points - 1 do
        local segLength = (points[i+1] - points[i]).Magnitude
        totalLength = totalLength + segLength
        table.insert(segments, {start = points[i], finish = points[i+1], length = segLength})
    end

    if totalLength == 0 then
        for i = 1, numSamples do table.insert(samples, points[1]) end
        return samples
    end

    local sampleDistance = totalLength / (numSamples - 1)
    if numSamples == 1 then sampleDistance = 0 end

    local currentDist = 0
    local currentSeg = 1
    local segStartDist = 0

    for i = 1, numSamples do
        while currentSeg <= #segments and (segStartDist + segments[currentSeg].length) < currentDist - 0.0001 do
            segStartDist = segStartDist + segments[currentSeg].length
            currentSeg = currentSeg + 1
        end
        currentSeg = math.min(currentSeg, #segments)

        local seg = segments[currentSeg]
        local t = 0
        if seg.length > 0 then
            t = math.clamp((currentDist - segStartDist) / seg.length, 0, 1)
        elseif currentDist > segStartDist then t = 1 else t = 0 end

        local samplePoint = lerpVector2(seg.start, seg.finish, t)
        table.insert(samples, samplePoint)

        if numSamples > 1 then currentDist = currentDist + sampleDistance end
    end

    while #samples < numSamples do table.insert(samples, points[#points]) end
    while #samples > numSamples do table.remove(samples) end

    return samples
end

-- GUI Preservation Functions
local preservedGuis = {}
local function preserveGuis()
    preservedGuis = {}
    local playerGui = LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
    if playerGui then
        for _, gui in ipairs(playerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name ~= "BodyLetterGui" and gui.ResetOnSpawn then
                table.insert(preservedGuis, gui)
                gui.ResetOnSpawn = false
            end
        end
    end
end

local function restoreGuis()
    task.wait() -- Give engine time to process GUI changes
    for _, gui in ipairs(preservedGuis) do
        if gui and gui.Parent == LocalPlayer:FindFirstChildWhichIsA("PlayerGui") then
            gui.ResetOnSpawn = true
        end
    end
    preservedGuis = {}
end

-- Update Function: Arranges body parts along the letter shape
local function updateRagdolledParts(dt)
    if not ghostEnabled or not originalCharacter or not originalCharacter.Parent or not ghostClone or not ghostClone.Parent then
        if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
        if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end
        return
    end

    local currentTime = tick()
    local actualDt = currentTime - lastUpdateTime
    lastUpdateTime = currentTime
    local interpDt = math.min(actualDt, 1/30)

    local rootPart = originalCharacter:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    local centerPosition = ghostClone.PrimaryPart and ghostClone.PrimaryPart.Position or rootPart.Position
    local centerCFrame = ghostClone.PrimaryPart and ghostClone.PrimaryPart.CFrame or rootPart.CFrame

    local shapePoints = getLetterShape(selectedLetter)
    if #shapePoints == 0 then return end
    local samplePoints = sampleLetterPoints(shapePoints, #bodyParts)
    if #samplePoints ~= #bodyParts then return end

    for i, partName in ipairs(bodyParts) do
        local originalPart = originalCharacter:FindFirstChild(partName)
        if originalPart then
            if not previousPositions[partName] then previousPositions[partName] = originalPart.CFrame end

            local sample = samplePoints[i]
            local offsetX = centerCFrame.RightVector * sample.X * letterSize
            local offsetY = centerCFrame.UpVector * sample.Y * letterSize
            local targetPos = centerPosition + offsetX + offsetY

            local rotation = previousPositions[partName] - previousPositions[partName].Position
            local targetCFrame = CFrame.new(targetPos) * rotation

            local distance = (targetCFrame.Position - previousPositions[partName].Position).Magnitude
            local baseRate = math.min(0.15, interpDt * 18)
            local adaptiveRate = math.min(0.85, baseRate * (1 + distance * 1.2))
            local smoothCFrame = previousPositions[partName]:Lerp(targetCFrame, adaptiveRate)

            if smoothCFrame == smoothCFrame then -- NaN Check
                 originalPart.CFrame = smoothCFrame
                 previousPositions[partName] = smoothCFrame
            else
                 originalPart.CFrame = targetCFrame
                 previousPositions[partName] = targetCFrame
            end

            originalPart.AssemblyLinearVelocity = Vector3.zero
            originalPart.AssemblyAngularVelocity = Vector3.zero
        end
    end
end

-- Toggle Ghost Mode / Reanimation
local function setGhostEnabled(newState)
    ghostEnabled = newState

    if ghostEnabled then
        -- Enabling logic remains the same as in your original script
        local char = LocalPlayer.Character
        if not char then print("Character not found to activate."); return end
        local humanoid = char:FindFirstChildWhichIsA("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if not humanoid or not root then print("Humanoid or RootPart missing."); return end
        if originalCharacter or ghostClone then print("Already in Ghost Mode or clone still exists."); return end

        print("Activating Ghost Mode...")
        originalCharacter = char
        originalCFrame = root.CFrame
        char.Archivable = true
        ghostClone = char:Clone()
        char.Archivable = false
        ghostClone.Name = originalCharacter.Name .. "_clone"

        local ghostHumanoid = ghostClone:FindFirstChildWhichIsA("Humanoid")
        if ghostHumanoid then
            ghostHumanoid.DisplayName = originalCharacter.Name .. "_clone"
            ghostHumanoid:ChangeState(Enum.HumanoidStateType.Physics) -- Keep ragdolling the clone
        end

        if not ghostClone.PrimaryPart then
            local hrp = ghostClone:FindFirstChild("HumanoidRootPart")
            if hrp then ghostClone.PrimaryPart = hrp else warn("Clone HRP not found!") end
        end

        for _, descendant in ipairs(ghostClone:GetDescendants()) do
            if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
                 descendant.Transparency = 1
                 descendant.CanCollide = false
                 descendant.Anchored = false
                 descendant.CanQuery = false
            elseif descendant:IsA("Decal") then descendant.Transparency = 1
            elseif descendant:IsA("Accessory") then
                 local handle = descendant:FindFirstChild("Handle")
                 if handle then
                    handle.Transparency = 1; handle.CanCollide = false; handle.CanQuery = false
                 end
            end
        end

        local animate = originalCharacter:FindFirstChild("Animate")
        if animate and animate:IsA("Script") then
            originalAnimateScript = animate
            originalAnimateScript.Disabled = true
            originalAnimateScript.Parent = ghostClone -- Move script to clone
        else originalAnimateScript = nil end

        preserveGuis()
        ghostClone.Parent = Workspace -- Keep clone in Workspace
        LocalPlayer.Character = ghostClone -- Player controls clone
        if ghostHumanoid then Workspace.CurrentCamera.CameraSubject = ghostHumanoid end
        restoreGuis()

        -- Enable Animate script on the clone
        if originalAnimateScript and originalAnimateScript.Parent == ghostClone then
            task.wait()
            originalAnimateScript.Disabled = false
        end

        -- Fire Ragdoll Event (Server-side constraints for original character)
        local ragdollEvent = ReplicatedStorage:FindFirstChild("RagdollEvent")
        if ragdollEvent then ragdollEvent:FireServer() else warn("RagdollEvent not found!") end

        previousPositions = {}
        lastUpdateTime = tick()
        if updateConnection then updateConnection:Disconnect() end
        if renderStepConnection then renderStepConnection:Disconnect() end
        updateConnection = RunService.Heartbeat:Connect(updateRagdolledParts) -- Start updating original parts

        print("Ghost Mode activated.")

    else
        -- MODIFIED DISABLING LOGIC (Based on the second script)
        print("Deactivating Ghost Mode...")
        if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
        if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end

        if not originalCharacter or not ghostClone then
            print("Not in Ghost Mode or clone/original character missing.")
            return
        end

        -- Fire Unragdoll Event
        local unragdollEvent = ReplicatedStorage:FindFirstChild("UnragdollEvent")
        if unragdollEvent then
            for i = 1, 3 do
                unragdollEvent:FireServer()
                task.wait(0.1) -- Small delay between fires as in the example
            end
        else
            warn("UnragdollEvent not found in ReplicatedStorage!")
        end

        -- Get target CFrame from the clone's RootPart or use original saved CFrame
        local targetCFrame = originalCFrame
        local ghostRoot = ghostClone:FindFirstChild("HumanoidRootPart")
        if ghostRoot then
            targetCFrame = ghostRoot.CFrame
        else
             warn("Clone HumanoidRootPart not found when deactivating! Using original CFrame.")
        end

        -- Find Animate script in the clone
        local animate = ghostClone:FindFirstChild("Animate")
        if animate and animate == originalAnimateScript then
             -- Disable and move Animate script back to the original character *before* destroying clone
             animate.Disabled = true
             animate.Parent = originalCharacter
        end

        -- Destroy the clone
        ghostClone:Destroy()
        ghostClone = nil

        -- Restore original character
        if originalCharacter and originalCharacter.Parent then
            local origRoot = originalCharacter:FindFirstChild("HumanoidRootPart")
            local origHumanoid = originalCharacter:FindFirstChildWhichIsA("Humanoid")

            -- Set original character's position
            if origRoot then
                origRoot.CFrame = targetCFrame
                -- Reset velocities (important after ragdoll)
                origRoot.AssemblyLinearVelocity = Vector3.zero
                origRoot.AssemblyAngularVelocity = Vector3.zero
            end

            preserveGuis()
            LocalPlayer.Character = originalCharacter -- Give control back
            if origHumanoid then
                Workspace.CurrentCamera.CameraSubject = origHumanoid -- Set camera back
                -- NOTE: No forced state changes like GettingUp from the first script
            end
            restoreGuis()

            -- Re-enable Animate script on the original character after a short delay
            if animate and animate.Parent == originalCharacter then
                task.wait(0.1) -- Use the shorter delay from the second script example
                animate.Disabled = false
                print("Original Animate script re-enabled.")
            end

            print("Original character restored.")
        else
             warn("Original character lost during ghost mode! Forcing respawn.")
             LocalPlayer:LoadCharacter() -- Fallback if original character is gone
        end

        -- Clean up variables
        originalCharacter = nil
        originalAnimateScript = nil -- Already moved or irrelevant
        previousPositions = {}
        print("Ghost mode disabled.")
    end
end

-- GUI Creation Function (Modified for size and rounded corners)
local function createGui()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "BodyLetterGui" -- **Changed GUI Name to BodyLetterGui**
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.DisplayOrder = 1000

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 400) -- **Smaller GUI Size**
    frame.Position = UDim2.new(0.5, -150, 0.1, 0) -- Adjusted Position for smaller size
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    frame.Active = true
    frame.Draggable = true

    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 25) -- Smaller title bar
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    titleBar.Parent = frame
    titleBar.Active = false
    local titleBarCorner = Instance.new("UICorner") -- Rounded Corners for title bar
    titleBarCorner.CornerRadius = UDim.new(0, 8)
    titleBarCorner.Parent = titleBar

    local titleText = Instance.new("TextLabel")
    titleText.Size = UDim2.new(1, -30, 1, 0) -- Adjusted size for smaller title bar
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "BodyLetter" -- **Changed GUI Title to BodyLetter**
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.Font = Enum.Font.GothamSemibold
    titleText.TextSize = 14
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame

    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 20, 0, 20) -- Smaller close button
    closeButton.Position = UDim2.new(1, -3, 0.5, 0) -- Adjusted position
    closeButton.AnchorPoint = Vector2.new(1, 0.5)
    closeButton.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 12 -- Smaller text size
    closeButton.Parent = titleBar
    closeButton.ZIndex = 2

    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(1, -15, 0, 25) -- Smaller button
    toggleButton.Position = UDim2.new(0.5, 0, 0, 35) -- Adjusted position
    toggleButton.AnchorPoint = Vector2.new(0.5, 0)
    toggleButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    toggleButton.Text = "Enable BodyLetter" -- **Changed Button Text to Enable BodyLetter**
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.Font = Enum.Font.GothamSemibold
    toggleButton.TextSize = 14
    toggleButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = toggleButton

    -- Size Slider Function (Unchanged with minor style adjustments for size)
    local function createSlider(parent, yPosition, labelText, minValue, maxValue, defaultValue, valueChangedCallback)
        local sliderHeight = 25; local knobSize = 18 -- Smaller slider height and knob
        local currentValue = defaultValue; local lastCallbackTime = 0
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Size = UDim2.new(1, -15, 0, sliderHeight + 10) -- Adjusted size
        sliderContainer.Position = UDim2.new(0, 7.5, 0, yPosition) -- Adjusted position
        sliderContainer.BackgroundTransparency = 1
        sliderContainer.Parent = parent
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0, 50, 0, sliderHeight); label.BackgroundTransparency = 1 -- Smaller label width
        label.Text = labelText .. ":"; label.TextColor3 = Color3.fromRGB(220, 220, 220) -- **English Text**
        label.Font = Enum.Font.Gotham; label.TextSize = 12; label.TextXAlignment = Enum.TextXAlignment.Left -- Smaller text size
        label.Parent = sliderContainer
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0, 40, 0, sliderHeight); valueLabel.Position = UDim2.new(1, 0, 0, 0) -- Smaller value label
        valueLabel.AnchorPoint = Vector2.new(1, 0); valueLabel.BackgroundTransparency = 1
        valueLabel.TextColor3 = Color3.fromRGB(255, 255, 255); valueLabel.Font = Enum.Font.GothamBold
        valueLabel.TextSize = 12; valueLabel.TextXAlignment = Enum.TextXAlignment.Right -- Smaller text size
        valueLabel.Text = string.format("%.1f", defaultValue); valueLabel.Parent = sliderContainer
        local sliderBackground = Instance.new("Frame")
        sliderBackground.Size = UDim2.new(1, -100, 0, sliderHeight); sliderBackground.Position = UDim2.new(0, 55, 0, 0) -- Adjusted size and position
        sliderBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 40); sliderBackground.BorderSizePixel = 0
        sliderBackground.Parent = sliderContainer
        local backgroundCorner = Instance.new("UICorner"); backgroundCorner.CornerRadius = UDim.new(0, 6); backgroundCorner.Parent = sliderBackground
        local trackContainer = Instance.new("Frame")
        trackContainer.Size = UDim2.new(1, -10, 0, sliderHeight); trackContainer.Position = UDim2.new(0.5, 0, 0, 0)
        trackContainer.AnchorPoint = Vector2.new(0.5, 0); trackContainer.BackgroundTransparency = 1
        trackContainer.Parent = sliderBackground; trackContainer.Active = true
        local track = Instance.new("Frame")
        track.Size = UDim2.new(1, 0, 0, 6); track.Position = UDim2.new(0, 0, 0.5, 0); track.AnchorPoint = Vector2.new(0, 0.5) -- Smaller track height
        track.BackgroundColor3 = Color3.fromRGB(80, 80, 80); track.BorderSizePixel = 0; track.Parent = trackContainer
        local trackCorner = Instance.new("UICorner"); trackCorner.CornerRadius = UDim.new(1, 0); trackCorner.Parent = track
        local progressTrack = Instance.new("Frame")
        progressTrack.Size = UDim2.new(0, 0, 1, 0); progressTrack.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
        progressTrack.BorderSizePixel = 0; progressTrack.Parent = track
        local progressCorner = Instance.new("UICorner"); progressCorner.CornerRadius = UDim.new(1, 0); progressCorner.Parent = progressTrack
        local knob = Instance.new("TextButton")
        knob.Size = UDim2.new(0, knobSize, 0, knobSize); knob.AnchorPoint = Vector2.new(0.5, 0.5)
        knob.BackgroundColor3 = Color3.fromRGB(200, 200, 200); knob.BorderSizePixel = 0
        knob.Text = ""; knob.AutoButtonColor = false; knob.ZIndex = 3; knob.Parent = trackContainer
        local knobCorner = Instance.new("UICorner"); knobCorner.CornerRadius = UDim.new(1, 0); knobCorner.Parent = knob
        local knobShadow = Instance.new("Frame")
        knobShadow.Size = UDim2.new(1, 4, 1, 4); knobShadow.Position = UDim2.new(0.5, 0, 0.5, 0); knobShadow.AnchorPoint = Vector2.new(0.5, 0.5)
        knobShadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0); knobShadow.BackgroundTransparency = 0.7
        knobShadow.BorderSizePixel = 0; knobShadow.ZIndex = 2; knobShadow.Parent = knob
        local shadowCorner = Instance.new("UICorner"); shadowCorner.CornerRadius = UDim.new(1, 0); shadowCorner.Parent = knobShadow
        local function updateSliderFromValue(value, callCallback)
            value = math.clamp(value, minValue, maxValue); value = math.floor(value * 10 + 0.5) / 10
            if value ~= currentValue or not callCallback then
                currentValue = value; local fraction = (value - minValue) / (maxValue - minValue)
                knob.Position = UDim2.new(fraction, 0, 0.5, 0); progressTrack.Size = UDim2.new(fraction, 0, 1, 0)
                valueLabel.Text = string.format("%.1f", value)
                local currentTime = tick()
                if callCallback and valueChangedCallback and (currentTime - lastCallbackTime > 0.1) then
                    lastCallbackTime = currentTime; valueChangedCallback(currentValue) end
            end
        end
        local function updateValueFromPosition(mouseX)
            local trackAbsPos = trackContainer.AbsolutePosition.X; local trackAbsSize = trackContainer.AbsoluteSize.X
            if trackAbsSize == 0 then return end; local relativeX = mouseX - trackAbsPos
            local fraction = math.clamp(relativeX / trackAbsSize, 0, 1); local newValue = minValue + fraction * (maxValue - minValue)
            updateSliderFromValue(newValue, true)
        end
        local isDragging = false
        knob.MouseButton1Down:Connect(function() isDragging = true end)
        sliderBackground.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then updateValueFromPosition(input.Position.X); isDragging = true end end)
        track.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then updateValueFromPosition(input.Position.X); isDragging = true end end)
        local inputEndedConnection; local inputChangedConnection
        inputEndedConnection = UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then if isDragging then if valueChangedCallback then valueChangedCallback(currentValue) end; isDragging = false end end end)
        inputChangedConnection = UserInputService.InputChanged:Connect(function(input) if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then updateValueFromPosition(input.Position.X) end end)
        sliderContainer.AncestryChanged:Connect(function(_, newParent) if not newParent then if inputEndedConnection then inputEndedConnection:Disconnect() end; if inputChangedConnection then inputChangedConnection:Disconnect() end end end)
        updateSliderFromValue(defaultValue, false); return sliderContainer
    end

    local sliderY = 70 -- Adjusted slider Y position
    local sizeSlider = createSlider(frame, sliderY, "Size", 1, 20, letterSize, function(newValue)
        letterSize = newValue
    end)

    -- Letter Selection Frame (Unchanged with smaller size)
    local letterFrame = Instance.new("ScrollingFrame")
    letterFrame.Size = UDim2.new(1, -15, 0, 150); letterFrame.Position = UDim2.new(0, 7.5, 0, sliderY + 35) -- Smaller height and adjusted position
    letterFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50); letterFrame.BorderSizePixel = 1
    letterFrame.BorderColor3 = Color3.fromRGB(60, 60, 60); letterFrame.ScrollBarThickness = 5 -- Smaller scroll bar
    letterFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y; letterFrame.Parent = frame
    local letterCorner = Instance.new("UICorner"); letterCorner.CornerRadius = UDim.new(0, 4); letterCorner.Parent = letterFrame
    local UIGridLayout = Instance.new("UIGridLayout")
    UIGridLayout.CellSize = UDim2.new(0, 30, 0, 30); UIGridLayout.CellPadding = UDim2.new(0, 3, 0, 3) -- Smaller cells and padding
    UIGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIGridLayout.Parent = letterFrame
    local supportedLetters = {}
    for i = 65, 90 do table.insert(supportedLetters, string.char(i)) end; table.sort(supportedLetters)
    local letterButtons = {}
    for i, letter in ipairs(supportedLetters) do
        local letterButton = Instance.new("TextButton")
        letterButton.Name = "LetterButton_" .. letter; letterButton.Size = UDim2.new(0, 30, 0, 30) -- Smaller button size
        letterButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80); letterButton.Text = letter
        letterButton.Font = Enum.Font.GothamBold; letterButton.TextSize = 14 -- Smaller text size
        letterButton.TextColor3 = Color3.fromRGB(255, 255, 255); letterButton.LayoutOrder = i; letterButton.Parent = letterFrame
        local btnCorner = Instance.new("UICorner"); btnCorner.CornerRadius = UDim.new(0, 4); btnCorner.Parent = letterButton
        table.insert(letterButtons, letterButton)
        letterButton.MouseButton1Click:Connect(function()
            selectedLetter = letter
            for _, btn in ipairs(letterButtons) do
                if btn.Text == selectedLetter then btn.BackgroundColor3 = Color3.fromRGB(76, 175, 80); btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                else btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80); btn.TextColor3 = Color3.fromRGB(220, 220, 220) end
            end
        end)
        if letter == selectedLetter then letterButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80); letterButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        else letterButton.TextColor3 = Color3.fromRGB(220, 220, 220) end
    end

    -- Text Animation Area (Unchanged with smaller size)
    local textAnimationY = letterFrame.Position.Y.Offset + letterFrame.Size.Y.Offset + 15 -- Adjusted position
    local animationLabel = Instance.new("TextLabel")
    animationLabel.Size = UDim2.new(1, -15, 0, 18); animationLabel.Position = UDim2.new(0, 7.5, 0, textAnimationY) -- Smaller height and adjusted position
    animationLabel.BackgroundTransparency = 1; animationLabel.Text = "Text Animation:" -- **English Text**
    animationLabel.TextColor3 = Color3.fromRGB(220, 220, 220); animationLabel.Font = Enum.Font.GothamSemibold
    animationLabel.TextSize = 12; animationLabel.TextXAlignment = Enum.TextXAlignment.Left; animationLabel.Parent = frame
    local textBox = Instance.new("TextBox")
    textBox.Size = UDim2.new(1, -100, 0, 25); textBox.Position = UDim2.new(0, 7.5, 0, textAnimationY + 20) -- Smaller height and adjusted position
    textBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60); textBox.BorderSizePixel = 0; textBox.Text = animationText
    textBox.PlaceholderText = "Enter text..."; textBox.TextColor3 = Color3.fromRGB(255, 255, 255) -- **English Text**
    textBox.Font = Enum.Font.Gotham; textBox.TextSize = 12; textBox.ClearTextOnFocus = false; textBox.Parent = frame
    local textBoxCorner = Instance.new("UICorner"); textBoxCorner.CornerRadius = UDim.new(0, 4); textBoxCorner.Parent = textBox
    local playButton = Instance.new("TextButton")
    playButton.Size = UDim2.new(0, 40, 0, 25); playButton.Position = UDim2.new(1, -85, 0, textAnimationY + 20) -- Smaller button and adjusted position
    playButton.AnchorPoint = Vector2.new(0, 0); playButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    playButton.Text = "Play"; playButton.TextColor3 = Color3.fromRGB(255, 255, 255); playButton.Font = Enum.Font.GothamSemibold -- **English Text**
    playButton.TextSize = 12; playButton.Parent = frame
    local playButtonCorner = Instance.new("UICorner"); playButtonCorner.CornerRadius = UDim.new(0, 4); playButtonCorner.Parent = playButton
    local stopButton = Instance.new("TextButton")
    stopButton.Size = UDim2.new(0, 40, 0, 25); stopButton.Position = UDim2.new(1, -45, 0, textAnimationY + 20) -- Smaller button and adjusted position
    stopButton.AnchorPoint = Vector2.new(0, 0); stopButton.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
    stopButton.Text = "Stop"; stopButton.TextColor3 = Color3.fromRGB(255, 255, 255); stopButton.Font = Enum.Font.GothamSemibold -- **English Text**
    stopButton.TextSize = 12; stopButton.Parent = frame
    local stopButtonCorner = Instance.new("UICorner"); stopButtonCorner.CornerRadius = UDim.new(0, 4); stopButtonCorner.Parent = stopButton
    animationSpeed = 2.0
    local speedSlider = createSlider(frame, textAnimationY + 55, "Speed", 0.5, 5.0, animationSpeed, function(newValue) -- Adjusted position
        animationSpeed = 5.5 - newValue
    end)
    local speedExplanation = Instance.new("TextLabel")
    speedExplanation.Size = UDim2.new(1, -15, 0, 18); speedExplanation.Position = UDim2.new(0, 7.5, 0, textAnimationY + 90) -- Smaller height and adjusted position
    speedExplanation.BackgroundTransparency = 1; speedExplanation.Text = "(Higher = faster)" -- **English Text**
    speedExplanation.TextColor3 = Color3.fromRGB(180, 180, 180); speedExplanation.Font = Enum.Font.Gotham
    speedExplanation.TextSize = 11; speedExplanation.TextXAlignment = Enum.TextXAlignment.Left; speedExplanation.Parent = frame

    local function startTextAnimation()
        if isAnimationPlaying then return end; animationText = textBox.Text; if animationText == "" then return end
        isAnimationPlaying = true; animationIndex = 1; playButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100); stopButton.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
        if animationConnection then animationConnection:Disconnect() end
        local lastUpdateTime = tick(); local currentChar = ""
        animationConnection = RunService.Heartbeat:Connect(function()
            if not isAnimationPlaying then return end; local currentTime = tick(); local elapsedTime = currentTime - lastUpdateTime
            if elapsedTime < animationSpeed then return end
            if animationIndex <= #animationText then
                currentChar = string.sub(animationText, animationIndex, animationIndex)
                if currentChar == " " or not letterShapes[string.upper(currentChar)] then
                    animationIndex = animationIndex + 1; lastUpdateTime = currentTime; return
                end
                selectedLetter = currentChar
                for _, btn in ipairs(letterButtons) do
                    if btn.Text == string.upper(selectedLetter) then btn.BackgroundColor3 = Color3.fromRGB(76, 175, 80); btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    else btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80); btn.TextColor3 = Color3.fromRGB(220, 220, 220) end
                end
                lastUpdateTime = currentTime; animationIndex = animationIndex + 1
            else
                animationIndex = 1; if #animationText > 0 then currentChar = string.sub(animationText, 1, 1); if letterShapes[string.upper(currentChar)] then selectedLetter = currentChar
                for _, btn in ipairs(letterButtons) do if btn.Text == string.upper(selectedLetter) then btn.BackgroundColor3 = Color3.fromRGB(76, 175, 80); btn.TextColor3 = Color3.fromRGB(255, 255, 255) else btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80); btn.TextColor3 = Color3.fromRGB(220, 220, 220) end end end end
                lastUpdateTime = currentTime
            end
        end)
    end
    local function stopTextAnimation()
        if not isAnimationPlaying then return end; isAnimationPlaying = false
        if animationConnection then animationConnection:Disconnect(); animationConnection = nil end
        playButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80); stopButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
    playButton.MouseButton1Click:Connect(startTextAnimation); stopButton.MouseButton1Click:Connect(stopTextAnimation)
    textBox.FocusLost:Connect(function(enterPressed) animationText = textBox.Text; if enterPressed and animationText ~= "" then startTextAnimation() end end)

    -- Event Connections for Toggle and Close (Unchanged)
    closeButton.MouseButton1Click:Connect(function()
        if isAnimationPlaying then stopTextAnimation() end
        if ghostEnabled then setGhostEnabled(false); task.wait(0.5) end
        screenGui:Destroy()
    end)
    toggleButton.MouseButton1Click:Connect(function()
        local newState = not ghostEnabled
        setGhostEnabled(newState)
        if ghostEnabled then toggleButton.Text = "Disable BodyLetter"; toggleButton.BackgroundColor3 = Color3.fromRGB(211, 47, 47) -- **Changed Button Text to Disable BodyLetter**
        else toggleButton.Text = "Enable BodyLetter"; toggleButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80) end -- **Changed Button Text to Enable BodyLetter**
    end)

    return screenGui
end

-- Initialization & Cleanup (Unchanged)
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local function cleanupExistingGui()
    local existingGui = playerGui:FindFirstChild("BodyLetterGui") -- **Changed GUI Name Check to BodyLetterGui**
    if existingGui then print("Old BodyLetter GUI found, removing."); existingGui:Destroy() end -- **Changed Log Message to BodyLetter**
end
cleanupExistingGui()
print("Creating new BodyLetter GUI (Letter Shape).") -- **Changed Log Message to BodyLetter**
local gui = createGui()
gui.Parent = playerGui
local scriptDestroyConnection
scriptDestroyConnection = script.Destroying:Connect(function()
    print("BodyLetter script destroying. Cleaning up...") -- **Changed Log Message to BodyLetter**
    if isAnimationPlaying and animationConnection then animationConnection:Disconnect(); animationConnection = nil; isAnimationPlaying = false end
    if ghostEnabled then setGhostEnabled(false) end
    if gui and gui.Parent then gui:Destroy() else cleanupExistingGui() end
    if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
    if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end
    if scriptDestroyConnection then scriptDestroyConnection:Disconnect(); scriptDestroyConnection = nil end
    print("Cleanup complete.")
end)
print("BodyLetter script loaded. GUI created.") -- **Changed Log Message to BodyLetter**


--[[ uafling ]]
-- Gui to Lua
-- Version: 3.2

-- Instances:

local Gui = Instance.new("ScreenGui")
local Main = Instance.new("Frame")
local Box = Instance.new("TextBox")
local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
local Label = Instance.new("TextLabel")
local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
local Button = Instance.new("TextButton")
local UITextSizeConstraint_3 = Instance.new("UITextSizeConstraint")
local ViewButton = Instance.new("TextButton") -- View button added for target viewing
local UITextSizeConstraint_4 = Instance.new("UITextSizeConstraint")
local ToggleButton = Instance.new("TextButton") -- Toggle button for GUI visibility

-- Corner & Shadow Effects
local UICorner = Instance.new("UICorner")
local UIStroke = Instance.new("UIStroke")

-- Properties:

Gui.Name = "Unanchored fling"
Gui.Parent = gethui()
Gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Main.Name = "Main"
Main.Parent = Gui
Main.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark background for a sleek look
Main.BackgroundTransparency = 0.1
Main.BorderSizePixel = 0
Main.Position = UDim2.new(0.35, 0, 0.35, 0) -- Centered position
Main.Size = UDim2.new(0.18, 0, 0.2, 0) -- Smaller size for the GUI
Main.Active = true
Main.Draggable = true
UICorner.Parent = Main
UIStroke.Parent = Main
UIStroke.Color = Color3.fromRGB(70, 70, 70)

Box.Name = "Box"
Box.Parent = Main
Box.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
Box.BorderSizePixel = 0
Box.Position = UDim2.new(0.1, 0, 0.25, 0) -- Adjusted spacing
Box.Size = UDim2.new(0.8, 0, 0.15, 0)
Box.FontFace = Font.new("rbxasset://fonts/families/SourceSansSemibold.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal)
Box.PlaceholderText = "Enter player name..."
Box.Text = ""
Box.TextColor3 = Color3.fromRGB(235, 235, 235)
Box.TextScaled = true
Box.TextWrapped = true
UITextSizeConstraint.Parent = Box
UITextSizeConstraint.MaxTextSize = 18
UICorner:Clone().Parent = Box

Label.Name = "Label"
Label.Parent = Main
Label.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
Label.BorderSizePixel = 0
Label.Size = UDim2.new(1, 0, 0.15, 0)
Label.FontFace = Font.new("rbxasset://fonts/families/Nunito.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal)
Label.Text = "Unanchor Fling Controller"
Label.TextColor3 = Color3.fromRGB(235, 235, 235)
Label.TextScaled = true
Label.TextWrapped = true
UITextSizeConstraint_2.Parent = Label
UITextSizeConstraint_2.MaxTextSize = 20
UICorner:Clone().Parent = Label

Button.Name = "Button"
Button.Parent = Main
Button.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
Button.BorderSizePixel = 0
Button.Position = UDim2.new(0.15, 0, 0.45, 0)
Button.Size = UDim2.new(0.7, 0, 0.2, 0)
Button.Font = Enum.Font.Nunito
Button.Text = "Unanchor Fling | Off"
Button.TextColor3 = Color3.fromRGB(240, 240, 240)
Button.TextScaled = true
Button.TextWrapped = true
UITextSizeConstraint_3.Parent = Button
UITextSizeConstraint_3.MaxTextSize = 26
UICorner:Clone().Parent = Button

-- New View Button Properties
ViewButton.Name = "ViewButton"
ViewButton.Parent = Main
ViewButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
ViewButton.BorderSizePixel = 0
ViewButton.Position = UDim2.new(0.15, 0, 0.7, 0) -- Positioned below the Unanchor fling button
ViewButton.Size = UDim2.new(0.7, 0, 0.2, 0)
ViewButton.Font = Enum.Font.Nunito
ViewButton.Text = "View Target | Off"
ViewButton.TextColor3 = Color3.fromRGB(240, 240, 240)
ViewButton.TextScaled = true
ViewButton.TextWrapped = true
UITextSizeConstraint_4.Parent = ViewButton
UITextSizeConstraint_4.MaxTextSize = 26
UICorner:Clone().Parent = ViewButton

-- New Toggle Button Properties for GUI Visibility
ToggleButton.Name = "ToggleButton"
ToggleButton.Parent = Gui
ToggleButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
ToggleButton.Position = UDim2.new(0.8, 0, 0.1, 0) -- Position at the top right corner
ToggleButton.Size = UDim2.new(0.05, 0, 0.05, 0) -- Smaller size
ToggleButton.Text = "X" -- Using a close icon for a clean look
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextScaled = true
ToggleButton.Font = Enum.Font.Nunito
ToggleButton.BorderSizePixel = 0
ToggleButton.Active = true
ToggleButton.Draggable = false
UICorner:Clone().Parent = ToggleButton

-- Scripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local character
local humanoidRootPart

local mainStatus = true
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
	if input.KeyCode == Enum.KeyCode.RightControl and not gameProcessedEvent then
		mainStatus = not mainStatus
		Main.Visible = mainStatus
	end
end)

local Folder = Instance.new("Folder", Workspace)
local Part = Instance.new("Part", Folder)
local Attachment1 = Instance.new("Attachment", Part)
Part.Anchored = true
Part.CanCollide = false
Part.Transparency = 1

if not getgenv().Network then
	getgenv().Network = {
		BaseParts = {},
		Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
	}

	Network.RetainPart = function(Part)
		if Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
			table.insert(Network.BaseParts, Part)
			Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			Part.CanCollide = false
		end
	end

	local function EnablePartControl()
		LocalPlayer.ReplicationFocus = Workspace
		RunService.Heartbeat:Connect(function()
			sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
			for _, Part in pairs(Network.BaseParts) do
				if Part:IsDescendantOf(Workspace) then
					Part.Velocity = Network.Velocity
				end
			end
		end)
	end

	EnablePartControl()
end

local function ForcePart(v)
	if v:IsA("BasePart") and not v.Anchored and not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
		if v:IsDescendantOf(LocalPlayer.Character) then
			return
		end
		for _, x in ipairs(v:GetChildren()) do
			if x:IsA("BodyMover") or x:IsA("RocketPropulsion") then
				x:Destroy()
			end
		end
		if v:FindFirstChild("Attachment") then
			v:FindFirstChild("Attachment"):Destroy()
		end
		if v:FindFirstChild("AlignPosition") then
			v:FindFirstChild("AlignPosition"):Destroy()
		end
		if v:FindFirstChild("Torque") then
			v:FindFirstChild("Torque"):Destroy()
		end
		v.CanCollide = false
		local Torque = Instance.new("Torque", v)
		Torque.Torque = Vector3.new(100000, 100000, 100000)
		local AlignPosition = Instance.new("AlignPosition", v)
		local Attachment2 = Instance.new("Attachment", v)
		Torque.Attachment0 = Attachment2
		AlignPosition.MaxForce = math.huge
		AlignPosition.MaxVelocity = math.huge
		AlignPosition.Responsiveness = 200
		AlignPosition.Attachment0 = Attachment2
		AlignPosition.Attachment1 = Attachment1
	end
end

local blackHoleActive = false
local DescendantAddedConnection

local function toggleBlackHole()
	blackHoleActive = not blackHoleActive
	if blackHoleActive then
		Button.Text = "Unanchor fling | On"
		for _, v in ipairs(Workspace:GetDescendants()) do
			ForcePart(v)
		end

		DescendantAddedConnection = Workspace.DescendantAdded:Connect(function(v)
			if blackHoleActive then
				ForcePart(v)
			end
		end)

		spawn(function()
			while blackHoleActive and RunService.RenderStepped:Wait() do
				if humanoidRootPart then
					Attachment1.WorldCFrame = humanoidRootPart.CFrame
				end
			end
		end)
	else
		Button.Text = "Unanchor fling | Off"
		if DescendantAddedConnection then
			DescendantAddedConnection:Disconnect()
		end
	end
end

local function getPlayer(name)
	local lowerName = string.lower(name)
	local bestMatch = nil
	local bestMatchLength = math.huge

	for _, p in ipairs(Players:GetPlayers()) do
		local playerName = string.lower(p.Name)
		local lowerDisplayName = string.lower(p.DisplayName)

		if string.sub(playerName, 1, #lowerName) == lowerName or string.sub(lowerDisplayName, 1, #lowerName) == lowerName then
			local matchLength = math.min(#lowerName, #playerName)
			if matchLength < bestMatchLength then
				bestMatch = p
				bestMatchLength = matchLength
			end
		end
	end

	return bestMatch
end

local function onButtonClicked()
	local playerName = Box.Text
	if playerName ~= "" then
		local targetPlayer = getPlayer(playerName)
		if targetPlayer then
			Box.Text = targetPlayer.Name
			local function applyBallFling(targetCharacter)
				humanoidRootPart = targetCharacter:WaitForChild("HumanoidRootPart")
				toggleBlackHole()
			end

			local targetCharacter = targetPlayer.Character
			if targetCharacter then
				applyBallFling(targetCharacter)
			else
				Box.Text = "Player not found"
			end

			targetPlayer.CharacterAdded:Connect(function(newCharacter)
				applyBallFling(newCharacter)
			end)
		else
			Box.Text = "Player not found"
		end
	end
end

Button.MouseButton1Click:Connect(onButtonClicked)

-- View button script
local viewing = false
local camera = Workspace.CurrentCamera

ViewButton.MouseButton1Click:Connect(function()
	viewing = not viewing
	local playerName = Box.Text
	local targetPlayer = getPlayer(playerName)
	if viewing then
		if targetPlayer and targetPlayer.Character then
			ViewButton.Text = "View Target | On"
			camera.CameraSubject = targetPlayer.Character:FindFirstChild("Humanoid")
			targetPlayer.CharacterAdded:Connect(function(newCharacter)
				if viewing then
					camera.CameraSubject = newCharacter:FindFirstChild("Humanoid")
				end
			end)
		else
			ViewButton.Text = "Player not found"
		end
	else
		ViewButton.Text = "View Target | Off"
		camera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
	end
end)

-- Toggle the GUI visibility
ToggleButton.MouseButton1Click:Connect(function()
	Main.Visible = not Main.Visible
end)


--[[ autorevc ]]
-- Only auto reactivate when moderated
game:GetService("VoiceChatInternal").LocalPlayerModerated:Connect(function()
task.wait(1)
game:GetService("VoiceChatService"):joinVoice()
end)

local player = game:GetService("Players").LocalPlayer
local tweenService = game:GetService("TweenService")
-- Function to create and display a notification
local function createNotification()
    -- Create GUI objects
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AKAdminNotification"
    screenGui.ResetOnSpawn = false
    screenGui.DisplayOrder = 10
    screenGui.Parent = player.PlayerGui
    
    -- Main notification frame
    local notificationFrame = Instance.new("Frame")
    notificationFrame.Name = "NotificationFrame"
    notificationFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 40) -- Dark background
    notificationFrame.BorderSizePixel = 0
    notificationFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    notificationFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    notificationFrame.Size = UDim2.new(0, 300, 0, 130)
    notificationFrame.Parent = screenGui
    
    -- Apply corner radius to make it look modern
    local cornerRadius = Instance.new("UICorner")
    cornerRadius.CornerRadius = UDim.new(0, 8)
    cornerRadius.Parent = notificationFrame
    
    -- Size constraint to prevent the notification from being too large on big screens
    local sizeConstraint = Instance.new("UISizeConstraint")
    sizeConstraint.MaxSize = Vector2.new(350, 160)
    sizeConstraint.MinSize = Vector2.new(250, 110)
    sizeConstraint.Parent = notificationFrame
    
    -- Apply padding for internal content
    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0, 15)
    padding.PaddingBottom = UDim.new(0, 15)
    padding.PaddingLeft = UDim.new(0, 15)
    padding.PaddingRight = UDim.new(0, 15)
    padding.Parent = notificationFrame
    
    -- Header text
    local headerText = Instance.new("TextLabel")
    headerText.Name = "HeaderText"
    headerText.BackgroundTransparency = 1
    headerText.Font = Enum.Font.GothamBold
    headerText.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light text
    headerText.TextSize = 24
    headerText.Text = "AK Admin"
    headerText.TextXAlignment = Enum.TextXAlignment.Left
    headerText.Position = UDim2.new(0, 0, 0, 0)
    headerText.Size = UDim2.new(1, 0, 0, 28)
    headerText.Parent = notificationFrame
    
    -- Colorful accent line under the header
    local accentLine = Instance.new("Frame")
    accentLine.Name = "AccentLine"
    accentLine.BackgroundColor3 = Color3.fromRGB(204, 153, 255) -- Light purple accent
    accentLine.BorderSizePixel = 0
    accentLine.Position = UDim2.new(0, 0, 0, 32)
    accentLine.Size = UDim2.new(0.4, 0, 0, 2)
    accentLine.Parent = notificationFrame
    
    -- Message text
    local messageText = Instance.new("TextLabel")
    messageText.Name = "MessageText"
    messageText.BackgroundTransparency = 1
    messageText.Font = Enum.Font.Gotham
    messageText.TextColor3 = Color3.fromRGB(200, 200, 200) -- Slightly darker than header for hierarchy
    messageText.TextSize = 16
    messageText.TextWrapped = true
    messageText.Text = "Auto reactivate VC enabled!"
    messageText.TextXAlignment = Enum.TextXAlignment.Left
    messageText.Position = UDim2.new(0, 0, 0, 45)
    messageText.Size = UDim2.new(1, 0, 0, 60)
    messageText.Parent = notificationFrame
    
    -- Close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.BackgroundTransparency = 1
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    closeButton.TextSize = 14
    closeButton.Text = "X"
    closeButton.Position = UDim2.new(1, -20, 0, 0)
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Parent = notificationFrame
    
    -- Animation: make the notification appear with a subtle animation
    notificationFrame.Position = UDim2.new(0.5, 0, 0.4, 0) -- Start position slightly higher
    notificationFrame.BackgroundTransparency = 1
    headerText.TextTransparency = 1
    accentLine.BackgroundTransparency = 1
    messageText.TextTransparency = 1
    closeButton.TextTransparency = 1
    
    -- Create a table of properties to tween
    local tweenInfo = TweenInfo.new(
        0.5, -- Duration
        Enum.EasingStyle.Quad, -- Easing style
        Enum.EasingDirection.Out -- Easing direction
    )
    
    -- Create tweens for each element
    local frameTween = tweenService:Create(notificationFrame, tweenInfo, {
        Position = UDim2.new(0.5, 0, 0.5, 0), -- Move to center
        BackgroundTransparency = 0
    })
    
    local headerTween = tweenService:Create(headerText, tweenInfo, {
        TextTransparency = 0
    })
    
    local accentTween = tweenService:Create(accentLine, tweenInfo, {
        BackgroundTransparency = 0
    })
    
    local messageTween = tweenService:Create(messageText, tweenInfo, {
        TextTransparency = 0
    })
    
    local closeTween = tweenService:Create(closeButton, tweenInfo, {
        TextTransparency = 0
    })
    
    -- Play the tweens in sequence
    frameTween:Play()
    wait(0.1)
    headerTween:Play()
    wait(0.1)
    accentTween:Play()
    wait(0.1)
    messageTween:Play()
    wait(0.1)
    closeTween:Play()
    
    -- Function to close/dismiss the notification
    local function closeNotification()
        -- Fade out animation
        local closeTweenInfo = TweenInfo.new(
            0.4, -- Duration
            Enum.EasingStyle.Quad, -- Easing style
            Enum.EasingDirection.In -- Easing direction
        )
        
        local frameCloseTween = tweenService:Create(notificationFrame, closeTweenInfo, {
            Position = UDim2.new(0.5, 0, 0.4, 0), -- Move up slightly
            BackgroundTransparency = 1
        })
        
        local headerCloseTween = tweenService:Create(headerText, closeTweenInfo, {
            TextTransparency = 1
        })
        
        local accentCloseTween = tweenService:Create(accentLine, closeTweenInfo, {
            BackgroundTransparency = 1
        })
        
        local messageCloseTween = tweenService:Create(messageText, closeTweenInfo, {
            TextTransparency = 1
        })
        
        local closeButtonTween = tweenService:Create(closeButton, closeTweenInfo, {
            TextTransparency = 1
        })
        
        -- Play close animations
        frameCloseTween:Play()
        headerCloseTween:Play()
        accentCloseTween:Play()
        messageCloseTween:Play()
        closeButtonTween:Play()
        
        -- Wait for animation to complete then remove
        wait(0.4)
        screenGui:Destroy()
    end
    
    -- Connect close button click event
    closeButton.MouseButton1Click:Connect(function()
        closeNotification()
    end)
    
    -- Auto-close after 5 seconds
    wait(5)
    closeNotification()
end
createNotification()


--[[ mutenonfriends ]]
-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MuteToggleGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Create the main button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleButton"
ToggleButton.Size = UDim2.new(0, 50, 0, 50)
ToggleButton.Position = UDim2.new(0.9, -25, 0.1, 0)
ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- off state: red
ToggleButton.BackgroundTransparency = 0.5  -- increased transparency
ToggleButton.Text = "🎤"  -- microphone emoji
ToggleButton.TextSize = 25
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.BorderSizePixel = 0
ToggleButton.AutoButtonColor = false
ToggleButton.Parent = ScreenGui

-- Make it circular
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = ToggleButton

-- Get TweenService for animations
local TweenService = game:GetService("TweenService")

local exceptions = {
    "Xeni_He7",
    "YournothimbuddyXD",
    "BloxiAstra"
}

local isMuted = false

local function isException(playerName)
    for _, name in pairs(exceptions) do
        if name == playerName then
            return true
        end
    end
    return false
end

-- Function to update mute status
local function updateMute()
    if isMuted then
        for _, v in pairs(game:GetService("Players"):GetPlayers()) do
            local audio = v:FindFirstChild("AudioDeviceInput")
            if audio then
                if not v:IsFriendsWith(game.Players.LocalPlayer.UserId) and not isException(v.Name) and v.Name ~= game.Players.LocalPlayer.Name then
                    audio.Muted = true
                end
            end
        end
    else
        for _, v in pairs(game:GetService("Players"):GetPlayers()) do
            local audio = v:FindFirstChild("AudioDeviceInput")
            if audio then
                audio.Muted = false
            end
        end
    end
end

-- Drag functionality for all devices
local UserInputService = game:GetService("UserInputService")
local dragging = false
local dragInput, dragStart, startPos

local function update(input)
    local delta = input.Position - dragStart
    ToggleButton.Position = UDim2.new(
        startPos.X.Scale, startPos.X.Offset + delta.X,
        startPos.Y.Scale, startPos.Y.Offset + delta.Y
    )
end

ToggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = ToggleButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

ToggleButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Toggle function with tween animation
ToggleButton.MouseButton1Click:Connect(function()
    isMuted = not isMuted

    -- Tween animation: spin the button 360°
    local tweenInfo = TweenInfo.new(
        0.5, -- duration
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out,
        0,   -- no repeats
        false,
        0
    )
    local goal = {Rotation = ToggleButton.Rotation + 360}
    local tween = TweenService:Create(ToggleButton, tweenInfo, goal)
    tween:Play()

    -- Update visual state: green if active, red if not
    if isMuted then
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    else
        ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end

    updateMute()
end)

-- Update mute when new players join (only if mute is active)
game:GetService("Players").PlayerAdded:Connect(function(player)
    wait(1) -- Wait for AudioDeviceInput to load
    if isMuted then
        local audio = player:FindFirstChild("AudioDeviceInput")
        if audio then
            if not player:IsFriendsWith(game.Players.LocalPlayer.UserId) and not isException(player.Name) and player.Name ~= game.Players.LocalPlayer.Name then
                audio.Muted = true
            end
        end
    end
end)


--[[ remotechecker ]]
-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer

-- Create GUI Elements
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ProfessionalRemoteGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = game:WaitForChild("CoreGui")

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 300, 0, 400)
mainFrame.Position = UDim2.new(0.5, -150, 0.5, -200)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

-- Add rounded corners
local mainUICorner = Instance.new("UICorner")
mainUICorner.CornerRadius = UDim.new(0, 10)
mainUICorner.Parent = mainFrame

-- Title Bar
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleUICorner = Instance.new("UICorner")
titleUICorner.CornerRadius = UDim.new(0, 10)
titleUICorner.Parent = titleBar

-- Title Text
local titleText = Instance.new("TextLabel")
titleText.Size = UDim2.new(1, -40, 1, 0)
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "Remote Event Manager"
titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
titleText.TextSize = 16
titleText.Font = Enum.Font.GothamBold
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = titleBar

-- Close Button
local closeButton = Instance.new("ImageButton")
closeButton.Size = UDim2.new(0, 24, 0, 24)
closeButton.Position = UDim2.new(1, -32, 0, 8)
closeButton.BackgroundTransparency = 1
closeButton.Image = "rbxassetid://7743878857"
closeButton.ImageColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Parent = titleBar

-- Search Bar
local searchBar = Instance.new("Frame")
searchBar.Size = UDim2.new(1, -20, 0, 35)
searchBar.Position = UDim2.new(0, 10, 0, 50)
searchBar.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
searchBar.BorderSizePixel = 0
searchBar.Parent = mainFrame

local searchUICorner = Instance.new("UICorner")
searchUICorner.CornerRadius = UDim.new(0, 8)
searchUICorner.Parent = searchBar

local searchBox = Instance.new("TextBox")
searchBox.Size = UDim2.new(1, -16, 1, -8)
searchBox.Position = UDim2.new(0, 8, 0, 4)
searchBox.BackgroundTransparency = 1
searchBox.Text = ""
searchBox.PlaceholderText = "Search RemoteEvents..."
searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
searchBox.TextSize = 14
searchBox.Font = Enum.Font.Gotham
searchBox.Parent = searchBar

-- Scroll Container
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -20, 1, -100)
scrollFrame.Position = UDim2.new(0, 10, 0, 95)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 4
scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
scrollFrame.Parent = mainFrame

-- List Layout
local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 8)
listLayout.Parent = scrollFrame

-- Padding
local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 5)
padding.PaddingBottom = UDim.new(0, 5)
padding.Parent = scrollFrame

-- Functions
local function createArgumentInput(parent, placeholder)
    local argFrame = Instance.new("Frame")
    argFrame.Size = UDim2.new(1, 0, 0, 30)
    argFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
    argFrame.BorderSizePixel = 0
    
    local argUICorner = Instance.new("UICorner")
    argUICorner.CornerRadius = UDim.new(0, 6)
    argUICorner.Parent = argFrame
    
    local argInput = Instance.new("TextBox")
    argInput.Size = UDim2.new(1, -16, 1, -8)
    argInput.Position = UDim2.new(0, 8, 0, 4)
    argInput.BackgroundTransparency = 1
    argInput.Text = ""
    argInput.PlaceholderText = placeholder
    argInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    argInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    argInput.TextSize = 14
    argInput.Font = Enum.Font.Gotham
    argInput.Parent = argFrame
    
    return argFrame, argInput
end

local function createRemoteButton(remoteName)
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(1, 0, 0, 110)
    buttonFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    buttonFrame.BorderSizePixel = 0
    
    local buttonUICorner = Instance.new("UICorner")
    buttonUICorner.CornerRadius = UDim.new(0, 8)
    buttonUICorner.Parent = buttonFrame
    
    -- Remote Name
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, -20, 0, 20)
    nameLabel.Position = UDim2.new(0, 10, 0, 5)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = remoteName
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Parent = buttonFrame
    
    -- Argument Container
    local argContainer = Instance.new("Frame")
    argContainer.Size = UDim2.new(1, -20, 0, 60)
    argContainer.Position = UDim2.new(0, 10, 0, 30)
    argContainer.BackgroundTransparency = 1
    argContainer.Parent = buttonFrame
    
    local arg1Frame, arg1Input = createArgumentInput(argContainer, "Enter argument 1...")
    arg1Frame.Size = UDim2.new(1, -90, 0, 30)
    arg1Frame.Parent = argContainer
    
    local arg2Frame, arg2Input = createArgumentInput(argContainer, "Enter argument 2...")
    arg2Frame.Size = UDim2.new(1, -90, 0, 30)
    arg2Frame.Position = UDim2.new(0, 0, 0, 35)
    arg2Frame.Parent = argContainer
    
    -- Fire Button
    local fireButton = Instance.new("TextButton")
    fireButton.Size = UDim2.new(0, 80, 0, 60)
    fireButton.Position = UDim2.new(1, -80, 0, 0)
    fireButton.BackgroundColor3 = Color3.fromRGB(59, 130, 246)
    fireButton.BorderSizePixel = 0
    fireButton.Text = "Fire"
    fireButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    fireButton.TextSize = 14
    fireButton.Font = Enum.Font.GothamBold
    fireButton.Parent = argContainer
    
    local fireUICorner = Instance.new("UICorner")
    fireUICorner.CornerRadius = UDim.new(0, 6)
    fireUICorner.Parent = fireButton
    
    -- Hover Effect
    local function updateButtonColor(isHovered)
        local targetColor = isHovered and Color3.fromRGB(96, 165, 250) or Color3.fromRGB(59, 130, 246)
        local tweenInfo = TweenInfo.new(0.2)
        local tween = TweenService:Create(fireButton, tweenInfo, {BackgroundColor3 = targetColor})
        tween:Play()
    end
    
    fireButton.MouseEnter:Connect(function()
        updateButtonColor(true)
    end)
    
    fireButton.MouseLeave:Connect(function()
        updateButtonColor(false)
    end)
    
    -- Fire RemoteEvent
    fireButton.MouseButton1Click:Connect(function()
        local remote = ReplicatedStorage:FindFirstChild(remoteName, true)
        if remote and remote:IsA("RemoteEvent") then
            local args = {}
            for _, input in ipairs({arg1Input, arg2Input}) do
                local arg = input.Text
                local convertedArg = arg
                if tonumber(arg) then
                    convertedArg = tonumber(arg)
                elseif arg == "true" then
                    convertedArg = true
                elseif arg == "false" then
                    convertedArg = false
                end
                table.insert(args, convertedArg)
            end
            
            pcall(function()
                remote:FireServer(unpack(args))
            end)
        end
    end)
    
    return buttonFrame
end

-- Make GUI draggable
local dragging = false
local dragStart = nil
local startPos = nil

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

-- Close button functionality
closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Search functionality
local function updateSearch()
    local searchText = string.lower(searchBox.Text)
    for _, button in pairs(scrollFrame:GetChildren()) do
        if button:IsA("Frame") then
            local nameLabel = button:FindFirstChild("TextLabel")
            if nameLabel then
                button.Visible = string.find(string.lower(nameLabel.Text), searchText) ~= nil
            end
        end
    end
end

searchBox.Changed:Connect(function(prop)
    if prop == "Text" then
        updateSearch()
    end
end)

-- Load RemoteEvents
local function loadRemoteEvents()
    for _, object in pairs(ReplicatedStorage:GetDescendants()) do
        if object:IsA("RemoteEvent") then
            local button = createRemoteButton(object.Name)
            button.Parent = scrollFrame
        end
    end
end

-- Update ScrollFrame canvas size
local function updateCanvasSize()
    local contentSize = listLayout.AbsoluteContentSize
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
end

scrollFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateCanvasSize)
listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateCanvasSize)

-- Monitor for new RemoteEvents
ReplicatedStorage.DescendantAdded:Connect(function(object)
    if object:IsA("RemoteEvent") then
        local button = createRemoteButton(object.Name)
        button.Parent = scrollFrame
        updateCanvasSize()
    end
end)

-- Initialize
loadRemoteEvents()
updateCanvasSize()


--[[ aimbot ]]
PLAYER  = game.Players.LocalPlayer
MOUSE   = PLAYER:GetMouse()
CC      = game.Workspace.CurrentCamera

ENABLED      = false       -- PC right-click aimbot activation
ESP_ENABLED  = false

_G.FREE_FOR_ALL = true

_G.ESP_BIND    = 52        -- Key code for ESP toggle (PC)
_G.CHANGE_AIM  = 'q'       -- Key for aim target toggle (PC)

_G.AIM_AT = 'Head'

-- Enhanced targeting system variables
local DAMAGE_DEALERS = {}           -- Track players who are damaging us
local LAST_HEALTH = 100            -- Track our health changes
local PRIORITY_TARGET = nil        -- Current priority target
local TARGET_LOCK_TIME = {}        -- Track how long we've been targeting someone
local BLACKLISTED_TARGETS = {}     -- Temporarily blacklist unresponsive targets

-- Camera movement detection for target switching
local LAST_CAMERA_CF = nil         -- Last camera position/rotation
local CAMERA_MOVE_THRESHOLD = 0.1  -- Sensitivity for camera movement detection
local LOCKED_TARGET = nil          -- Currently locked target
local ALLOW_TARGET_SWITCH = true   -- Flag to control target switching

wait(1)

-- Initialize health tracking
if PLAYER.Character and PLAYER.Character:FindFirstChild("Humanoid") then
    LAST_HEALTH = PLAYER.Character.Humanoid.Health
end

-- Function to check if a player is alive and valid
function IsPlayerAlive(player)
    if not player or not player.Character then
        return false
    end
    
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return false
    end
    
    -- Check if player is dead or dying
    if humanoid.Health <= 0 then
        return false
    end
    
    -- Check if player is in a "dead" state
    if humanoid:GetState() == Enum.HumanoidStateType.Dead then
        return false
    end
    
    -- Check if the character model is properly loaded
    local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return false
    end
    
    return true
end

-- Function to check if a player can be seen (not behind walls)
function CanSeePlayer(player)
    if not IsPlayerAlive(player) then
        return false
    end
    
    local targetPart = player.Character:FindFirstChild(_G.AIM_AT)
    if not targetPart then
        return false
    end
    
    local ray = Ray.new(CC.CoordinateFrame.Position, (targetPart.Position - CC.CoordinateFrame.Position).Unit * 1000)
    local hit, pos = game.Workspace:FindPartOnRayWithIgnoreList(ray, {PLAYER.Character})
    
    -- If we hit the target part or nothing, we can see them
    if hit and hit.Parent == player.Character then
        return true
    end
    
    return false
end

-- Function to track damage dealers
function TrackDamage()
    if PLAYER.Character and PLAYER.Character:FindFirstChild("Humanoid") then
        local currentHealth = PLAYER.Character.Humanoid.Health
        
        if currentHealth < LAST_HEALTH and LAST_HEALTH > 0 then
            -- We took damage, find who might have caused it
            local damageAmount = LAST_HEALTH - currentHealth
            local currentTime = tick()
            
            -- Look for nearby players who might be attacking us
            for _, player in pairs(game.Players:GetPlayers()) do
                if player ~= PLAYER and IsPlayerAlive(player) then
                    local distance = (player.Character.HumanoidRootPart.Position - PLAYER.Character.HumanoidRootPart.Position).Magnitude
                    
                    -- If player is close enough to have damaged us
                    if distance <= 100 then
                        if not DAMAGE_DEALERS[player.Name] then
                            DAMAGE_DEALERS[player.Name] = {
                                player = player,
                                lastDamageTime = currentTime,
                                damageCount = 1,
                                totalDamage = damageAmount
                            }
                        else
                            DAMAGE_DEALERS[player.Name].lastDamageTime = currentTime
                            DAMAGE_DEALERS[player.Name].damageCount = DAMAGE_DEALERS[player.Name].damageCount + 1
                            DAMAGE_DEALERS[player.Name].totalDamage = DAMAGE_DEALERS[player.Name].totalDamage + damageAmount
                        end
                    end
                end
            end
        end
        
        LAST_HEALTH = currentHealth
    end
end

-- Clean up old damage dealer records
function CleanupDamageDealers()
    local currentTime = tick()
    for name, data in pairs(DAMAGE_DEALERS) do
        -- Remove records older than 10 seconds
        if currentTime - data.lastDamageTime > 10 then
            DAMAGE_DEALERS[name] = nil
        end
    end
end

-- Function to detect camera movement
function HasCameraMoved()
    if not LAST_CAMERA_CF then
        LAST_CAMERA_CF = CC.CoordinateFrame
        return false
    end
    
    local currentCF = CC.CoordinateFrame
    local positionDiff = (currentCF.Position - LAST_CAMERA_CF.Position).Magnitude
    local rotationDiff = math.abs(currentCF.LookVector:Dot(LAST_CAMERA_CF.LookVector) - 1)
    
    -- Check if camera moved significantly
    if positionDiff > CAMERA_MOVE_THRESHOLD or rotationDiff > 0.01 then
        LAST_CAMERA_CF = currentCF
        return true
    end
    
    return false
end

-- Function to check if current locked target is still valid
function IsLockedTargetValid()
    if not LOCKED_TARGET then
        return false
    end
    
    -- Check if target is still alive and valid
    if not IsPlayerAlive(LOCKED_TARGET) then
        return false
    end
    
    -- Check if we can still see the target
    if not CanSeePlayer(LOCKED_TARGET) then
        return false
    end
    
    -- Check if target is within reasonable range
    local targetPart = LOCKED_TARGET.Character:FindFirstChild(_G.AIM_AT)
    if targetPart then
        local distance = (targetPart.Position - CC.CoordinateFrame.Position).Magnitude
        if distance > 600 then -- Increased range tolerance for locked targets
            return false
        end
    end
    
    return true
end
function GetSmartestTarget()
    local PLAYERS = {}
    local CANDIDATES = {}
    
    -- Get all valid players
    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= PLAYER and IsPlayerAlive(v) then
            -- Check team conditions
            if _G.FREE_FOR_ALL == false then
                if v.TeamColor ~= PLAYER.TeamColor then
                    table.insert(PLAYERS, v)
                end
            else
                table.insert(PLAYERS, v)
            end
        end
    end
    
    -- Score each player based on multiple factors
    for _, player in pairs(PLAYERS) do
        if not BLACKLISTED_TARGETS[player.Name] or tick() - BLACKLISTED_TARGETS[player.Name] > 5 then
            local targetPart = player.Character:FindFirstChild(_G.AIM_AT)
            if targetPart then
                local distance = (targetPart.Position - CC.CoordinateFrame.Position).Magnitude
                local canSee = CanSeePlayer(player)
                
                if canSee and distance <= 500 then -- Reasonable range limit
                    local score = 0
                    
                    -- Distance scoring (closer = better, but not the only factor)
                    score = score + math.max(0, 100 - distance / 5)
                    
                    -- Damage dealer priority (much higher score)
                    if DAMAGE_DEALERS[player.Name] then
                        local damageData = DAMAGE_DEALERS[player.Name]
                        score = score + 200 -- High priority for damage dealers
                        score = score + damageData.damageCount * 50 -- More damage = higher priority
                        score = score + math.max(0, 50 - (tick() - damageData.lastDamageTime) * 5) -- Recent damage = higher priority
                    end
                    
                    -- Health scoring (lower health enemies are easier targets)
                    local enemyHealth = player.Character.Humanoid.Health
                    score = score + math.max(0, 50 - enemyHealth / 2)
                    
                    -- Mouse proximity scoring
                    local screenPos, onScreen = CC:WorldToScreenPoint(targetPart.Position)
                    if onScreen then
                        local mouseDistance = math.sqrt((screenPos.X - MOUSE.X)^2 + (screenPos.Y - MOUSE.Y)^2)
                        score = score + math.max(0, 100 - mouseDistance / 5)
                    end
                    
                    -- Consistency bonus (if we've been tracking this target)
                    if PRIORITY_TARGET == player then
                        score = score + 30 -- Slight bonus for target consistency
                    end
                    
                    table.insert(CANDIDATES, {
                        player = player,
                        score = score,
                        distance = distance
                    })
                end
            end
        end
    end
    
    -- Sort by score (highest first)
    table.sort(CANDIDATES, function(a, b) return a.score > b.score end)
    
    -- Return the best candidate
    if #CANDIDATES > 0 then
        local bestTarget = CANDIDATES[1].player
        
        -- Update priority target tracking
        if PRIORITY_TARGET ~= bestTarget then
            PRIORITY_TARGET = bestTarget
            TARGET_LOCK_TIME[bestTarget.Name] = tick()
        end
        
        return bestTarget
    end
    
    return false
end

-- Enhanced target validation
function ValidateTarget(target)
    if not target or not IsPlayerAlive(target) then
        return false
    end
    
    if not CanSeePlayer(target) then
        return false
    end
    
    -- Check if target has been unresponsive for too long
    if TARGET_LOCK_TIME[target.Name] and tick() - TARGET_LOCK_TIME[target.Name] > 8 then
        BLACKLISTED_TARGETS[target.Name] = tick()
        TARGET_LOCK_TIME[target.Name] = nil
        return false
    end
    
    return true
end

-- Main GUI setup (keeping original design)
GUI_MAIN                           = Instance.new('ScreenGui', game.CoreGui)
GUI_MAIN.Name                      = 'SMART_AIMBOT'

GUI_TARGET                         = Instance.new('TextLabel', GUI_MAIN)
GUI_TARGET.Size                    = UDim2.new(0,250,0,30)
GUI_TARGET.BackgroundTransparency  = 0.3
GUI_TARGET.BackgroundColor         = BrickColor.new('Really black')
GUI_TARGET.BorderSizePixel         = 0
GUI_TARGET.Position                = UDim2.new(0.5,-125,0,0)
GUI_TARGET.Text                    = 'SMART AIMBOT : OFF'
GUI_TARGET.TextColor3              = Color3.new(0,1,0)
GUI_TARGET.TextStrokeTransparency  = 0.5
GUI_TARGET.TextWrapped             = true
GUI_TARGET.FontSize                = 'Size24'
GUI_TARGET.Font                    = 'SourceSansBold'

GUI_AIM_AT                         = Instance.new('TextLabel', GUI_MAIN)
GUI_AIM_AT.Size                    = UDim2.new(0,250,0,20)
GUI_AIM_AT.BackgroundTransparency  = 0.3
GUI_AIM_AT.BackgroundColor         = BrickColor.new('Really black')
GUI_AIM_AT.BorderSizePixel         = 0
GUI_AIM_AT.Position                = UDim2.new(0.5,-125,0,30)
GUI_AIM_AT.Text                    = 'TARGETING : HEAD'
GUI_AIM_AT.TextColor3              = Color3.new(1,1,0)
GUI_AIM_AT.TextStrokeTransparency  = 0.5
GUI_AIM_AT.TextWrapped             = true
GUI_AIM_AT.FontSize                = 'Size18'
GUI_AIM_AT.Font                    = 'SourceSansBold'

-- Status display
GUI_STATUS                         = Instance.new('TextLabel', GUI_MAIN)
GUI_STATUS.Size                    = UDim2.new(0,250,0,20)
GUI_STATUS.BackgroundTransparency  = 0.3
GUI_STATUS.BackgroundColor         = BrickColor.new('Really black')
GUI_STATUS.BorderSizePixel         = 0
GUI_STATUS.Position                = UDim2.new(0.5,-125,0,50)
GUI_STATUS.Text                    = 'STATUS: READY'
GUI_STATUS.TextColor3              = Color3.new(0,0.7,1)
GUI_STATUS.TextStrokeTransparency  = 0.5
GUI_STATUS.TextWrapped             = true
GUI_STATUS.FontSize                = 'Size14'
GUI_STATUS.Font                    = 'SourceSansBold'

-- Controls GUI Panel
local guiControlsToggle = Instance.new("TextButton", GUI_MAIN)
guiControlsToggle.Name = "ControlsToggle"
guiControlsToggle.Size = UDim2.new(0, 150, 0, 30)
guiControlsToggle.Position = UDim2.new(0, 10, 0, 100)
guiControlsToggle.BackgroundTransparency = 0.3
guiControlsToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
guiControlsToggle.BorderSizePixel = 0
guiControlsToggle.Text = "Show Controls"
guiControlsToggle.TextColor3 = Color3.new(1, 1, 1)
guiControlsToggle.Font = Enum.Font.SourceSansBold
guiControlsToggle.TextSize = 16

local guiControlsDetails = Instance.new("Frame", GUI_MAIN)
guiControlsDetails.Name = "ControlsDetails"
guiControlsDetails.Size = UDim2.new(0, 250, 0, 120)
guiControlsDetails.Position = UDim2.new(0, 10, 0, 140)
guiControlsDetails.BackgroundTransparency = 0.2
guiControlsDetails.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
guiControlsDetails.Visible = false

local controlsText = Instance.new("TextLabel", guiControlsDetails)
controlsText.Size = UDim2.new(1, 0, 1, 0)
controlsText.BackgroundTransparency = 1
controlsText.TextColor3 = Color3.new(1, 1, 1)
controlsText.Font = Enum.Font.SourceSans
controlsText.TextSize = 14
controlsText.TextWrapped = true
controlsText.Text = "SMART CONTROLS:\n- PC: Right Mouse = Hold to aim\n- Q = Toggle aim target (Head/Torso)\n- 4 = Toggle ESP\n- Mobile: Use buttons below\n\nSMART FEATURES:\n- Locks onto targets until YOU move camera\n- Auto-targets damage dealers\n- Ignores dead players\n- Move your mouse/camera to switch targets"

guiControlsToggle.MouseButton1Click:Connect(function()
    guiControlsDetails.Visible = not guiControlsDetails.Visible
    guiControlsToggle.Text = guiControlsDetails.Visible and "Hide Controls" or "Show Controls"
end)

-- Mobile Controls
local MOBILE_AIMBOT = false

local aimbotToggleButton = Instance.new("TextButton", GUI_MAIN)
aimbotToggleButton.Name = "AimbotToggleButton"
aimbotToggleButton.Size = UDim2.new(0, 120, 0, 35)
aimbotToggleButton.Position = UDim2.new(0, 10, 0, 270)
aimbotToggleButton.BackgroundTransparency = 0.2
aimbotToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
aimbotToggleButton.BorderSizePixel = 0
aimbotToggleButton.Text = "AIMBOT: OFF"
aimbotToggleButton.TextColor3 = Color3.new(1,1,1)
aimbotToggleButton.Font = Enum.Font.SourceSansBold
aimbotToggleButton.TextSize = 16

aimbotToggleButton.MouseButton1Click:Connect(function()
    MOBILE_AIMBOT = not MOBILE_AIMBOT
    aimbotToggleButton.Text = MOBILE_AIMBOT and "AIMBOT: ON" or "AIMBOT: OFF"
    aimbotToggleButton.BackgroundColor3 = MOBILE_AIMBOT and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(200, 50, 50)
end)

local espToggleButton = Instance.new("TextButton", GUI_MAIN)
espToggleButton.Name = "ESPToggleButton"
espToggleButton.Size = UDim2.new(0, 120, 0, 35)
espToggleButton.Position = UDim2.new(0, 140, 0, 270)
espToggleButton.BackgroundTransparency = 0.2
espToggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 200)
espToggleButton.BorderSizePixel = 0
espToggleButton.Text = "ESP: OFF"
espToggleButton.TextColor3 = Color3.new(1,1,1)
espToggleButton.Font = Enum.Font.SourceSansBold
espToggleButton.TextSize = 16

espToggleButton.MouseButton1Click:Connect(function()
    ESP_ENABLED = not ESP_ENABLED
    if ESP_ENABLED then
        FIND()
        espToggleButton.Text = "ESP: ON"
        espToggleButton.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        CLEAR()
        TRACK = false
        espToggleButton.Text = "ESP: OFF"
        espToggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 200)
    end
end)

-- ESP System (Enhanced)
local TRACK = false

function CREATE(BASE, TEAM, isDamageDealer)
    local ESP_MAIN = Instance.new('BillboardGui', PLAYER.PlayerGui)
    local ESP_DOT = Instance.new('Frame', ESP_MAIN)
    local ESP_NAME = Instance.new('TextLabel', ESP_MAIN)
    local ESP_HEALTH = Instance.new('TextLabel', ESP_MAIN)
    
    ESP_MAIN.Name = 'ESP'
    ESP_MAIN.Adornee = BASE
    ESP_MAIN.AlwaysOnTop = true
    ESP_MAIN.ExtentsOffset = Vector3.new(0, 1, 0)
    ESP_MAIN.Size = UDim2.new(0, 5, 0, 5)
    
    -- Color coding for different threat levels
    local dotColor = isDamageDealer and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 165, 0)
    
    ESP_DOT.Name = 'DOT'
    ESP_DOT.BackgroundColor3 = dotColor
    ESP_DOT.BackgroundTransparency = 0.2
    ESP_DOT.BorderSizePixel = 0
    ESP_DOT.Position = UDim2.new(-0.5, 0, -0.5, 0)
    ESP_DOT.Size = UDim2.new(2, 0, 2, 0)
    ESP_DOT.Visible = true
    ESP_DOT.ZIndex = 10
    
    ESP_NAME.Name = 'NAME'
    ESP_NAME.BackgroundTransparency = 1
    ESP_NAME.Position = UDim2.new(0, 0, 0, -50)
    ESP_NAME.Size = UDim2.new(1, 0, 10, 0)
    ESP_NAME.ZIndex = 10
    ESP_NAME.Font = 'ArialBold'
    ESP_NAME.TextSize = 14
    ESP_NAME.Text = (isDamageDealer and "[THREAT] " or "") .. BASE.Parent.Name:upper()
    ESP_NAME.TextColor3 = dotColor
    ESP_NAME.TextStrokeTransparency = 0.5
    
    -- Health display
    if BASE.Parent:FindFirstChild("Humanoid") then
        ESP_HEALTH.Name = 'HEALTH'
        ESP_HEALTH.BackgroundTransparency = 1
        ESP_HEALTH.Position = UDim2.new(0, 0, 0, -30)
        ESP_HEALTH.Size = UDim2.new(1, 0, 10, 0)
        ESP_HEALTH.ZIndex = 10
        ESP_HEALTH.Font = 'Arial'
        ESP_HEALTH.TextSize = 12
        ESP_HEALTH.Text = "HP: " .. math.floor(BASE.Parent.Humanoid.Health)
        ESP_HEALTH.TextColor3 = Color3.fromRGB(0, 255, 0)
        ESP_HEALTH.TextStrokeTransparency = 0.5
    end
end

function CLEAR()
    for _,v in pairs(PLAYER.PlayerGui:GetChildren()) do
        if v.Name == 'ESP' and v:IsA('BillboardGui') then
            v:Destroy()
        end
    end
end

function FIND()
    CLEAR()
    TRACK = true
    spawn(function()
        while TRACK do
            wait(0.5) -- Reduced update frequency for performance
            if TRACK then
                CLEAR()
                for i,v in pairs(game.Players:GetChildren()) do
                    if v ~= PLAYER and IsPlayerAlive(v) then
                        local shouldShow = false
                        
                        if _G.FREE_FOR_ALL == false then
                            shouldShow = v.TeamColor ~= PLAYER.TeamColor
                        else
                            shouldShow = true
                        end
                        
                        if shouldShow and v.Character:FindFirstChild('Head') then
                            local isDamageDealer = DAMAGE_DEALERS[v.Name] ~= nil
                            CREATE(v.Character.Head, true, isDamageDealer)
                        end
                    end
                end
            end
        end
    end)
end

-- Input handling
MOUSE.Button2Down:connect(function()
    ENABLED = true
end)

MOUSE.Button2Up:connect(function()
    ENABLED = false
end)

MOUSE.KeyDown:connect(function(KEY)
    KEY = KEY:lower():byte()
    if KEY == _G.ESP_BIND then
        ESP_ENABLED = not ESP_ENABLED
        if ESP_ENABLED then
            FIND()
        else
            CLEAR()
            TRACK = false
        end
    end
end)

MOUSE.KeyDown:connect(function(KEY)
    if KEY == _G.CHANGE_AIM then
        _G.AIM_AT = (_G.AIM_AT == 'Head') and 'Torso' or 'Head'
        GUI_AIM_AT.Text = 'TARGETING : ' .. _G.AIM_AT:upper()
    end
end)

-- Enhanced main loop with damage tracking
spawn(function()
    while wait(0.1) do
        TrackDamage()
        CleanupDamageDealers()
        
        -- Update status display
        local activeDealers = 0
        for _ in pairs(DAMAGE_DEALERS) do
            activeDealers = activeDealers + 1
        end
        
        if activeDealers > 0 then
            GUI_STATUS.Text = 'THREATS DETECTED: ' .. activeDealers
            GUI_STATUS.TextColor3 = Color3.new(1, 0, 0)
        else
            GUI_STATUS.Text = 'STATUS: SCANNING'
            GUI_STATUS.TextColor3 = Color3.new(0, 0.7, 1)
        end
    end
end)

-- Main aimbot loop with camera movement detection
game:GetService('RunService').RenderStepped:connect(function()
    if ENABLED or MOBILE_AIMBOT then
        -- Check for camera movement to allow target switching
        if HasCameraMoved() then
            ALLOW_TARGET_SWITCH = true
        end
        
        local TARGET = GetSmartestTarget()
        
        if TARGET and ValidateTarget(TARGET) then
            local AIM = TARGET.Character:FindFirstChild(_G.AIM_AT)
            if AIM then
                -- Smooth aiming with prediction
                local targetPos = AIM.Position
                
                -- Lead target if they're moving
                if TARGET.Character:FindFirstChild("HumanoidRootPart") then
                    local velocity = TARGET.Character.HumanoidRootPart.Velocity
                    local distance = (targetPos - CC.CoordinateFrame.Position).Magnitude
                    local timeToTarget = distance / 1000 -- Approximate bullet speed
                    targetPos = targetPos + (velocity * timeToTarget * 0.5) -- Lead the target
                end
                
                CC.CoordinateFrame = CFrame.new(CC.CoordinateFrame.Position, targetPos)
                
                -- Update camera reference after aiming (don't count aimbot movement as user movement)
                LAST_CAMERA_CF = CC.CoordinateFrame
                
                -- Update GUI
                local threatIndicator = DAMAGE_DEALERS[TARGET.Name] and " [THREAT]" or ""
                local lockIndicator = (LOCKED_TARGET == TARGET and not ALLOW_TARGET_SWITCH) and " 🔒" or ""
                GUI_TARGET.Text = 'LOCKED: ' .. TARGET.Name:sub(1, 8) .. threatIndicator .. lockIndicator
                GUI_TARGET.TextColor3 = DAMAGE_DEALERS[TARGET.Name] and Color3.new(1, 0.2, 0.2) or Color3.new(0.2, 1, 0.2)
            end
        else
            -- No valid target, allow switching
            LOCKED_TARGET = nil
            ALLOW_TARGET_SWITCH = true
            GUI_TARGET.Text = 'SMART AIMBOT : SCANNING'
            GUI_TARGET.TextColor3 = Color3.new(1, 1, 0)
        end
    else
        -- Aimbot is off, reset target lock
        LOCKED_TARGET = nil
        ALLOW_TARGET_SWITCH = true
        GUI_TARGET.Text = 'SMART AIMBOT : OFF'
        GUI_TARGET.TextColor3 = Color3.new(0.5, 0.5, 0.5)
    end
end)

-- ESP maintenance loop
spawn(function()
    while wait(1) do
        if ESP_ENABLED then
            FIND()
        end
    end
end)


--[[ shmost ]]
-- Enhanced Auto Teleport to Highest Population Server Script
-- This script keeps searching until it finds a server with a good amount of players
-- It prioritizes servers with optimal player counts and implements persistence

local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Configuration
local visitedServersFileName = "VisitedServers_" .. game.PlaceId .. ".json"
local minimumAcceptablePlayerCount = 10 -- Won't stop until finding a server with at least this many players
local preferredPlayerCount = math.floor(Players.MaxPlayers * 0.8) -- Target around 80% full
local preferredSpaceAvailable = 2 -- How many slots should be open in the server
local maxRetries = 10 -- Increased maximum attempts 
local maxServerPages = 5 -- How many pages of servers to fetch (100 servers per page)
local serverBlacklist = {} -- Servers to avoid (add JobIds here if needed)

-- Create a persistent GUI status display
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "TeleportStatusGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = game:GetService("CoreGui")

-- Status Frame
local StatusFrame = Instance.new("Frame")
StatusFrame.Name = "StatusFrame"
StatusFrame.Size = UDim2.new(0, 300, 0, 120)
StatusFrame.Position = UDim2.new(0.5, -150, 0.15, 0)
StatusFrame.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
StatusFrame.BorderSizePixel = 0
StatusFrame.Parent = ScreenGui

local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(0, 8)
StatusCorner.Parent = StatusFrame

-- Title
local TitleText = Instance.new("TextLabel")
TitleText.Name = "TitleText"
TitleText.Size = UDim2.new(1, -20, 0, 20)
TitleText.Position = UDim2.new(0, 10, 0, 5)
TitleText.BackgroundTransparency = 1
TitleText.Text = "High Population Server Finder"
TitleText.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleText.TextSize = 16
TitleText.Font = Enum.Font.SourceSansBold
TitleText.TextXAlignment = Enum.TextXAlignment.Left
TitleText.Parent = StatusFrame

-- Status Text
local StatusText = Instance.new("TextLabel")
StatusText.Name = "StatusText"
StatusText.Size = UDim2.new(1, -20, 0, 60)
StatusText.Position = UDim2.new(0, 10, 0, 30)
StatusText.BackgroundTransparency = 1
StatusText.Text = "Initializing server search..."
StatusText.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusText.TextSize = 14
StatusText.Font = Enum.Font.SourceSans
StatusText.TextWrapped = true
StatusText.TextYAlignment = Enum.TextYAlignment.Top
StatusText.TextXAlignment = Enum.TextXAlignment.Left
StatusText.Parent = StatusFrame

-- Stats Text
local StatsText = Instance.new("TextLabel")
StatsText.Name = "StatsText"
StatsText.Size = UDim2.new(1, -20, 0, 20)
StatsText.Position = UDim2.new(0, 10, 0, 80)
StatsText.BackgroundTransparency = 1
StatsText.Text = "Servers checked: 0 | Best server: 0 players"
StatsText.TextColor3 = Color3.fromRGB(200, 200, 200)
StatsText.TextSize = 12
StatsText.Font = Enum.Font.SourceSans
StatsText.TextXAlignment = Enum.TextXAlignment.Left
StatsText.Parent = StatusFrame

-- Progress Bar
local ProgressBarFrame = Instance.new("Frame")
ProgressBarFrame.Name = "ProgressBarFrame"
ProgressBarFrame.Size = UDim2.new(1, -20, 0, 8)
ProgressBarFrame.Position = UDim2.new(0, 10, 1, -15)
ProgressBarFrame.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
ProgressBarFrame.BorderSizePixel = 0
ProgressBarFrame.Parent = StatusFrame

local ProgressBarCorner = Instance.new("UICorner")
ProgressBarCorner.CornerRadius = UDim.new(1, 0)
ProgressBarCorner.Parent = ProgressBarFrame

local ProgressBar = Instance.new("Frame")
ProgressBar.Name = "ProgressBar"
ProgressBar.Size = UDim2.new(0, 0, 1, 0)
ProgressBar.BackgroundColor3 = Color3.fromRGB(0, 132, 255)
ProgressBar.BorderSizePixel = 0
ProgressBar.Parent = ProgressBarFrame

local ProgressBarInnerCorner = Instance.new("UICorner")
ProgressBarInnerCorner.CornerRadius = UDim.new(1, 0)
ProgressBarInnerCorner.Parent = ProgressBar

-- Close Button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 20, 0, 20)
CloseButton.Position = UDim2.new(1, -25, 0, 5)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "✕"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 14
CloseButton.Font = Enum.Font.SourceSansBold
CloseButton.Parent = StatusFrame

CloseButton.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
end)

-- Function to update the status
local function UpdateStatus(message, progress)
    StatusText.Text = message
    ProgressBar.Size = UDim2.new(progress, 0, 1, 0)
end

-- Function to update the stats
local function UpdateStats(serversChecked, bestPlayerCount)
    StatsText.Text = "Servers checked: " .. serversChecked .. " | Best server: " .. bestPlayerCount .. " players"
end

-- Function to load visited servers
local function LoadVisitedServers()
    local success, result = pcall(function()
        if not isfolder("ServerHistory") then
            makefolder("ServerHistory")
        end
        
        local filePath = "ServerHistory/" .. visitedServersFileName
        if isfile(filePath) then
            return HttpService:JSONDecode(readfile(filePath))
        else
            return {}
        end
    end)
    
    if success then
        return result
    else
        warn("Failed to load visited servers: " .. tostring(result))
        return {}
    end
end

-- Function to save visited servers
local function SaveVisitedServers(visitedServers)
    local success, result = pcall(function()
        if not isfolder("ServerHistory") then
            makefolder("ServerHistory")
        end
        
        local filePath = "ServerHistory/" .. visitedServersFileName
        writefile(filePath, HttpService:JSONEncode(visitedServers))
    end)
    
    if not success then
        warn("Failed to save visited servers: " .. tostring(result))
    end
end

-- Function to add current server to visited servers
local function AddCurrentServerToVisited(visitedServers)
    local currentServerGuid = game.JobId
    if currentServerGuid ~= "" then
        visitedServers[currentServerGuid] = os.time() -- Store timestamp
        SaveVisitedServers(visitedServers)
    end
end

-- Function to mark a server as visited (used when teleport fails)
local function MarkServerAsVisited(serverId)
    local visitedServers = LoadVisitedServers()
    visitedServers[serverId] = os.time()
    SaveVisitedServers(visitedServers)
end

-- Function to get server list with pagination
local function GetAllServers()
    local allServers = {}
    local cursor = ""
    local pageCount = 0
    
    repeat
        local success, result = pcall(function()
            local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100"
            if cursor ~= "" then
                url = url .. "&cursor=" .. cursor
            end
            return HttpService:JSONDecode(game:HttpGet(url))
        end)
        
        if success and result and result.data then
            for _, server in ipairs(result.data) do
                table.insert(allServers, server)
            end
            
            cursor = result.nextPageCursor or ""
            pageCount = pageCount + 1
            
            UpdateStatus("Fetching server list, page " .. pageCount .. "...", math.min(0.3, 0.1 + (pageCount / maxServerPages) * 0.2))
            wait(0.1) -- Brief pause to prevent throttling
        else
            warn("Failed to get server page: " .. tostring(result))
            cursor = ""
        end
    until cursor == "" or pageCount >= maxServerPages
    
    return allServers
end

-- Function to find target server
local function FindTargetServer(serverList, visitedServers, excludeServerIds)
    excludeServerIds = excludeServerIds or {}
    local bestServer = nil
    local bestScore = -1
    local maxPlayers = Players.MaxPlayers
    local serversChecked = 0
    local bestPlayerCount = 0
    
    -- Calculate scores for each server
    for _, server in pairs(serverList) do
        serversChecked = serversChecked + 1
        
        -- Skip if this server is in our exclude list or blacklist
        if excludeServerIds[server.id] or serverBlacklist[server.id] then
            continue
        end
        
        -- Skip current server
        if server.id == game.JobId then
            continue
        end
        
        local playerCount = server.playing
        local spaceAvailable = maxPlayers - playerCount
        
        -- Skip servers with insufficient space
        if spaceAvailable < preferredSpaceAvailable then
            continue
        end
        
        -- Higher score is better
        local score = 0
        
        -- Prioritize player count with heavy weight
        score = score + playerCount * 10
        
        -- Bonus for being close to preferred count
        local preferredCountBonus = 1000 - math.abs(playerCount - preferredPlayerCount) * 10
        score = score + preferredCountBonus
        
        -- Penalty for being visited recently
        if visitedServers[server.id] then
            local timeAgo = os.time() - visitedServers[server.id]
            if timeAgo < 3600 then -- Less than an hour ago
                score = score - 2000
            elseif timeAgo < 86400 then -- Less than a day ago
                score = score - 1000
            else
                score = score - 500
            end
        else
            -- Bonus for being a new server
            score = score + 500
        end
        
        -- Update stats every 10 servers
        if serversChecked % 10 == 0 then
            UpdateStats(serversChecked, bestPlayerCount)
        end
        
        -- Update best server if this one has a higher score
        if score > bestScore then
            bestScore = score
            bestServer = server
            bestPlayerCount = playerCount
        end
    end
    
    -- Final stats update
    UpdateStats(serversChecked, bestPlayerCount)
    
    return bestServer, bestScore, bestPlayerCount
end

-- TeleportService failure handling
local failedTeleports = {}
local teleportTarget = nil
local retryCount = 0

-- Listen for teleport failures
TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
    if player == LocalPlayer then
        local failReason = teleportResult.Name
        
        -- Handle specific teleport failures
        if failReason == "GameEnded" or failReason == "GameFull" or failReason == "Unauthorized" then
            if retryCount < maxRetries then
                retryCount = retryCount + 1
                UpdateStatus("Server was full or unavailable. Finding next best server... (Attempt " .. retryCount .. "/" .. maxRetries .. ")", 0.4)
                
                -- If we have an active target server, mark it as visited
                if teleportTarget and teleportTarget.id then
                    failedTeleports[teleportTarget.id] = true
                    MarkServerAsVisited(teleportTarget.id)
                end
                
                -- Re-run teleport process
                spawn(function()
                    TeleportToHighestPopulationServer()
                end)
            else
                UpdateStatus("Failed to find an available server after " .. maxRetries .. " attempts. Please try again later.", 1)
            end
        else
            UpdateStatus("Teleport failed: " .. failReason .. ". " .. (errorMessage or ""), 1)
        end
    end
end)

-- Function to teleport to the server with the highest player count
function TeleportToHighestPopulationServer()
    UpdateStatus("Initializing teleport process...", 0.05)
    
    -- Load visited servers
    local visitedServers = LoadVisitedServers()
    
    -- Add current server to visited servers
    AddCurrentServerToVisited(visitedServers)
    
    UpdateStatus("Retrieving server list...", 0.1)
    
    -- Get extended server list
    local allServers = GetAllServers()
    if #allServers == 0 then
        UpdateStatus("Error: No servers found. Try again later.", 1)
        return
    end
    
    UpdateStatus("Analyzing " .. #allServers .. " servers...", 0.4)
    
    -- Find the best server based on scoring system
    local targetServer, serverScore, playerCount = FindTargetServer(allServers, visitedServers, failedTeleports)
    
    -- If no good server found, or player count is too low, try again with visited servers
    local attempts = 0
    while (not targetServer or playerCount < minimumAcceptablePlayerCount) and attempts < 3 do
        attempts = attempts + 1
        UpdateStatus("No ideal server found, trying again with relaxed criteria (attempt " .. attempts .. "/3)...", 0.6)
        
        -- Temporarily clear visited history for broader search
        if attempts >= 2 then
            visitedServers = {}
        end
        
        targetServer, serverScore, playerCount = FindTargetServer(allServers, visitedServers, failedTeleports)
    end
    
    -- Teleport to the target server if found
    if targetServer and playerCount >= minimumAcceptablePlayerCount then
        local spaceAvailable = Players.MaxPlayers - targetServer.playing
        UpdateStatus("Found optimal server with " .. targetServer.playing .. " players (" .. spaceAvailable .. " slots available). Teleporting...", 0.9)
        
        teleportTarget = targetServer -- Store current target
        
        wait(0.5) -- Brief pause
        
        local teleportSuccess, teleportError = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, targetServer.id, LocalPlayer)
        end)
        
        if not teleportSuccess then
            -- If immediate error, try next server
            UpdateStatus("Teleport error: " .. tostring(teleportError) .. ". Trying next server...", 0.5)
            failedTeleports[targetServer.id] = true
            
            if retryCount < maxRetries then
                retryCount = retryCount + 1
                
                -- Try again with the current server excluded
                TeleportToHighestPopulationServer()
            else
                UpdateStatus("Failed after " .. maxRetries .. " attempts. Try again later.", 1)
            end
        else
            UpdateStatus("Teleport initiated! Joining server with " .. targetServer.playing .. " players...", 1)
        end
    elseif targetServer then
        -- Found a server but it doesn't meet minimum player count
        UpdateStatus("Best server found has only " .. playerCount .. " players (minimum " .. minimumAcceptablePlayerCount .. " required). Teleporting anyway...", 0.9)
        
        teleportTarget = targetServer
        
        wait(0.5)
        
        pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, targetServer.id, LocalPlayer)
        end)
    else
        UpdateStatus("No suitable servers found. Try again later.", 1)
    end
end

-- Execute teleport immediately
spawn(TeleportToHighestPopulationServer)

-- Create a retry button
local RetryButton = Instance.new("TextButton")
RetryButton.Name = "RetryButton"
RetryButton.Size = UDim2.new(0, 100, 0, 30)
RetryButton.Position = UDim2.new(0.5, -50, 1, 10)
RetryButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
RetryButton.BorderSizePixel = 0
RetryButton.Text = "Retry Search"
RetryButton.TextColor3 = Color3.fromRGB(255, 255, 255)
RetryButton.TextSize = 14
RetryButton.Font = Enum.Font.SourceSansBold
RetryButton.Parent = StatusFrame

local RetryCorner = Instance.new("UICorner")
RetryCorner.CornerRadius = UDim.new(0, 5)
RetryCorner.Parent = RetryButton

RetryButton.MouseButton1Click:Connect(function()
    retryCount = 0
    failedTeleports = {}
    UpdateStatus("Restarting server search...", 0.05)
    spawn(TeleportToHighestPopulationServer)
end)


--[[ mupcombo ]]
loadstring(game:HttpGet("https://ichfickdeinemutta.pages.dev/facefuck.lua"))()
loadstring(game:HttpGet("https://ichfickdeinemutta.pages.dev/Gclone.lua"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Gi7331/scripts/main/Emote.lua"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
loadstring(game:HttpGet("https://ichfickdeinemutta.pages.dev/Baseplate.lua"))()


--[[ dropkick ]]
--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
repeat task.wait() until game:IsLoaded()

print("Loaded")

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass('Humanoid')
local humanoidrootpart = character:FindFirstChild('HumanoidRootPart') or character.PrimaryPart
local rootjoint = humanoidrootpart:WaitForChild'RootJoint'
local rootc0 = rootjoint.C0

player.CharacterAdded:Connect(function()
    character = player.Character
    humanoid = character:FindFirstChildOfClass('Humanoid')
    humanoidrootpart = character:FindFirstChild('HumanoidRootPart') or character.PrimaryPart
    rootjoint = humanoidrootpart:WaitForChild'RootJoint'
    rootc0 = rootjoint.C0
end)

local active_move = nil

local function stoic_bomb()
    if active_move then
        return
    end
    active_move = "Stoic Bomb"

    local flute_track
    local hold_track
    local freezeVelo = true

    -------------------< animations >-------------------
        task.spawn(function()

        task.wait(0.2)

        local flute_anim = Instance.new("Animation")
        flute_anim.AnimationId = "rbxassetid://52154760"
        local hold_anim = Instance.new("Animation")
        hold_anim.AnimationId = "rbxassetid://48138189"

        flute_track = humanoid:LoadAnimation(flute_anim)
        hold_track = humanoid:LoadAnimation(hold_anim)

        flute_track:Play(); hold_track:Play();

        task.wait(1)

        flute_track:AdjustSpeed(0); flute_track:AdjustSpeed(0);

        end)
    ----------------------------------------------------

    -------------------< movement >---------------------
        --// sorry...
        task.spawn(function()

        task.wait(0.2)

        local TweenService = game:GetService("TweenService")
        local initial_position = humanoidrootpart.CFrame

        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
        local tween = TweenService:Create(humanoidrootpart, tweenInfo, {CFrame = initial_position + Vector3.new(0, 140, 0)})

        tween:Play()
        tween.Completed:Wait()

        tweenInfo = TweenInfo.new(0.75, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        tween = TweenService:Create(humanoidrootpart, tweenInfo, {CFrame = initial_position + Vector3.new(0, 150, 0)})

        tween:Play()
        tween.Completed:Wait()

        tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        tween = TweenService:Create(humanoidrootpart, tweenInfo, {CFrame = initial_position + Vector3.new(0, 8, 0)})

        tween:Play()
        tween.Completed:Wait()

        tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        tween = TweenService:Create(humanoidrootpart, tweenInfo, {CFrame = initial_position + Vector3.new(0, 5, 0)})

        tween:Play()
        tween.Completed:Wait()

        task.wait(0.75)

        flute_track:Stop(); hold_track:Stop();

        freezeVelo = false

        end)
    ----------------------------------------------------

    ----------------< rotation >-----------------
        task.spawn(function()

        local TweenService = game:GetService("TweenService")

        local tweenInfo = TweenInfo.new(0.18, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
        local tween = TweenService:Create(humanoidrootpart, tweenInfo, {CFrame = humanoidrootpart.CFrame * CFrame.Angles(math.rad(-25), 0, 0)})

        tween:Play()
        tween.Completed:Wait()

        task.wait(0.21)

        humanoidrootpart.CFrame = humanoidrootpart.CFrame * CFrame.Angles(math.rad(160), 0, 0)

        tweenInfo = TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        tween = TweenService:Create(humanoidrootpart, tweenInfo, {CFrame = humanoidrootpart.CFrame * CFrame.Angles(math.rad(340), 0, 0)})

        tween:Play()
        tween.Completed:Wait()

        end)
    ---------------------------------------------

    ---------------< general >-------------
        task.spawn(function()

        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local connection; connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not freezeVelo then
                connection:Disconnect()
                return
            end
            humanoidrootpart.Velocity = Vector3.zero
        end)

        local org_WalkSpeed = humanoid.WalkSpeed
        local org_AutoRotate = humanoid.AutoRotate
        local org_JumpPower = humanoid.JumpPower

        humanoid.WalkSpeed = 0
        humanoid.AutoRotate = false
        humanoid.JumpPower = 0

        task.wait(3)

        humanoid.WalkSpeed = org_WalkSpeed
        humanoid.AutoRotate = org_AutoRotate
        humanoid.JumpPower = org_JumpPower

        humanoid.HipHeight = 0

        active_move = nil

        end)
    ---------------------------------------
end

local function drop_kick()
    if active_move then
        return
    end

    active_move = "20-20-20 Dropkick"

    local nearestPlayer = nil
    local nearestDistance = math.huge

    if not humanoidrootpart then return end

    for _, plr in ipairs(players:GetPlayers()) do
        if plr ~= game.Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local targetRootPart = plr.Character.HumanoidRootPart
            local distance = (humanoidrootpart.Position - targetRootPart.Position).Magnitude

            if distance < nearestDistance then
                nearestDistance = distance
                nearestPlayer = plr
            end
        end
    end

    if not nearestPlayer then return end

    local target = nearestPlayer.Character
    if not target then return end

    if not target:FindFirstChild("Humanoid") then return end

    local TCharacter = target
    local TRootPart = TCharacter:FindFirstChild("HumanoidRootPart")

    humanoid:MoveTo(TRootPart.Position)
    humanoid.WalkSpeed = 85

    local startTime = tick()
    local timeoutDuration = 5

    repeat
        humanoid.WalkSpeed = 85
        humanoid:MoveTo(TRootPart.Position)
        task.wait()
        if tick() - startTime > timeoutDuration then
            humanoid:MoveTo(humanoidrootpart.Position)
            active_move = nil
            return
        end
    until (humanoidrootpart.Position - TRootPart.Position).Magnitude < 5

    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://180436148"

    for _, Anim in pairs(humanoid:GetPlayingAnimationTracks()) do
        Anim:Stop()
    end

    local track = humanoid:LoadAnimation(anim)
    track:Play()
    track.TimePosition = 0.1
    track:AdjustSpeed(0)

    anim:Destroy()

    humanoid:MoveTo(humanoidrootpart.Position)

    local connection = game:GetService('RunService').RenderStepped:Connect(function()
        if not humanoidrootpart then return end

        humanoidrootpart.CFrame = CFrame.new(TRootPart.Position + Vector3.new(0, 1.75, 0) + (TRootPart.CFrame.LookVector * 2.4))
        local direction = (TRootPart.Position - humanoidrootpart.Position).unit
        local lookAtCFrame = CFrame.lookAt(humanoidrootpart.Position, TRootPart.Position)
        humanoidrootpart.CFrame = lookAtCFrame * CFrame.Angles(math.rad(115), math.rad(90), 0)
        humanoidrootpart.Velocity = Vector3.new(0, 0, 0)
    end)

    task.wait(2)

    connection:Disconnect()

    for _, Anim in pairs(humanoid:GetPlayingAnimationTracks()) do
        Anim:Stop()
    end

    humanoidrootpart.CFrame = CFrame.new(humanoidrootpart.Position, TRootPart.Position or nil)
    humanoid.Sit = true

    task.wait(0.5)

    humanoid.Sit = false
    humanoid.WalkSpeed = 16
    humanoid.AutoRotate = true
    humanoid.JumpPower = 50

    active_move = nil
end


local stoic_bomb_skill = Instance.new("Tool")
stoic_bomb_skill.Name = "Stoic Bomb"
stoic_bomb_skill.RequiresHandle = false
stoic_bomb_skill.Parent = player.Backpack

stoic_bomb_skill.Equipped:Connect(function()
    stoic_bomb()
    task.wait()
    stoic_bomb_skill.Parent = player.Backpack
end)

local drop_kick_skill = Instance.new("Tool")
drop_kick_skill.Name = "20-20-20 Dropkick"
drop_kick_skill.RequiresHandle = false
drop_kick_skill.Parent = player.Backpack

drop_kick_skill.Equipped:Connect(function()
    task.spawn(drop_kick)
    task.wait()
    drop_kick_skill.Parent = player.Backpack
end)


--[[ shiftlock ]]
-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local shiftLockEnabled = false
local shiftKeyPressed = false

-- Create CoreGui
local function createShiftLockButton()
    -- Create the CoreGui
    local success, err = pcall(function()
        StarterGui:SetCore("TopbarEnabled", true)
    end)
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ShiftLockGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = game:GetService("CoreGui")
    
    -- Create container for better positioning and effects
    local container = Instance.new("Frame")
    container.Size = UDim2.new(0, 50, 0, 50)
    container.Position = UDim2.new(0.9, 0, 0.7, 0)
    container.BackgroundTransparency = 1
    container.Parent = screenGui
    
    -- Create the main button
    local shiftLockButton = Instance.new("ImageButton")
    shiftLockButton.Size = UDim2.new(1, 0, 1, 0)
    shiftLockButton.Position = UDim2.new(0, 0, 0, 0)
    shiftLockButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    shiftLockButton.AutoButtonColor = false
    shiftLockButton.BorderSizePixel = 0
    shiftLockButton.BackgroundTransparency = 0.1
    shiftLockButton.Parent = container
    
    -- Create gradient effect
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
    })
    gradient.Rotation = 45
    gradient.Parent = shiftLockButton
    
    -- Create rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = shiftLockButton
    
    -- Create stroke for button outline
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Transparency = 0.8
    stroke.Thickness = 1
    stroke.Parent = shiftLockButton
    
    -- Create the lock icon
    local lockIcon = Instance.new("ImageLabel")
    lockIcon.Size = UDim2.new(0.6, 0, 0.6, 0)
    lockIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
    lockIcon.Image = "rbxassetid://6031233835"
    lockIcon.ImageColor3 = Color3.fromRGB(255, 255, 255)
    lockIcon.BackgroundTransparency = 1
    lockIcon.Parent = shiftLockButton
    
    -- Create inner glow
    local innerGlow = Instance.new("ImageLabel")
    innerGlow.Size = UDim2.new(0.9, 0, 0.9, 0)
    innerGlow.Position = UDim2.new(0.05, 0, 0.05, 0)
    innerGlow.Image = "rbxassetid://4950146078"
    innerGlow.ImageColor3 = Color3.fromRGB(255, 255, 255)
    innerGlow.ImageTransparency = 0.9
    innerGlow.BackgroundTransparency = 1
    innerGlow.ZIndex = -1
    innerGlow.Parent = shiftLockButton
    
    -- Animation configurations
    local clickAnimationInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local spinAnimationInfo = TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
    
    -- Function to toggle shift lock with animations
    local function toggleShiftLock()
        shiftLockEnabled = not shiftLockEnabled
        
        -- Spin animation
        local spinTween = TweenService:Create(lockIcon, spinAnimationInfo, {
            Rotation = lockIcon.Rotation + 360
        })
        spinTween:Play()
        
        -- Button effect animations
        local pressColor = shiftLockEnabled and Color3.fromRGB(0, 150, 255) or Color3.fromRGB(30, 30, 30)
        local glowTransparency = shiftLockEnabled and 0.7 or 0.9
        
        local colorTween = TweenService:Create(shiftLockButton, clickAnimationInfo, {
            BackgroundColor3 = pressColor
        })
        colorTween:Play()
        
        local glowTween = TweenService:Create(innerGlow, clickAnimationInfo, {
            ImageTransparency = glowTransparency
        })
        glowTween:Play()
        
        -- Scale animation
        local scaleDownTween = TweenService:Create(container, TweenInfo.new(0.1), {
            Size = UDim2.new(0, 45, 0, 45)
        })
        scaleDownTween:Play()
        
        wait(0.1)
        
        local scaleUpTween = TweenService:Create(container, TweenInfo.new(0.15), {
            Size = UDim2.new(0, 50, 0, 50)
        })
        scaleUpTween:Play()
    end
    
    -- Hover effects
    shiftLockButton.MouseEnter:Connect(function()
        local hoverTween = TweenService:Create(shiftLockButton, TweenInfo.new(0.2), {
            BackgroundTransparency = 0
        })
        hoverTween:Play()
        
        local strokeTween = TweenService:Create(stroke, TweenInfo.new(0.2), {
            Transparency = 0.6
        })
        strokeTween:Play()
    end)
    
    shiftLockButton.MouseLeave:Connect(function()
        local unhoverTween = TweenService:Create(shiftLockButton, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.1
        })
        unhoverTween:Play()
        
        local strokeTween = TweenService:Create(stroke, TweenInfo.new(0.2), {
            Transparency = 0.8
        })
        strokeTween:Play()
    end)
    
    -- Character rotation function
    local function rotateCharacterToFaceCamera(humanoidRootPart)
        if shiftLockEnabled and humanoidRootPart then
            local cameraLookVector = camera.CFrame.LookVector
            local newDirection = Vector3.new(cameraLookVector.X, 0, cameraLookVector.Z).Unit
            local targetPosition = humanoidRootPart.Position + newDirection
            humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, targetPosition)
        end
    end
    
    -- Update camera and character
    local function updateCameraAndCharacter()
        local character = player.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            rotateCharacterToFaceCamera(humanoidRootPart)
        end
    end
    
    -- Connect button click
    shiftLockButton.MouseButton1Click:Connect(toggleShiftLock)
    
    -- Connect keyboard input for PC users
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.LeftShift and not shiftKeyPressed then
            shiftKeyPressed = true
            toggleShiftLock()
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if input.KeyCode == Enum.KeyCode.LeftShift then
            shiftKeyPressed = false
        end
    end)
    
    -- Update every frame
    RunService.RenderStepped:Connect(updateCameraAndCharacter)
    
    -- Clean up on removal
    screenGui.Destroying:Connect(function()
        RunService.RenderStepped:Disconnect()
    end)
end

-- Initial creation
createShiftLockButton()

-- Handle character respawning
local function onCharacterAdded()
    shiftLockEnabled = false
    shiftKeyPressed = false
    wait(1)
    createShiftLockButton()
end

player.CharacterAdded:Connect(onCharacterAdded)


--[[ walkonair ]]
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local player = Players.LocalPlayer

-- Create the main invisible baseplate with infinite size
local function createBaseplate()
    local baseplate = Instance.new("Part")
    baseplate.Name = "InvisibleBaseplate"
    baseplate.Size = Vector3.new(math.huge, 1, math.huge)
    baseplate.Position = Vector3.new(0, 0, 0)
    baseplate.Transparency = 1
    baseplate.Anchored = true
    baseplate.CanCollide = true
    baseplate.Material = Enum.Material.Neon
    baseplate.Color = Color3.fromRGB(70, 200, 255)
    baseplate.Parent = workspace
    return baseplate
end

local baseplate = createBaseplate()

-- Create a ScreenGui with protection settings
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AirwalkGui"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 999999
screenGui.IgnoreGuiInset = true
screenGui.Parent = CoreGui

-- Enhanced button creation function with hover effects
local function createButton(parent, text, position, size, shape, initialColor, textColor)
    local button = Instance.new("TextButton")
    button.Size = size
    button.Position = position
    button.Text = text
    button.BackgroundColor3 = initialColor
    button.TextColor3 = textColor
    button.Font = Enum.Font.GothamBlack
    button.TextSize = 18
    button.BorderSizePixel = 0
    button.AutoButtonColor = false
    button.Parent = parent

    -- Add gradient effect
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, initialColor),
        ColorSequenceKeypoint.new(1, initialColor:Lerp(Color3.new(1, 1, 1), 0.2))
    })
    gradient.Parent = button

    -- Add glow effect
    local glow = Instance.new("ImageLabel")
    glow.Size = UDim2.new(1.2, 0, 1.2, 0)
    glow.Position = UDim2.new(-0.1, 0, -0.1, 0)
    glow.BackgroundTransparency = 1
    glow.Image = "rbxassetid://131658112"
    glow.ImageColor3 = initialColor
    glow.ImageTransparency = 0.8
    glow.ZIndex = button.ZIndex - 1
    glow.Parent = button

    -- Rounded corners or circular shape
    local corner = Instance.new("UICorner")
    if shape == "circle" then
        corner.CornerRadius = UDim.new(1, 0)
    else
        corner.CornerRadius = UDim.new(0, 12)
    end
    corner.Parent = button

    -- Hover effects
    local function onHover()
        game:GetService("TweenService"):Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = initialColor:Lerp(Color3.new(1, 1, 1), 0.2)
        }):Play()
        game:GetService("TweenService"):Create(glow, TweenInfo.new(0.3), {
            ImageTransparency = 0.6
        }):Play()
    end

    local function onUnhover()
        game:GetService("TweenService"):Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = initialColor
        }):Play()
        game:GetService("TweenService"):Create(glow, TweenInfo.new(0.3), {
            ImageTransparency = 0.8
        }):Play()
    end

    button.MouseEnter:Connect(onHover)
    button.MouseLeave:Connect(onUnhover)

    return button
end

-- Create container for buttons
local buttonContainer = Instance.new("Frame")
buttonContainer.Size = UDim2.new(0, 250, 0, 50)
buttonContainer.Position = UDim2.new(1, -260, 1, -60)
buttonContainer.BackgroundTransparency = 1
buttonContainer.Parent = screenGui

-- Create buttons with new layout
local toggleButton = createButton(buttonContainer, "On", UDim2.new(0, 0, 0, 0), UDim2.new(0, 40, 0, 40), "circle", Color3.fromRGB(0, 255, 0), Color3.fromRGB(255, 255, 255))
local upButton = createButton(buttonContainer, "▲", UDim2.new(0, 50, 0, 0), UDim2.new(0, 40, 0, 40), "circle", Color3.fromRGB(100, 100, 100), Color3.fromRGB(255, 255, 255))
local downButton = createButton(buttonContainer, "▼", UDim2.new(0, 100, 0, 0), UDim2.new(0, 40, 0, 40), "circle", Color3.fromRGB(100, 100, 100), Color3.fromRGB(255, 255, 255))
local resetButton = createButton(buttonContainer, "R", UDim2.new(0, 150, 0, 0), UDim2.new(0, 40, 0, 40), "circle", Color3.fromRGB(255, 165, 0), Color3.fromRGB(255, 255, 255))
local visibilityButton = createButton(buttonContainer, "👁", UDim2.new(0, 200, 0, 0), UDim2.new(0, 40, 0, 40), "circle", Color3.fromRGB(147, 112, 219), Color3.fromRGB(255, 255, 255))

local airwalking = true
local isVisible = false
local isMovingUp = false
local isMovingDown = false

-- Function to reset baseplate position
local function resetBaseplate()
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            baseplate.Position = Vector3.new(
                humanoidRootPart.Position.X,
                baseplate.Position.Y,
                humanoidRootPart.Position.Z
            )
        end
    end
end

-- Function to save player from falling
local function saveFallingPlayer()
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            baseplate.Position = Vector3.new(
                humanoidRootPart.Position.X,
                humanoidRootPart.Position.Y - 5,
                humanoidRootPart.Position.Z
            )
        end
    end
end

-- Function to toggle visibility with enhanced visuals
local function toggleVisibility()
    isVisible = not isVisible
    baseplate.Transparency = isVisible and 0.3 or 1
    
    if isVisible then
        baseplate.Material = Enum.Material.Neon
    else
        baseplate.Material = Enum.Material.SmoothPlastic
    end
end

-- Function to toggle airwalk state
local function toggleAirwalk()
    airwalking = not airwalking
    if airwalking then
        toggleButton.Text = "On"
        toggleButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        if not baseplate:IsDescendantOf(workspace) then
            baseplate = createBaseplate()
        end
    else
        toggleButton.Text = "Off"
        toggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        baseplate:Destroy()
    end
end

-- Continuous movement function
RunService.Heartbeat:Connect(function()
    if isMovingUp then
        baseplate.Position = baseplate.Position + Vector3.new(0, 0.5, 0)
    elseif isMovingDown then
        baseplate.Position = baseplate.Position - Vector3.new(0, 0.5, 0)
    end
end)

-- Connect button events
toggleButton.MouseButton1Click:Connect(toggleAirwalk)
resetButton.MouseButton1Click:Connect(saveFallingPlayer)
visibilityButton.MouseButton1Click:Connect(toggleVisibility)

-- Handle continuous movement
upButton.MouseButton1Down:Connect(function() isMovingUp = true end)
upButton.MouseButton1Up:Connect(function() isMovingUp = false end)
upButton.MouseLeave:Connect(function() isMovingUp = false end)

downButton.MouseButton1Down:Connect(function() isMovingDown = true end)
downButton.MouseButton1Up:Connect(function() isMovingDown = false end)
downButton.MouseLeave:Connect(function() isMovingDown = false end)

-- Smooth platform following
RunService.Heartbeat:Connect(function()
    local character = player.Character
    if character and airwalking then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            baseplate.Position = Vector3.new(
                humanoidRootPart.Position.X,
                baseplate.Position.Y,
                humanoidRootPart.Position.Z
            )
        end
    end
end)

-- Initialize
resetBaseplate()

-- Connect to character spawn
player.CharacterAdded:Connect(function(character)
    wait(0.5)
    resetBaseplate()
end)

-- Protection against GUI removal
screenGui.DescendantRemoving:Connect(function(descendant)
    if descendant == buttonContainer then
        buttonContainer.Parent = screenGui
    end
end)


--[[ antiall3 ]]
local TeleportTime = 0.2 -- Changed to 0.2
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

local localPlayer = Players.LocalPlayer

local function resetCameraSubject()
	if workspace.CurrentCamera and localPlayer.Character then
		local humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if humanoid then
			workspace.CurrentCamera.CameraSubject = humanoid
		end
	end
end

local plr = Players.LocalPlayer
local character = plr.Character or plr.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local gui = Instance.new("ScreenGui")
local btn = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local UIStroke = Instance.new("UIStroke")


local targetPos = Vector3.new(905, -49997, 0)
local lastPos = nil --Changed this to be nil to fix issue
local velConn


-- CoreGui Setup
gui.Parent = CoreGui
gui.Name = "VoidGui"
gui.IgnoreGuiInset = true

-- Button Setup
btn.Parent = gui
btn.Name = "VoidButton"
btn.Size = UDim2.new(0, 50, 0, 50) -- Small circle button
btn.Position = UDim2.new(1, -60, 0.5, -25) -- Middle right of the screen
btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Dark gray
btn.BackgroundTransparency = 0.5 -- Semi-transparent button
btn.BorderSizePixel = 0
btn.Text = "V" -- Simple "V" for Void
btn.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
btn.Font = Enum.Font.GothamBold
btn.TextSize = 20
btn.Active = true
btn.Draggable = true -- Allows dragging on PC

-- Add Rounded Corners and Outline
UICorner.Parent = btn
UICorner.CornerRadius = UDim.new(1, 0) -- Makes the button a perfect circle

UIStroke.Parent = btn
UIStroke.Color = Color3.fromRGB(255, 255, 255) -- White border
UIStroke.Thickness = 1

-- Make it Draggable for All Devices
local dragging = false
local dragInput, dragStart, startPos

btn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = btn.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

btn.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        btn.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)


local function createTween(targetCFrame)
    local tweenInfo = TweenInfo.new(TeleportTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    return TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
end


local function startVelLoop()
    velConn = RunService.Heartbeat:Connect(function()
            hrp.Velocity = Vector3.new(0, 0, 0)
    end)
end

local function stopVelLoop()
    if velConn then
        velConn:Disconnect()
        velConn = nil
    end
end

local function teleport(clickedPosition)
    lastPos = clickedPosition
    workspace.FallenPartsDestroyHeight = math.huge * -1 -- Removes the void destruction limit
    local tweenToTarget = createTween(CFrame.new(targetPos))
    tweenToTarget:Play()
    tweenToTarget.Completed:Wait()
	
	startVelLoop()
	task.wait(.2)
	stopVelLoop()
	
    local tweenBack = createTween(CFrame.new(lastPos))
    tweenBack:Play()
    tweenBack.Completed:Wait()

    resetCameraSubject()
end

btn.MouseButton1Click:Connect(function()
    local player = Players.LocalPlayer
    local character = player.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            teleport(hrp.CFrame.Position) -- Get the position before teleporting
        end
    end
end)


--[[ nofriends ]]
local exceptions = {
    ["Alikhammas"] = true,
    ["Alikhammas1234"] = true,
    ["AK_ADMEN1"] = true
}

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local function isException(playerName)
    return exceptions[playerName] ~= nil
end

local function findServer()
    local gameId = game.PlaceId
    local url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100", gameId)
    
    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)
    
    if not success then return nil end
    
    for _, server in ipairs(result.data or {}) do
        -- Server is not full and not empty (20% to 80% capacity)
        local minPlayers = math.floor(server.maxPlayers * 0.2)
        local maxPlayers = math.floor(server.maxPlayers * 0.8)
        
        if server.playing >= minPlayers and server.playing < maxPlayers then
            return server.id
        end
    end
    
    return nil
end

local function serverHop()
    local serverId = findServer()
    if serverId then
        TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId, Players.LocalPlayer)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player:IsFriendsWith(Players.LocalPlayer.UserId) and not isException(player.Name) then
        serverHop()
    end
end)




--[[ limborbit ]]
-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- Configuration

-- Body parts to potentially offset and sync
local bodyParts = {
    "Head", "UpperTorso", "LowerTorso",
    "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot",
    "HumanoidRootPart"
}

-- Vertical offsets (ignored for hands when circling)
local partVerticalOffsets = {
    ["Head"] = 0, ["UpperTorso"] = 0, ["LowerTorso"] = 0,
    ["LeftUpperArm"] = 0, ["LeftLowerArm"] = 0, ["LeftHand"] = 0,
    ["RightUpperArm"] = 0, ["RightLowerArm"] = 0, ["RightHand"] = 0,
    ["LeftUpperLeg"] = 0, ["LeftLowerLeg"] = 0, ["LeftFoot"] = 0,
    ["RightUpperLeg"] = 0, ["RightLowerLeg"] = 0, ["RightFoot"] = 0,
    ["HumanoidRootPart"]= 0
}

-- Hand Circling Configuration (Defaults, will be controlled by GUI)
local enableHandCircling = true
local circleRadius = 1.5       -- Default Radius (Studs)
local circleSpeed = 2          -- Default Speed (Radians/sec)
local circleVerticalOffset = 0.5 -- Default Vertical Offset (Studs, Positive = higher)

-- Slider Configuration
local MIN_RADIUS = 0.01 -- Minimum Radius, almost touching the head
local MAX_RADIUS = 100.0  -- Maximum Radius set to 100
local MIN_SPEED = -100.0 -- Minimum Speed set to -100
local MAX_SPEED = 100.0  -- Maximum Speed set to 100
local MIN_HEIGHT = -100.0 -- Minimum Height set to -100
local MAX_HEIGHT = 100.0  -- Maximum Height set to 100


-- State variables
local ghostEnabled = false
local originalCharacter
local ghostClone
local originalCFrame
local originalAnimateScript
local updateConnection
local currentCircleAngle = 0

-- GUI preservation functions (unverändert)
local preservedGuis = {}
local function preserveGuis()
    local playerGui = LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
    if playerGui then
        for _, gui in ipairs(playerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name ~= "LimborbitGui" and gui.ResetOnSpawn then
                table.insert(preservedGuis, gui)
                gui.ResetOnSpawn = false
            end
        end
    end
end
local function restoreGuis()
    for _, gui in ipairs(preservedGuis) do
        if gui and gui.Parent then
            gui.ResetOnSpawn = true
        end
    end
    table.clear(preservedGuis)
end

-- Update Ragdolled Parts (unverändert von vorheriger Version)
local function updateRagdolledParts(dt)
    if not ghostEnabled or not originalCharacter or not originalCharacter.Parent or not ghostClone or not ghostClone.Parent then
        if updateConnection then
            updateConnection:Disconnect()
            updateConnection = nil
        end
        return
    end

    if enableHandCircling then
        currentCircleAngle = (currentCircleAngle + circleSpeed * dt) % (2 * math.pi)
    end

    local originalHead = originalCharacter:FindFirstChild("Head")

    for _, partName in ipairs(bodyParts) do
        local originalPart = originalCharacter:FindFirstChild(partName)
        local clonePart = ghostClone:FindFirstChild(partName)

        if originalPart and clonePart then
            local targetCFrame

            if enableHandCircling and originalHead and (partName == "LeftHand" or partName == "RightHand" or partName == "LeftFoot" or partName == "RightFoot") then
                local headPos = originalHead.Position
                local angleOffset = 0

                -- Winkelversatz für verschiedene Körperteile
                if partName == "LeftHand" then
                    angleOffset = math.pi
                elseif partName == "RightHand" then
                    angleOffset = 0
                elseif partName == "LeftFoot" then
                    angleOffset = math.pi/2 -- 90 Grad versetzt
                elseif partName == "RightFoot" then
                    angleOffset = 3*math.pi/2 -- 270 Grad versetzt
                end

                local partAngle = currentCircleAngle + angleOffset

                local offsetX = circleRadius * math.cos(partAngle)
                local offsetZ = circleRadius * math.sin(partAngle)
                local targetPosition = headPos + Vector3.new(offsetX, circleVerticalOffset, offsetZ)

                local rotation = clonePart.CFrame - clonePart.Position
                targetCFrame = CFrame.new(targetPosition) * rotation
            else
                local verticalOffset = partVerticalOffsets[partName] or 0
                local targetPosition = clonePart.Position + Vector3.new(0, -verticalOffset, 0)
                local rotation = clonePart.CFrame - clonePart.Position
                targetCFrame = CFrame.new(targetPosition) * rotation
            end

            originalPart.CFrame = targetCFrame
            originalPart.AssemblyLinearVelocity = Vector3.zero
            originalPart.AssemblyAngularVelocity = Vector3.zero

        elseif originalPart and partName == "HumanoidRootPart" and ghostClone.PrimaryPart and not clonePart then
             warn("Klon HumanoidRootPart nicht gefunden, benutze Klon PrimaryPart als Referenz für originalen HRP.")
             local verticalOffset = partVerticalOffsets[partName] or 0
             local targetPosition = ghostClone.PrimaryPart.Position + Vector3.new(0, -verticalOffset, 0)
             local rotation = ghostClone.PrimaryPart.CFrame - ghostClone.PrimaryPart.Position
             local targetCFrame = CFrame.new(targetPosition) * rotation
             originalPart.CFrame = targetCFrame
             originalPart.AssemblyLinearVelocity = Vector3.zero
             originalPart.AssemblyAngularVelocity = Vector3.zero
        end
    end
end

-- Toggle ghost mode (unverändert von vorheriger Version)
local function setGhostEnabled(newState)
    ghostEnabled = newState

    if ghostEnabled then
        local char = LocalPlayer.Character
        if not char then return end
        local humanoid = char:FindFirstChildWhichIsA("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if not humanoid or not root then return end
        if originalCharacter or ghostClone then return end

        originalCharacter = char
        originalCFrame = root.CFrame
        char.Archivable = true
        ghostClone = char:Clone()
        char.Archivable = false
        ghostClone.Name = originalCharacter.Name .. "_clone"
        local ghostHumanoid = ghostClone:FindFirstChildWhichIsA("Humanoid")
        if ghostHumanoid then
            ghostHumanoid.DisplayName = originalCharacter.Name .. "_clone"
            ghostHumanoid:ChangeState(Enum.HumanoidStateType.Physics)
        end
        if not ghostClone.PrimaryPart then
            local hrp = ghostClone:FindFirstChild("HumanoidRootPart")
            if hrp then ghostClone.PrimaryPart = hrp else warn("Klon HRP nicht gefunden!") end
        end
        for _, part in ipairs(ghostClone:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 1; part.CanCollide = false; part.Anchored = false; part.CanQuery = false
            elseif part:IsA("Decal") then part.Transparency = 1
            elseif part:IsA("Accessory") then
                local handle = part:FindFirstChild("Handle")
                if handle then handle.Transparency = 1; handle.CanCollide = false; handle.CanQuery = false end
            end
        end
        local animate = originalCharacter:FindFirstChild("Animate")
        if animate then originalAnimateScript = animate; originalAnimateScript.Disabled = true; originalAnimateScript.Parent = ghostClone end
        preserveGuis()
        ghostClone.Parent = Workspace
        LocalPlayer.Character = ghostClone
        if ghostHumanoid then Workspace.CurrentCamera.CameraSubject = ghostHumanoid end
        restoreGuis()
        if originalAnimateScript and originalAnimateScript.Parent == ghostClone then originalAnimateScript.Disabled = false end
        ReplicatedStorage.RagdollEvent:FireServer()
        currentCircleAngle = 0
        if updateConnection then updateConnection:Disconnect() end
        updateConnection = RunService.Heartbeat:Connect(updateRagdolledParts)
    else
        if not originalCharacter or not ghostClone then return end
        if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
        for i = 1, 3 do ReplicatedStorage.UnragdollEvent:FireServer(); task.wait(0.1) end
        local targetCFrame = originalCFrame
        local ghostPrimary = ghostClone.PrimaryPart
        if ghostPrimary then targetCFrame = ghostPrimary.CFrame else warn("Klon PrimaryPart nicht gefunden!") end
        local animate = ghostClone:FindFirstChild("Animate")
        if animate then animate.Disabled = true; animate.Parent = originalCharacter end
        ghostClone:Destroy(); ghostClone = nil
        if originalCharacter and originalCharacter.Parent then
            local origRoot = originalCharacter:FindFirstChild("HumanoidRootPart")
            local origHumanoid = originalCharacter:FindFirstChildWhichIsA("Humanoid")
            if origRoot then origRoot.CFrame = targetCFrame; origRoot.AssemblyLinearVelocity = Vector3.zero; origRoot.AssemblyAngularVelocity = Vector3.zero end
            preserveGuis()
            LocalPlayer.Character = originalCharacter
            if origHumanoid then Workspace.CurrentCamera.CameraSubject = origHumanoid; origHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
            restoreGuis()
            if animate and animate.Parent == originalCharacter then task.wait(0.1); animate.Disabled = false end
        else print("Originaler Charakter verloren.") end
        originalCharacter = nil; originalAnimateScript = nil
    end
end


-- *** MODIFIED FUNCTION: createGui ***
local function createGui()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LimborbitGui" -- Changed GUI Name
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Wichtig für Slider-Knopf über Track

    -- Haupt-Frame (größer machen für Slider)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 250, 0, 205) -- Höhe für dritten Slider angepasst
    frame.Position = UDim2.new(0.5, -125, 0.1, 0) -- Zentriert
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    frame.Active = true
    frame.Draggable = false -- Nicht mehr draggable, stattdessen Titelleiste verwenden

    -- Titelleiste zum Ziehen des Fensters
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = frame

    -- Titeltext
    local titleText = Instance.new("TextLabel")
    titleText.Size = UDim2.new(1, -35, 1, 0)
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "Limborbit" -- Changed GUI Title Text
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.Font = Enum.Font.GothamSemibold
    titleText.TextSize = 14
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar

    -- Drag-Funktionalität für die Titelleiste
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then -- Mobile Drag Support
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then -- Mobile Drag Support
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and dragging then -- Mobile Drag Support
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame

    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = titleBar

    -- Enable/Disable Button (unter der Titelleiste)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, -20, 0, 30) -- Höhe angepasst, etwas Platz lassen
    button.Position = UDim2.new(0.5, 0, 0, 40) -- Unter der Titelleiste
    button.AnchorPoint = Vector2.new(0.5, 0)
    button.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    button.Text = "Enable Limborbit" -- Changed Button Text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.GothamSemibold
    button.TextSize = 14
    button.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = button

    -- Close Button (Position relativ zur Titelleiste)
    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 25, 0, 25)
    closeButton.Position = UDim2.new(1, -5, 0.5, 0) -- Rechts in der Titelleiste
    closeButton.AnchorPoint = Vector2.new(1, 0.5)
    closeButton.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 14
    closeButton.Parent = titleBar

    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton

    -- --- Slider Helper Function (Neu implementiert und für Mobile angepasst) ---
    local function createSlider(parent, yPosition, labelText, minValue, maxValue, defaultValue, valueChangedCallback)
        local sliderY = yPosition
        local sliderHeight = 20
        local knobSize = 16
        local currentValue = defaultValue

        -- Container für den gesamten Slider (für bessere Organisation)
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Size = UDim2.new(1, -20, 0, sliderHeight)
        sliderContainer.Position = UDim2.new(0, 10, 0, sliderY)
        sliderContainer.BackgroundTransparency = 1
        sliderContainer.Parent = parent

        -- Label
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0, 60, 0, sliderHeight)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = labelText .. ":"
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.Font = Enum.Font.Gotham
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.TextYAlignment = Enum.TextYAlignment.Center
        label.Parent = sliderContainer

        -- Value Display
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0, 40, 0, sliderHeight)
        valueLabel.Position = UDim2.new(1, 0, 0, 0)
        valueLabel.AnchorPoint = Vector2.new(1, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        valueLabel.Font = Enum.Font.GothamBold
        valueLabel.TextSize = 12
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.TextYAlignment = Enum.TextYAlignment.Center
        valueLabel.Text = string.format("%.2f", defaultValue) -- Display 2 decimal places
        valueLabel.Parent = sliderContainer

        -- Track Container (für bessere Mausinteraktion)
        local trackContainer = Instance.new("Frame")
        trackContainer.Size = UDim2.new(1, -110, 0, sliderHeight)
        trackContainer.Position = UDim2.new(0, 65, 0, 0)
        trackContainer.BackgroundTransparency = 1
        trackContainer.Parent = sliderContainer

        -- Track Frame
        local track = Instance.new("Frame")
        track.Size = UDim2.new(1, 0, 0, 6)
        track.Position = UDim2.new(0, 0, 0.5, 0)
        track.AnchorPoint = Vector2.new(0, 0.5)
        track.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        track.BorderSizePixel = 0
        track.Parent = trackContainer

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Knob Button
        local knob = Instance.new("TextButton")
        knob.Size = UDim2.new(0, knobSize, 0, knobSize)
        knob.AnchorPoint = Vector2.new(0.5, 0.5)
        knob.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
        knob.BorderSizePixel = 0
        knob.Text = ""
        knob.AutoButtonColor = false
        knob.ZIndex = 2
        knob.Parent = trackContainer

        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(1, 0)
        knobCorner.Parent = knob

        -- Funktion zum Aktualisieren der Slider-Anzeige basierend auf dem Wert
        local function updateSliderFromValue(value)
            currentValue = value
            local fraction = (value - minValue) / (maxValue - minValue)
            fraction = math.clamp(fraction, 0, 1)
            knob.Position = UDim2.new(fraction, 0, 0.5, 0)
            valueLabel.Text = string.format("%.2f", value) -- Display 2 decimal places
        end

        -- Funktion zum Aktualisieren des Werts basierend auf der Mausposition
        local function updateValueFromPosition(mouseX)
            local trackAbsPos = trackContainer.AbsolutePosition.X
            local trackAbsSize = trackContainer.AbsoluteSize.X
            local relativeX = mouseX - trackAbsPos
            local fraction = math.clamp(relativeX / trackAbsSize, 0, 1)
            local newValue = minValue + fraction * (maxValue - minValue)
            updateSliderFromValue(newValue)
            valueChangedCallback(newValue)
        end

        -- Mausinteraktionen (Mobile Support hinzugefügt)
        local isDragging = false

        knob.InputBegan:Connect(function(input) -- Mobile Support
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDragging = true
            end
        end)

        trackContainer.InputBegan:Connect(function(input) -- Mobile Support
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDragging = true
                updateValueFromPosition(input.Position.X)
            end
        end)

        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then -- Mobile Support
                isDragging = false
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then -- Mobile Support
                updateValueFromPosition(input.Position.X)
            end
        end)

        -- Initialisierung
        updateSliderFromValue(defaultValue)

        return {
            Container = sliderContainer,
            Track = track,
            Knob = knob,
            Label = label,
            ValueLabel = valueLabel,
            UpdateValue = updateSliderFromValue,
            GetValue = function() return currentValue end
        }
    end
    -- --- End Slider Helper Function ---

    -- Erstelle Radius Slider
    local radiusSliderY = 85 -- Y-Position für den Radius-Slider (unter dem Button)
    local radiusSlider = createSlider(frame, radiusSliderY, "Radius", MIN_RADIUS, MAX_RADIUS, circleRadius, function(newValue)
        circleRadius = newValue -- Aktualisiere die globale Variable
    end)

    -- Erstelle Speed Slider
    local speedSliderY = radiusSliderY + 40 -- Y-Position für den Speed-Slider (unter dem Radius-Slider)
    local speedSlider = createSlider(frame, speedSliderY, "Speed", MIN_SPEED, MAX_SPEED, circleSpeed, function(newValue)
        circleSpeed = newValue -- Aktualisiere die globale Variable
    end)

    -- Erstelle Height Slider
    local heightSliderY = speedSliderY + 40 -- Y-Position für den Height-Slider (unter dem Speed-Slider)
    local heightSlider = createSlider(frame, heightSliderY, "Höhe", MIN_HEIGHT, MAX_HEIGHT, circleVerticalOffset, function(newValue)
        circleVerticalOffset = newValue -- Aktualisiere die globale Variable
    end)

    -- --- Event Connections für Haupt-Buttons ---
    closeButton.MouseButton1Click:Connect(function()
        if ghostEnabled then
            setGhostEnabled(false)
            if button and button.Parent then
                button.Text = "Enable Limborbit" -- Changed Button Text
                button.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
            end
            task.wait(0.5)
        end
        screenGui:Destroy()
    end)

    button.MouseButton1Click:Connect(function()
        local newState = not ghostEnabled
        setGhostEnabled(newState)

        if button and button.Parent then
            if newState then
                button.Text = "Disable Limborbit" -- Changed Button Text
                button.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
            else
                button.Text = "Enable Limborbit" -- Changed Button Text
                button.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
            end
        end
    end)

    return screenGui
end

-- Initialize GUI and Cleanup (unverändert)
local playerGui = LocalPlayer:WaitForChild("PlayerGui")

local existingGui = playerGui:FindFirstChild("LimborbitGui") -- Changed GUI Name Check
if existingGui then
    print("Alte Limborbit GUI gefunden, wird entfernt.")
    existingGui:Destroy()
end

print("Erstelle neue Limborbit GUI mit Slidern.") -- Changed Log Message
local gui = createGui()
gui.Parent = playerGui

script.Destroying:Connect(function()
    print("Limborbit Skript wird zerstört. Räume auf...") -- Changed Log Message
    if ghostEnabled then
        setGhostEnabled(false)
    end
    if gui and gui.Parent then
        gui:Destroy()
    else
        local possiblyExistingGui = playerGui:FindFirstChild("LimborbitGui") -- Changed GUI Name Check
        if possiblyExistingGui then
            possiblyExistingGui:Destroy()
        end
    end
    if updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
    end
    print("Aufräumen abgeschlossen.")
end)

print("Limborbit Skript geladen. Radius und Speed über GUI einstellbar.") -- Changed Log Message


--[[ freecam ]]
--[[
    WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local cam = workspace.CurrentCamera
local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local onMobile = not UIS.KeyboardEnabled
local keysDown = {}
local rotating = false
local touchPos
local toggleActive = true -- Initially enabled
local dragging, dragInput, dragStart, startPos

if not game:IsLoaded() then game.Loaded:Wait() end

-- Freeze the character
if humanoid then
    humanoid.PlatformStand = true -- Prevents the character from falling or moving
    character.HumanoidRootPart.Anchored = true -- Anchor the character's root part
end

cam.CameraType = Enum.CameraType.Scriptable

local speed = 5
local sens = 0.3

speed /= 10
if onMobile then sens *= 2 end

-- Function to control camera
local function renderStepped()
    if not toggleActive then return end -- Stop if toggle is off

    -- Handle camera rotation
    if rotating then
        local delta = UIS:GetMouseDelta()
        local cf = cam.CFrame
        local yAngle = cf:ToEulerAngles(Enum.RotationOrder.YZX)
        local newAmount = math.deg(yAngle) + delta.Y

        if newAmount > 65 or newAmount < -65 then
            if not (yAngle < 0 and delta.Y < 0) and not (yAngle > 0 and delta.Y > 0) then
                delta = Vector2.new(delta.X, 0)
            end
        end

        cf *= CFrame.Angles(-math.rad(delta.Y), 0, 0)
        cf = CFrame.Angles(0, -math.rad(delta.X), 0) * (cf - cf.Position) + cf.Position
        cf = CFrame.lookAt(cf.Position, cf.Position + cf.LookVector)
        if delta ~= Vector2.new(0, 0) then cam.CFrame = cam.CFrame:Lerp(cf, sens) end
        UIS.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
    else
        UIS.MouseBehavior = Enum.MouseBehavior.Default
    end

    -- Handle camera movement
    if keysDown["Enum.KeyCode.W"] then
        cam.CFrame *= CFrame.new(Vector3.new(0, 0, -speed))
    end
    if keysDown["Enum.KeyCode.A"] then
        cam.CFrame *= CFrame.new(Vector3.new(-speed, 0, 0))
    end
    if keysDown["Enum.KeyCode.S"] then
        cam.CFrame *= CFrame.new(Vector3.new(0, 0, speed))
    end
    if keysDown["Enum.KeyCode.D"] then
        cam.CFrame *= CFrame.new(Vector3.new(speed, 0, 0))
    end
end

RS.RenderStepped:Connect(renderStepped)

-- Create GUI for toggle button
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = player:WaitForChild("PlayerGui")

local toggleButton = Instance.new("TextButton")
toggleButton.Parent = screenGui
toggleButton.Size = UDim2.new(0, 100, 0, 40) -- Smaller size
toggleButton.Position = UDim2.new(0.5, -50, 0, 20)
toggleButton.Text = "Freecam On"
toggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Darker background for a sleek look
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text for contrast
toggleButton.Font = Enum.Font.Gotham -- Sleeker, modern font
toggleButton.TextSize = 18 -- Smaller font size
toggleButton.BorderSizePixel = 0

-- Add rounded corners
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 12) -- Rounded corners for a modern look
UICorner.Parent = toggleButton

-- Dragging functionality
local function onDragStarted(input)
    dragging = true
    dragStart = input.Position
    startPos = toggleButton.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function onDragging(input)
    if not dragging then return end

    local delta = input.Position - dragStart
    local newPosition = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
    toggleButton.Position = newPosition
end

toggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        onDragStarted(input)
    end
end)

toggleButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UIS.InputChanged:Connect(function(input)
    if input == dragInput and (dragging) then
        onDragging(input)
    end
end)

-- Toggle functionality
local function resetPlayer()
    -- Reset the character to normal (unfreeze)
    humanoid.PlatformStand = false
    character.HumanoidRootPart.Anchored = false
    cam.CameraType = Enum.CameraType.Custom -- Reset to normal camera
end

local function freezePlayer()
    -- Freeze the character again and apply camera controls
    humanoid.PlatformStand = true
    character.HumanoidRootPart.Anchored = true
    cam.CameraType = Enum.CameraType.Scriptable
end

toggleButton.MouseButton1Click:Connect(function()
    toggleActive = not toggleActive

    if toggleActive then
        toggleButton.Text = "Freecam On"
        freezePlayer() -- Freeze player when camera control is on
        RS.RenderStepped:Connect(renderStepped) -- Re-enable camera control
    else
        toggleButton.Text = "Freecam Off"
        resetPlayer() -- Unfreeze player when camera control is off
        RS.RenderStepped:Disconnect(renderStepped) -- Disable camera control
    end
end)

-- Movement key handling
local validKeys = {"Enum.KeyCode.W", "Enum.KeyCode.A", "Enum.KeyCode.S", "Enum.KeyCode.D"}

UIS.InputBegan:Connect(function(Input)
    if not toggleActive then return end

    for _, key in pairs(validKeys) do
        if key == tostring(Input.KeyCode) then
            keysDown[key] = true
        end
    end

    if Input.UserInputType == Enum.UserInputType.MouseButton2 or (Input.UserInputType == Enum.UserInputType.Touch and UIS:GetMouseLocation().X > (cam.ViewportSize.X / 2)) then
        rotating = true
    end

    if Input.UserInputType == Enum.UserInputType.Touch then
        if Input.Position.X < cam.ViewportSize.X / 2 then
            touchPos = Input.Position
        end
    end
end)

UIS.InputEnded:Connect(function(Input)
    if not toggleActive then return end

    for key, v in pairs(keysDown) do
        if key == tostring(Input.KeyCode) then
            keysDown[key] = false
        end
    end

    if Input.UserInputType == Enum.UserInputType.MouseButton2 or (Input.UserInputType == Enum.UserInputType.Touch and UIS:GetMouseLocation().X > (cam.ViewportSize.X / 2)) then
        rotating = false
    end

    if Input.UserInputType == Enum.UserInputType.Touch and touchPos then
        if Input.Position.X < cam.ViewportSize.X / 2 then
            touchPos = nil
            keysDown["Enum.KeyCode.W"] = false
            keysDown["Enum.KeyCode.A"] = false
            keysDown["Enum.KeyCode.S"] = false
            keysDown["Enum.KeyCode.D"] = false
        end
    end
end)

UIS.TouchMoved:Connect(function(input)
    if not toggleActive then return end

    if touchPos then
        if input.Position.X < cam.ViewportSize.X / 2 then
            if input.Position.Y < touchPos.Y then
                keysDown["Enum.KeyCode.W"] = true
                keysDown["Enum.KeyCode.S"] = false
            else
                keysDown["Enum.KeyCode.W"] = false
                keysDown["Enum.KeyCode.S"] = true
            end
            if input.Position.X < (touchPos.X - 15) then
                keysDown["Enum.KeyCode.A"] = true
                keysDown["Enum.KeyCode.D"] = false
            elseif input.Position.X > (touchPos.X + 15) then
                keysDown["Enum.KeyCode.A"] = false
                keysDown["Enum.KeyCode.D"] = true
            else
                keysDown["Enum.KeyCode.A"] = false
                keysDown["Enum.KeyCode.D"] = false
            end
        end
    end
end)


--[[ fastoof ]]
-- Instant Respawn Script with Countdown GUI
-- Uses Humanoid.Died event and CharacterAdded for reliable position restoration
local player = game.Players.LocalPlayer
local deadPos -- This will store the CFrame VALUE of the HumanoidRootPart
local deadCam -- This will store the CFrame VALUE of the Camera

-- Create a clean countdown GUI
local function createCountdownGUI()
    -- Remove any existing countdown GUI
    local existingGUI = player.PlayerGui:FindFirstChild("RespawnCountdownGUI")
    if existingGUI then
        existingGUI:Destroy()
    end
    
    -- Create new GUI
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "RespawnCountdownGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player.PlayerGui
    
    -- Create the main frame
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 80)
    frame.Position = UDim2.new(0.5, -100, 0.3, 0)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BackgroundTransparency = 0.2
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    
    -- Add corner radius
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = frame
    
    -- Title label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.Position = UDim2.new(0, 0, 0, 5)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.GothamSemibold
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 16
    titleLabel.Text = "Resetting Character"
    titleLabel.Parent = frame
    
    -- Countdown label
    local countdownLabel = Instance.new("TextLabel")
    countdownLabel.Size = UDim2.new(1, 0, 0, 40)
    countdownLabel.Position = UDim2.new(0, 0, 0, 35)
    countdownLabel.BackgroundTransparency = 1
    countdownLabel.Font = Enum.Font.GothamBold
    countdownLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    countdownLabel.TextSize = 20
    countdownLabel.Name = "CountdownLabel"
    countdownLabel.Parent = frame
    
    return screenGui, countdownLabel
end

-- Function to log position on death (from your example code)
local function logPosition()
    local character = player.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            deadPos = hrp.CFrame
            -- Also store camera position
            if workspace.CurrentCamera then
                deadCam = workspace.CurrentCamera.CFrame
            end
        end
    end
end

-- Set up position restoration connection
-- Connecting to Died event to save position
local diedConnection
local function setupDiedConnection()
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- Disconnect existing connection if any
            if diedConnection then
                diedConnection:Disconnect()
            end
            
            -- Connect new died event
            diedConnection = humanoid.Died:Connect(logPosition)
        end
    end
end

-- Set up CharacterAdded connection for teleporting back
local characterAddedConnection = player.CharacterAdded:Connect(function(char)
    -- Set up died connection for the new character
    local humanoid = char:WaitForChild("Humanoid", 3)
    if humanoid then
        diedConnection = humanoid.Died:Connect(logPosition)
    end
    
    -- Teleport to previous position if available
    local hrp = char:WaitForChild("HumanoidRootPart", 3)
    if hrp and deadPos then
        hrp.CFrame = deadPos
        
        -- Set camera back to original position if available
        if workspace.CurrentCamera and deadCam then
            workspace.CurrentCamera.CFrame = deadCam
        end
    end
end)

-- Main function for instant respawn
local function performInstantRespawn()
    -- Store initial position first
    local character = player.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Store initial position
    deadPos = hrp.CFrame
    
    -- Store camera position
    if workspace.CurrentCamera then
        deadCam = workspace.CurrentCamera.CFrame
    end
    
    -- Setup died connection for current character
    setupDiedConnection()
    
    -- Create and show the countdown GUI
    local gui, countdownLabel = createCountdownGUI()
    
    -- Calculate exact same respawn timing as original script
    local respawnTime = game.Players.RespawnTime - 0.165
    
    -- Update countdown in a separate thread to avoid adding delays
    spawn(function()
        local startTime = tick()
        local endTime = startTime + respawnTime
        
        while tick() < endTime and gui and gui.Parent do
            local remaining = math.max(0, math.ceil(endTime - tick()))
            countdownLabel.Text = remaining .. "s"
            wait(0.05) -- Update frequently but don't add significant delay
        end
        
        countdownLabel.Text = "Respawning..."
    end)
    
    -- Use replicatesignal if available (exact same as original)
    if typeof(replicatesignal) == "function" then
        replicatesignal(player.ConnectDiedSignalBackend)
    end
    
    -- Wait the exact same time as original script
    wait(respawnTime)
    
    -- Kill the character using your Health = 0 method
    character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Health = 0 -- Using your method instead of ChangeState
        end
    end
    
    -- Wait a bit to make sure the character died and CharacterAdded will fire
    wait(0.85) -- Slightly longer wait to ensure CharacterAdded handles the teleport
    
    -- Remove the GUI
    if gui and gui.Parent then
        gui:Destroy()
    end
end

-- Run the respawn function
performInstantRespawn()

-- Cleanup function to use when script stops running
local function cleanup()
    if diedConnection then
        diedConnection:Disconnect()
    end
    
    if characterAddedConnection then
        characterAddedConnection:Disconnect()
    end
    
    local gui = player.PlayerGui:FindFirstChild("RespawnCountdownGUI")
    if gui then
        gui:Destroy()
    end
end

-- Optional: Call cleanup() when you want to stop the script


--[[ vccontroller ]]
--[[
    Player Radius Audio Control Script
    Allows players to control who they can hear based on proximity
]]

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Configuration
local CONFIG = {
    DEFAULT_RADIUS = 50,
    MIN_RADIUS = 5,
    MAX_RADIUS = 500,
    PRESET_VALUES = {10, 25, 50, 100, 200},
    COLOR = {
        MAIN_BG = Color3.fromRGB(40, 45, 60),
        SECONDARY_BG = Color3.fromRGB(60, 65, 80),
        ACCENT = Color3.fromRGB(0, 132, 255),
        TEXT = Color3.fromRGB(240, 240, 240),
        ERROR = Color3.fromRGB(255, 80, 80),
        SUCCESS = Color3.fromRGB(80, 230, 80),
        HIGHLIGHT_IN_RANGE = Color3.fromRGB(80, 200, 120),
        HIGHLIGHT_OUT_RANGE = Color3.fromRGB(200, 80, 80)
    }
}

-- State Variables
local state = {
    radiusEnabled = false,
    currentRadius = CONFIG.DEFAULT_RADIUS,
    isDragging = false,
    showingVisualRadius = false,
    visualRadiusPart = nil
}

-- Utility Functions
local Utility = {}

function Utility.getCharacterRoot(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
end

function Utility.createButtonAnimation(button)
    local originalColor = button.BackgroundColor3
    local originalSize = button.Size
    local hoverColor = Color3.new(
        math.min(originalColor.R + 0.1, 1),
        math.min(originalColor.G + 0.1, 1),
        math.min(originalColor.B + 0.1, 1)
    )
    
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = hoverColor
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = originalColor
        }):Play()
    end)
    
    button.MouseButton1Down:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.1), {
            Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset * 0.95, 
                            originalSize.Y.Scale, originalSize.Y.Offset * 0.95)
        }):Play()
    end)
    
    button.MouseButton1Up:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.1), {
            Size = originalSize
        }):Play()
    end)
end

function Utility.showNotification(parent, message, messageType)
    local notifColor = messageType == "error" and CONFIG.COLOR.ERROR or CONFIG.COLOR.SUCCESS
    
    local notification = Instance.new("TextLabel")
    notification.Name = "Notification"
    notification.Size = UDim2.new(0, 200, 0, 30)
    notification.Position = UDim2.new(0.5, -100, 0, -40)
    notification.BackgroundColor3 = notifColor
    notification.TextColor3 = CONFIG.COLOR.TEXT
    notification.TextSize = 14
    notification.Font = Enum.Font.GothamSemibold
    notification.Text = message
    notification.TextWrapped = true
    notification.BackgroundTransparency = 0.2
    notification.AnchorPoint = Vector2.new(0.5, 0)
    notification.Parent = parent
    
    local notifUICorner = Instance.new("UICorner")
    notifUICorner.CornerRadius = UDim.new(0, 6)
    notifUICorner.Parent = notification
    
    TweenService:Create(notification, TweenInfo.new(0.5), {
        Position = UDim2.new(0.5, -100, 0, 10)
    }):Play()
    
    delay(3, function()
        local fadeTween = TweenService:Create(notification, TweenInfo.new(0.5), {
            BackgroundTransparency = 1,
            TextTransparency = 1
        })
        fadeTween:Play()
        fadeTween.Completed:Connect(function()
            notification:Destroy()
        end)
    end)
end

-- Ensure the local character is loaded
if not LocalPlayer.Character or not Utility.getCharacterRoot(LocalPlayer.Character) then
    LocalPlayer.CharacterAdded:Wait()
end

-- Visual Radius Functions
local VisualRadius = {}

function VisualRadius.create()
    if state.visualRadiusPart then
        state.visualRadiusPart:Destroy()
    end
    
    local part = Instance.new("Part")
    part.Name = "RadiusVisualization"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 0.8
    part.Material = Enum.Material.Neon
    part.BrickColor = BrickColor.new("Cyan")
    part.Shape = Enum.PartType.Ball
    part.Size = Vector3.new(state.currentRadius * 2, state.currentRadius * 2, state.currentRadius * 2)
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Name = "RadiusLabel"
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.LightInfluence = 0
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = part
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 0, 36)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 24
    textLabel.Text = "Radius: " .. state.currentRadius
    textLabel.Parent = surfaceGui
    
    part.Parent = workspace
    state.visualRadiusPart = part
    state.showingVisualRadius = true
end

function VisualRadius.update()
    if not state.showingVisualRadius or not state.visualRadiusPart then return end
    
    local character = LocalPlayer.Character
    local rootPart = Utility.getCharacterRoot(character)
    if rootPart then
        state.visualRadiusPart.Position = rootPart.Position
    end
    
    if state.visualRadiusPart.Size.X ~= state.currentRadius * 2 then
        state.visualRadiusPart.Size = Vector3.new(
            state.currentRadius * 2, 
            state.currentRadius * 2, 
            state.currentRadius * 2
        )
        
        local label = state.visualRadiusPart:FindFirstChild("RadiusLabel")
        if label and label:IsA("SurfaceGui") then
            local textLabel = label:FindFirstChildOfClass("TextLabel")
            if textLabel then
                textLabel.Text = "Radius: " .. state.currentRadius
            end
        end
    end
end

function VisualRadius.toggle()
    if state.showingVisualRadius then
        if state.visualRadiusPart then
            state.visualRadiusPart:Destroy()
            state.visualRadiusPart = nil
        end
        state.showingVisualRadius = false
    else
        VisualRadius.create()
    end
    return state.showingVisualRadius
end

-- Highlight Functions
local HighlightManager = {}

function HighlightManager.addHighlight(character, inRange)
    if not character then return end
    
    local hl = character:FindFirstChild("RadiusHighlight")
    if not hl then
        hl = Instance.new("Highlight")
        hl.Name = "RadiusHighlight"
        hl.Parent = character
    end
    
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    
    if inRange then
        hl.FillColor = CONFIG.COLOR.HIGHLIGHT_IN_RANGE
        hl.OutlineColor = CONFIG.COLOR.HIGHLIGHT_IN_RANGE
    else
        hl.FillColor = CONFIG.COLOR.HIGHLIGHT_OUT_RANGE
        hl.OutlineColor = CONFIG.COLOR.HIGHLIGHT_OUT_RANGE
    end
end

function HighlightManager.removeHighlight(character)
    if not character then return end
    
    local hl = character:FindFirstChild("RadiusHighlight")
    if hl then
        hl:Destroy()
    end
end

-- Create GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "RadiusControlGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 320, 0, 220)
MainFrame.Position = UDim2.new(0.5, -160, 0.5, -110)
MainFrame.BackgroundColor3 = CONFIG.COLOR.MAIN_BG
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = MainFrame

-- Title Bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 40)
TitleBar.BackgroundColor3 = CONFIG.COLOR.ACCENT
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 10)
TitleCorner.Parent = TitleBar

local TitleBarBottom = Instance.new("Frame")
TitleBarBottom.Name = "TitleBarBottom"
TitleBarBottom.Size = UDim2.new(1, 0, 0, 10)
TitleBarBottom.Position = UDim2.new(0, 0, 1, -10)
TitleBarBottom.BackgroundColor3 = CONFIG.COLOR.ACCENT
TitleBarBottom.BorderSizePixel = 0
TitleBarBottom.ZIndex = 0
TitleBarBottom.Parent = TitleBar

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Name = "TitleLabel"
TitleLabel.Size = UDim2.new(1, -40, 1, 0)
TitleLabel.Position = UDim2.new(0, 10, 0, 0)
TitleLabel.BackgroundTransparency = 1
TitleLabel.Text = "Radius Audio Controller"
TitleLabel.TextColor3 = CONFIG.COLOR.TEXT
TitleLabel.TextSize = 16
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
TitleLabel.Parent = TitleBar

-- Close button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 30, 0, 30)
CloseButton.Position = UDim2.new(1, -35, 0, 5)
CloseButton.BackgroundColor3 = CONFIG.COLOR.ERROR
CloseButton.Text = "×"
CloseButton.TextSize = 20
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextColor3 = CONFIG.COLOR.TEXT
CloseButton.Parent = TitleBar

local CloseUICorner = Instance.new("UICorner")
CloseUICorner.CornerRadius = UDim.new(0, 6)
CloseUICorner.Parent = CloseButton

-- Main content
local ContentFrame = Instance.new("Frame")
ContentFrame.Name = "ContentFrame"
ContentFrame.Size = UDim2.new(1, -20, 1, -50)
ContentFrame.Position = UDim2.new(0, 10, 0, 45)
ContentFrame.BackgroundTransparency = 1
ContentFrame.Parent = MainFrame

-- Radius control section
local RadiusControlFrame = Instance.new("Frame")
RadiusControlFrame.Name = "RadiusControlFrame"
RadiusControlFrame.Size = UDim2.new(1, 0, 0, 80)
RadiusControlFrame.BackgroundTransparency = 1
RadiusControlFrame.Parent = ContentFrame

local RadiusLabel = Instance.new("TextLabel")
RadiusLabel.Name = "RadiusLabel"
RadiusLabel.Size = UDim2.new(0, 100, 0, 25)
RadiusLabel.BackgroundTransparency = 1
RadiusLabel.Text = "Radius:"
RadiusLabel.TextColor3 = CONFIG.COLOR.TEXT
RadiusLabel.TextSize = 14
RadiusLabel.Font = Enum.Font.GothamSemibold
RadiusLabel.TextXAlignment = Enum.TextXAlignment.Left
RadiusLabel.Parent = RadiusControlFrame

local RadiusInput = Instance.new("TextBox")
RadiusInput.Name = "RadiusInput"
RadiusInput.Size = UDim2.new(0, 100, 0, 30)
RadiusInput.Position = UDim2.new(0, 0, 0, 25)
RadiusInput.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
RadiusInput.Text = tostring(state.currentRadius)
RadiusInput.TextColor3 = CONFIG.COLOR.TEXT
RadiusInput.PlaceholderText = "Enter radius..."
RadiusInput.TextSize = 14
RadiusInput.Font = Enum.Font.Gotham
RadiusInput.ClearTextOnFocus = false
RadiusInput.Parent = RadiusControlFrame

local RadiusInputCorner = Instance.new("UICorner")
RadiusInputCorner.CornerRadius = UDim.new(0, 6)
RadiusInputCorner.Parent = RadiusInput

local PresetFrame = Instance.new("Frame")
PresetFrame.Name = "PresetFrame"
PresetFrame.Size = UDim2.new(0, 170, 0, 60)
PresetFrame.Position = UDim2.new(1, -170, 0, 0)
PresetFrame.BackgroundTransparency = 1
PresetFrame.Parent = RadiusControlFrame

local PresetLabel = Instance.new("TextLabel")
PresetLabel.Name = "PresetLabel"
PresetLabel.Size = UDim2.new(1, 0, 0, 20)
PresetLabel.BackgroundTransparency = 1
PresetLabel.Text = "Preset Values:"
PresetLabel.TextColor3 = CONFIG.COLOR.TEXT
PresetLabel.TextSize = 14
PresetLabel.Font = Enum.Font.GothamSemibold
PresetLabel.TextXAlignment = Enum.TextXAlignment.Left
PresetLabel.Parent = PresetFrame

local PresetButtonsFrame = Instance.new("Frame")
PresetButtonsFrame.Name = "PresetButtonsFrame"
PresetButtonsFrame.Size = UDim2.new(1, 0, 0, 30)
PresetButtonsFrame.Position = UDim2.new(0, 0, 0, 25)
PresetButtonsFrame.BackgroundTransparency = 1
PresetButtonsFrame.Parent = PresetFrame

local buttonWidth = 30
local padding = 5
for i, value in ipairs(CONFIG.PRESET_VALUES) do
    local PresetButton = Instance.new("TextButton")
    PresetButton.Name = "Preset_" .. value
    PresetButton.Size = UDim2.new(0, buttonWidth, 0, buttonWidth)
    PresetButton.Position = UDim2.new(0, (i-1) * (buttonWidth + padding), 0, 0)
    PresetButton.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
    PresetButton.Text = tostring(value)
    PresetButton.TextColor3 = CONFIG.COLOR.TEXT
    PresetButton.TextSize = 12
    PresetButton.Font = Enum.Font.GothamSemibold
    PresetButton.Parent = PresetButtonsFrame
    
    local PresetButtonCorner = Instance.new("UICorner")
    PresetButtonCorner.CornerRadius = UDim.new(0, 4)
    PresetButtonCorner.Parent = PresetButton
    
    Utility.createButtonAnimation(PresetButton)
    
    PresetButton.MouseButton1Click:Connect(function()
        state.currentRadius = value
        RadiusInput.Text = tostring(value)
    end)
end

local ControlsFrame = Instance.new("Frame")
ControlsFrame.Name = "ControlsFrame"
ControlsFrame.Size = UDim2.new(1, 0, 0, 85)
ControlsFrame.Position = UDim2.new(0, 0, 0, 90)
ControlsFrame.BackgroundTransparency = 1
ControlsFrame.Parent = ContentFrame

local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleButton"
ToggleButton.Size = UDim2.new(0, 140, 0, 35)
ToggleButton.Position = UDim2.new(0, 0, 0, 0)
ToggleButton.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
ToggleButton.Text = "Enable Radius Audio"
ToggleButton.TextColor3 = CONFIG.COLOR.TEXT
ToggleButton.TextSize = 14
ToggleButton.Font = Enum.Font.GothamSemibold
ToggleButton.Parent = ControlsFrame

local ToggleUICorner = Instance.new("UICorner")
ToggleUICorner.CornerRadius = UDim.new(0, 6)
ToggleUICorner.Parent = ToggleButton

local VisualizeButton = Instance.new("TextButton")
VisualizeButton.Name = "VisualizeButton"
VisualizeButton.Size = UDim2.new(0, 140, 0, 35)
VisualizeButton.Position = UDim2.new(1, -140, 0, 0)
VisualizeButton.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
VisualizeButton.Text = "Show Radius Sphere"
VisualizeButton.TextColor3 = CONFIG.COLOR.TEXT
VisualizeButton.TextSize = 14
VisualizeButton.Font = Enum.Font.GothamSemibold
VisualizeButton.Parent = ControlsFrame

local VisualizeUICorner = Instance.new("UICorner")
VisualizeUICorner.CornerRadius = UDim.new(0, 6)
VisualizeUICorner.Parent = VisualizeButton

local StatusFrame = Instance.new("Frame")
StatusFrame.Name = "StatusFrame"
StatusFrame.Size = UDim2.new(1, 0, 0, 35)
StatusFrame.Position = UDim2.new(0, 0, 0, 45)
StatusFrame.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
StatusFrame.Parent = ControlsFrame

local StatusUICorner = Instance.new("UICorner")
StatusUICorner.CornerRadius = UDim.new(0, 6)
StatusUICorner.Parent = StatusFrame

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Name = "StatusLabel"
StatusLabel.Size = UDim2.new(1, -10, 1, 0)
StatusLabel.Position = UDim2.new(0, 5, 0, 0)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Text = "Status: Disabled"
StatusLabel.TextColor3 = CONFIG.COLOR.TEXT
StatusLabel.TextSize = 14
StatusLabel.Font = Enum.Font.GothamSemibold
StatusLabel.TextXAlignment = Enum.TextXAlignment.Left
StatusLabel.Parent = StatusFrame

Utility.createButtonAnimation(ToggleButton)
Utility.createButtonAnimation(VisualizeButton)
Utility.createButtonAnimation(CloseButton)

-- GUI Functionality

ToggleButton.MouseButton1Click:Connect(function()
    state.radiusEnabled = not state.radiusEnabled
    
    if state.radiusEnabled then
        ToggleButton.Text = "Disable Radius Audio"
        ToggleButton.BackgroundColor3 = CONFIG.COLOR.SUCCESS
        StatusLabel.Text = "Status: Enabled - Radius: " .. state.currentRadius
    else
        ToggleButton.Text = "Enable Radius Audio"
        ToggleButton.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
        StatusLabel.Text = "Status: Disabled"
        
        for _, player in pairs(Players:GetPlayers()) do
            local audio = player:FindFirstChild("AudioDeviceInput")
            if audio then
                audio.Muted = false
            end
            if player.Character then
                HighlightManager.removeHighlight(player.Character)
            end
        end
    end
end)

VisualizeButton.MouseButton1Click:Connect(function()
    local isShowing = VisualRadius.toggle()
    
    if isShowing then
        VisualizeButton.Text = "Hide Radius Sphere"
        VisualizeButton.BackgroundColor3 = CONFIG.COLOR.ACCENT
    else
        VisualizeButton.Text = "Show Radius Sphere"
        VisualizeButton.BackgroundColor3 = CONFIG.COLOR.SECONDARY_BG
    end
end)

RadiusInput.FocusLost:Connect(function(enterPressed)
    local num = tonumber(RadiusInput.Text)
    if num then
        if num < CONFIG.MIN_RADIUS then
            num = CONFIG.MIN_RADIUS
            Utility.showNotification(ScreenGui, "Minimum radius is " .. CONFIG.MIN_RADIUS, "error")
        elseif num > CONFIG.MAX_RADIUS then
            num = CONFIG.MAX_RADIUS
            Utility.showNotification(ScreenGui, "Maximum radius is " .. CONFIG.MAX_RADIUS, "error")
        end
        
        state.currentRadius = num
        RadiusInput.Text = tostring(num)
        
        if state.radiusEnabled then
            StatusLabel.Text = "Status: Enabled - Radius: " .. state.currentRadius
        end
        
        Utility.showNotification(ScreenGui, "Radius set to " .. num, "success")
    else
        RadiusInput.Text = tostring(state.currentRadius)
        Utility.showNotification(ScreenGui, "Please enter a valid number", "error")
    end
end)

CloseButton.MouseButton1Click:Connect(function()
    state.radiusEnabled = false
    
    for _, player in pairs(Players:GetPlayers()) do
        local audio = player:FindFirstChild("AudioDeviceInput")
        if audio then
            audio.Muted = false
        end
        if player.Character then
            HighlightManager.removeHighlight(player.Character)
        end
    end
    
    if state.visualRadiusPart then
        state.visualRadiusPart:Destroy()
    end
    
    ScreenGui:Destroy()
end)

-- Drag & Drop functionality (supports all devices)
local dragInput, dragStart, startPos

local function updateDrag(input)
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(
        startPos.X.Scale, startPos.X.Offset + delta.X,
        startPos.Y.Scale, startPos.Y.Offset + delta.Y
    )
end

TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        state.isDragging = true
        dragStart = input.Position
        startPos = MainFrame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                state.isDragging = false
            end
        end)
    end
end)

TitleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if state.isDragging and input == dragInput then
        updateDrag(input)
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.F4 then
        ScreenGui.Enabled = not ScreenGui.Enabled
    end
end)

-- Helper function to update a new player's character
local function onCharacterAdded(player, character)
    character:WaitForChild("HumanoidRootPart")
    if state.radiusEnabled and LocalPlayer.Character then
        local localRoot = Utility.getCharacterRoot(LocalPlayer.Character)
        local targetRoot = Utility.getCharacterRoot(character)
        if localRoot and targetRoot then
            local distance = (targetRoot.Position - localRoot.Position).Magnitude
            local inRange = distance <= state.currentRadius
            local audio = player:FindFirstChild("AudioDeviceInput")
            if audio then
                audio.Muted = not inRange
            end
            HighlightManager.addHighlight(character, inRange)
        end
    end
end

-- Handle new players joining
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        onCharacterAdded(player, character)
    end)
    if player.Character then
        onCharacterAdded(player, player.Character)
    end
end)

-- Main update loop
RunService.Heartbeat:Connect(function()
    if state.radiusEnabled and LocalPlayer.Character then
        local localRoot = Utility.getCharacterRoot(LocalPlayer.Character)
        if not localRoot then return end
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = Utility.getCharacterRoot(player.Character)
                if targetRoot then
                    local distance = (targetRoot.Position - localRoot.Position).Magnitude
                    local inRange = distance <= state.currentRadius
                    
                    local audio = player:FindFirstChild("AudioDeviceInput")
                    if audio then
                        audio.Muted = not inRange
                    end
                    
                    if state.radiusEnabled then
                        HighlightManager.addHighlight(player.Character, inRange)
                    end
                end
            end
        end
    end
    VisualRadius.update()
end)

Utility.showNotification(ScreenGui, "Radius Audio Controller loaded", "success")


--[[ loopclearchat ]]
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local function chatMessage(str)
	str = tostring(str)
	if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
		local generalChannel = TextChatService:FindFirstChild("TextChannels"):FindFirstChild("RBXGeneral")
		if generalChannel then
			generalChannel:SendAsync(str)
		else
			warn("RBXGeneral channel not found!")
		end
	else
		local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest")
		if chatEvent then
			chatEvent:FireServer(str, "All")
		else
			warn("DefaultChatSystemChatEvents not found!")
		end
	end
end

local blob = "\u{000D}"
local clearMessage = "" .. string.rep(blob, 197) .. ""

-- UI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ClearChatGUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local toggleButton = Instance.new("TextButton")
toggleButton.Name = "ClearChatToggle"
toggleButton.Size = UDim2.new(0, 50, 0, 50)
toggleButton.Position = UDim2.new(1, -60, 0.5, -25) -- Middle-Right
toggleButton.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
toggleButton.BackgroundTransparency = 0.5
toggleButton.BorderColor3 = Color3.fromRGB(80, 80, 80)
toggleButton.BorderSizePixel = 2
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 28
toggleButton.Parent = screenGui
toggleButton.Draggable = true
toggleButton.AutoButtonColor = false
toggleButton.Text = "🗑️"

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0.5, 0)
corner.Parent = toggleButton

local dragging = false
local offset

local function dragStart(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Mouse or inputObject.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		offset = Vector2.new(toggleButton.AbsolutePosition.X - inputObject.Position.X, toggleButton.AbsolutePosition.Y - inputObject.Position.Y)
		inputObject.Changed:Connect(function()
			if not dragging then return end
			toggleButton.Position = UDim2.new(0, inputObject.Position.X + offset.X, 0, inputObject.Position.Y + offset.Y)
		end)
	end
end

local function dragEnd(inputObject)
	dragging = false
end

toggleButton.InputBegan:Connect(dragStart)
toggleButton.InputEnded:Connect(dragEnd)

-- Variables for the message loop
local isClearing = false
local messageLoopThread = nil

-- Function that continuously sends the clear message every 4 seconds.
local function messageLoop()
	while isClearing do
		chatMessage(clearMessage)
		-- Wait exactly 4 seconds before sending the next message.
		wait(4)
	end
end

-- Function to toggle the loop on and off.
local function toggleMessageLoop()
	isClearing = not isClearing

	if isClearing then
		-- Change the button appearance to indicate "active"
		toggleButton.BackgroundColor3 = Color3.fromRGB(0, 180, 0)
		toggleButton.BackgroundTransparency = 0.3
		-- Start the message loop as a coroutine
		messageLoopThread = coroutine.wrap(messageLoop)
		messageLoopThread()
	else
		-- Change the button appearance back to "inactive"
		toggleButton.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
		toggleButton.BackgroundTransparency = 0.5
	end

	-- Button rotation animation for visual feedback.
	local tweenInfo = TweenInfo.new(
		0.3,
		Enum.EasingStyle.Quad,
		Enum.EasingDirection.Out,
		0,
		false
	)
	local tween = TweenService:Create(toggleButton, tweenInfo, {Rotation = toggleButton.Rotation + 360})
	tween:Play()
end

toggleButton.MouseButton1Click:Connect(toggleMessageLoop)


--[[ antiheadsit ]]
-- Made by AnthonyIsntHere
-- Modified with simplified head radius detection

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Player = Players.LocalPlayer
local Character, Humanoid, RootPart, Head
local Camera = workspace.CurrentCamera
local IsVoiding = false
local IsEnabled = true

-- Create GUI elements for mobile
local function CreateMobileButton()
    local gui = Instance.new("ScreenGui")
    gui.Name = "VoidProtectionGUI"
    gui.ResetOnSpawn = false
    
    local button = Instance.new("TextButton")
    button.Name = "ToggleButton"
    button.Size = UDim2.new(0, 45, 0, 45)
    button.Position = UDim2.new(0, 20, 1, -70)
    button.AnchorPoint = Vector2.new(0, 1)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.1
    button.Text = "ON"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 14
    button.Font = Enum.Font.GothamBold
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Transparency = 0.8
    stroke.Thickness = 1
    stroke.Parent = button
    
    button.Parent = gui
    gui.Parent = Player:WaitForChild("PlayerGui")
    
    button.MouseButton1Click:Connect(function()
        IsEnabled = not IsEnabled
        button.Text = IsEnabled and "ON" or "OFF"
        button.BackgroundColor3 = IsEnabled and Color3.fromRGB(30, 30, 30) or Color3.fromRGB(180, 40, 40)
    end)
    
    return button
end

-- Simplified head-sitting detection with radius check
local function IsPlayerSittingOnHead()
    if Head then
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= Player then
                local otherCharacter = otherPlayer.Character
                if not otherCharacter then continue end
                
                local otherHumanoid = otherCharacter:FindFirstChildWhichIsA("Humanoid")
                if not otherHumanoid then continue end
                
                -- Only check if they're seated
                if otherHumanoid:GetState() ~= Enum.HumanoidStateType.Seated then continue end
                
                local otherRoot = otherCharacter:FindFirstChild("HumanoidRootPart")
                if not otherRoot then continue end
                
                -- Check if they're within radius of head/upper torso area
                local distance = (otherRoot.Position - Head.Position).Magnitude
                if distance <= 3.5 then  -- Radius check
                    return otherPlayer
                end
            end
        end
    end
    return nil
end

-- Bang animation detection
local function IsUsingBangAnimation()
    if RootPart then
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= Player then
                local otherCharacter = otherPlayer.Character
                local otherHumanoid = otherCharacter and otherCharacter:FindFirstChildWhichIsA("Humanoid")
                local otherRootPart = otherHumanoid and otherHumanoid.RootPart

                if otherRootPart and (RootPart.Position - otherRootPart.Position).Magnitude < 2 then
                    for _, animTrack in ipairs(otherHumanoid:GetPlayingAnimationTracks()) do
                        if animTrack.Animation and (animTrack.Animation.AnimationId:match("148840371") or animTrack.Animation.AnimationId:match("5918726674")) then
                            return otherPlayer
                        end
                    end
                end
            end
        end
    end
    return nil
end

-- Bypass the void limit
workspace.FallenPartsDestroyHeight = 0/0

-- Void teleport function
local function VoidTeleport()
    workspace.Camera.CameraType = Enum.CameraType.Fixed
    
    local HRoot = game:GetService("Players").LocalPlayer.Character.Humanoid.RootPart
    local Pos = HRoot.CFrame
    
    HRoot.CFrame = Pos + Vector3.new(0, -1e3, 0)
    task.wait(0.1)
    HRoot.CFrame = Pos
    
    workspace.Camera.CameraType = Enum.CameraType.Custom
end

-- Create mobile button
local mobileButton = CreateMobileButton()

-- Setup keyboard toggle
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.N then
        IsEnabled = not IsEnabled
        mobileButton.Text = IsEnabled and "ON" or "OFF"
        mobileButton.BackgroundColor3 = IsEnabled and Color3.fromRGB(30, 30, 30) or Color3.fromRGB(180, 40, 40)
    end
end)

-- Main protection loop
while true do
    if IsEnabled then
        Character = Player.Character
        if Character then
            Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
            RootPart = Character:FindFirstChild("HumanoidRootPart")
            Head = Character:FindFirstChild("Head")
            
            local sittingPlayer = IsPlayerSittingOnHead()
            local bangPlayer = IsUsingBangAnimation()
            
            if (sittingPlayer or bangPlayer) and not IsVoiding then
                IsVoiding = true
                local offender = sittingPlayer or bangPlayer
                
                -- Kill the offender
                if offender and offender.Character then
                    local offenderHumanoid = offender.Character:FindFirstChildWhichIsA("Humanoid")
                    if offenderHumanoid then
                        offenderHumanoid.Health = 0
                    end
                end
                
                -- Immediate void teleport
                VoidTeleport()
                IsVoiding = false
            end
        end
    end
    
    task.wait(0.1)
end


--[[ revc ]]
game:GetService("VoiceChatService"):joinVoice()



--[[ hug ]]
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ANIMATION_IDS = {
    R6 = {
        "rbxassetid://225975820",
        "rbxassetid://283545583"
    },
    R15 = {
        "rbxassetid://6082224617",
        "rbxassetid://4940563117"
    }
}

local State = {
    isHugging = false,
    animations = {},
    defaultGravity = workspace.Gravity
}

local function setupAnimations()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    local animationIds = humanoid.RigType == Enum.HumanoidRigType.R15 and ANIMATION_IDS.R15 or ANIMATION_IDS.R6
    
    for _, anim in pairs(State.animations) do
        if anim.AnimationTrack then
            anim.AnimationTrack:Stop()
            anim.AnimationTrack:Destroy()
        end
    end
    
    State.animations = {}
    
    for _, id in ipairs(animationIds) do
        local animation = Instance.new("Animation")
        animation.AnimationId = id
        local animationTrack = humanoid:LoadAnimation(animation)
        
        -- Add TimePosition changed callback for R15
        if humanoid.RigType == Enum.HumanoidRigType.R15 then
            animationTrack.TimePosition = 0
            task.delay(0.3, function()
                if animationTrack.IsPlaying then
                    animationTrack:AdjustSpeed(0)
                end
            end)
        end
        
        table.insert(State.animations, {
            Animation = animation,
            AnimationTrack = animationTrack
        })
    end
end

local function findNearestPlayer()
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    local nearestPlayer = nil
    local minDistance = math.huge
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local targetCharacter = player.Character
            if targetCharacter then
                local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local distance = (rootPart.Position - targetRoot.Position).Magnitude
                    if distance < minDistance then
                        minDistance = distance
                        nearestPlayer = player
                    end
                end
            end
        end
    end
    
    return nearestPlayer
end

local function attachToTarget(rootPart, targetRootPart)
    local attachment = Instance.new("Attachment")
    attachment.Parent = rootPart
    
    local targetAttachment = Instance.new("Attachment")
    targetAttachment.CFrame = CFrame.new(0, 0, 1)
    targetAttachment.Parent = targetRootPart
    
    local alignPosition = Instance.new("AlignPosition")
    alignPosition.Attachment0 = attachment
    alignPosition.Attachment1 = targetAttachment
    alignPosition.MaxForce = 100000
    alignPosition.MaxVelocity = 500
    alignPosition.Responsiveness = 200
    alignPosition.Parent = rootPart
    
    local alignOrientation = Instance.new("AlignOrientation")
    alignOrientation.Attachment0 = attachment
    alignOrientation.Attachment1 = targetAttachment
    alignOrientation.MaxTorque = 100000
    alignOrientation.Responsiveness = 200
    alignOrientation.Parent = rootPart
end

local function cleanupAttachments()
    local character = LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    for _, child in ipairs(rootPart:GetChildren()) do
        if child:IsA("Attachment") or child:IsA("AlignPosition") or child:IsA("AlignOrientation") then
            child:Destroy()
        end
    end
end

local function toggleHug()
    State.isHugging = not State.isHugging
    
    if State.isHugging then
        workspace.Gravity = 0
        local target = findNearestPlayer()
        
        if target and target.Character then
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local targetRootPart = target.Character:FindFirstChild("HumanoidRootPart")
                
                if rootPart and targetRootPart then
                    setupAnimations()
                    for _, anim in pairs(State.animations) do
                        if anim.AnimationTrack then
                            anim.AnimationTrack:Play()
                        end
                    end
                    attachToTarget(rootPart, targetRootPart)
                end
            end
        end
    else
        workspace.Gravity = State.defaultGravity
        for _, anim in pairs(State.animations) do
            if anim.AnimationTrack then
                anim.AnimationTrack:Stop()
                anim.AnimationTrack:AdjustSpeed(1) -- Reset animation speed
            end
        end
        cleanupAttachments()
    end
end

local function setupInput()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.H then
            toggleHug()
        end
    end)
    
    if UserInputService.TouchEnabled then
        local screenGui = Instance.new("ScreenGui")
        screenGui.ResetOnSpawn = false
        screenGui.DisplayOrder = 999
        screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
        
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 60, 0, 60)
        button.Position = UDim2.new(0.95, -70, 0.2, 0)
        button.BackgroundColor3 = Color3.fromRGB(255, 182, 193)
        button.Text = "🤗"
        button.TextSize = 30
        button.Font = Enum.Font.GothamBold
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.AutoButtonColor = false
        button.Parent = screenGui
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = button
        
        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 182, 193)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 192, 203))
        })
        gradient.Rotation = 45
        gradient.Parent = button
        
        local function createTween(properties)
            return TweenService:Create(button, TweenInfo.new(0.3), properties)
        end
        
        button.MouseButton1Click:Connect(toggleHug)
        button.MouseEnter:Connect(function()
            createTween({Size = UDim2.new(0, 66, 0, 66)}):Play()
        end)
        button.MouseLeave:Connect(function()
            createTween({Size = UDim2.new(0, 60, 0, 60)}):Play()
        end)
    end
end

setupInput()


--[[ bodysnake ]]
-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- Configuration

-- Body parts to potentially offset and sync (All enabled by default)
local bodyParts = {
    "Head", "UpperTorso", "LowerTorso",
    "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot",
    "HumanoidRootPart" -- Used as reference, not part of the visible snake
}

-- Snake Configuration: Order of body parts in the snake
-- HumanoidRootPart is implicitly the leader, the snake starts visually with Head
local snakeOrder = {
    "Head",
    "UpperTorso",
    "LowerTorso",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand",
    "LeftUpperLeg",
    "LeftLowerLeg",
    "LeftFoot",
    "RightUpperLeg",
    "RightLowerLeg",
    "RightFoot"
}

-- Snake Configuration
local snakeDistance = 1.0       -- Default Abstand zwischen den Teilen (Studs)
local snakeSmoothing = 0.1      -- FIXED Glättungsfaktor (0-1, höher = glatter) - No longer user-adjustable

-- Slider Configuration
local MIN_DISTANCE = 0.2
local MAX_DISTANCE = 5.0
-- Removed Smoothing and Vertical sliders/constants

-- Swing mode state (global for access in all functions)
swingEnabled = true

-- State variables
local ghostEnabled = false
local originalCharacter
local ghostClone
local originalCFrame
local originalAnimateScript
local updateConnection
local renderStepConnection
local previousPositions = {}
local targetPositions = {}
local lastUpdateTime = 0

-- GUI preservation functions (Unchanged)
local preservedGuis = {}
local function preserveGuis()
    local playerGui = LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
    if playerGui then
        for _, gui in ipairs(playerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name ~= "SnakeReanimationGui" and gui.ResetOnSpawn then
                table.insert(preservedGuis, gui)
                gui.ResetOnSpawn = false
            end
        end
    end
end
local function restoreGuis()
    for _, gui in ipairs(preservedGuis) do
        if gui and gui.Parent then
            gui.ResetOnSpawn = true
        end
    end
    table.clear(preservedGuis)
end

-- Update Snake Parts (optimized for smooth snake-like movement)
local pathHistory = {}
local maxPathLength = 3000 -- enough for long snakes and delays

local function updateSnakeParts(dt)
    if not ghostEnabled or not originalCharacter or not originalCharacter.Parent or not ghostClone or not ghostClone.Parent then
        if updateConnection then
            updateConnection:Disconnect()
            updateConnection = nil
        end
        if renderStepConnection then
            renderStepConnection:Disconnect()
            renderStepConnection = nil
        end
        return
    end

    local currentTime = tick()
    local actualDt = currentTime - lastUpdateTime
    lastUpdateTime = currentTime

    local rootPart = ghostClone:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    if not targetPositions then targetPositions = {} end
    if not previousPositions then previousPositions = {} end

    -- All parts from snakeOrder are now active
    local activeSnakeParts = snakeOrder

    if #activeSnakeParts == 0 then return end

    local isMoving = rootPart.AssemblyLinearVelocity.Magnitude > 0.1

    -- Path recording for "route-follow" mode
    if not pathHistory then pathHistory = {} end
    table.insert(pathHistory, 1, {pos = rootPart.Position, rot = rootPart.CFrame - rootPart.Position})
    if #pathHistory > maxPathLength then
        table.remove(pathHistory)
    end

    if swingEnabled then
        -- Default "Swing" mode (as before)
        local firstPartName = activeSnakeParts[1]
        local firstPart = originalCharacter:FindFirstChild(firstPartName)

        if firstPart then
            if not targetPositions[firstPartName] then targetPositions[firstPartName] = firstPart.CFrame end
            if not previousPositions[firstPartName] then previousPositions[firstPartName] = firstPart.CFrame end

            if isMoving then
                local targetPosition = rootPart.Position
                local targetRotation = rootPart.CFrame - rootPart.Position
                local targetCFrame = CFrame.new(targetPosition) * targetRotation
                targetPositions[firstPartName] = targetCFrame
            end

            local smoothCFrame = previousPositions[firstPartName]:Lerp(targetPositions[firstPartName], snakeSmoothing)
            firstPart.CFrame = smoothCFrame
            firstPart.AssemblyLinearVelocity = Vector3.zero
            firstPart.AssemblyAngularVelocity = Vector3.zero
            previousPositions[firstPartName] = smoothCFrame

            for i = 2, #activeSnakeParts do
                local partName = activeSnakeParts[i]
                local currentPart = originalCharacter:FindFirstChild(partName)
                local previousPartName = activeSnakeParts[i-1]
                local previousPart = originalCharacter:FindFirstChild(previousPartName)

                if currentPart and previousPart then
                    if not targetPositions[partName] then targetPositions[partName] = currentPart.CFrame end
                    if not previousPositions[partName] then previousPositions[partName] = currentPart.CFrame end

                    if isMoving then
                        local prevPartPos = previousPart.Position
                        local prevPartRot = previousPart.CFrame - previousPart.Position
                        local directionVector

                        if i == 2 then
                            directionVector = (prevPartPos - rootPart.Position).Unit
                        else
                            local beforePreviousPart = originalCharacter:FindFirstChild(activeSnakeParts[i-2])
                            if beforePreviousPart then
                                directionVector = (prevPartPos - beforePreviousPart.Position).Unit
                            else
                                directionVector = prevPartRot.LookVector
                            end
                        end

                        if directionVector.Magnitude < 0.1 then
                            directionVector = prevPartRot.LookVector
                        end

                        local targetPosition = prevPartPos + directionVector * snakeDistance
                        local targetRotation = prevPartRot
                        local targetCFrame = CFrame.new(targetPosition) * targetRotation
                        targetPositions[partName] = targetCFrame
                    end

                    local smoothCFrame = previousPositions[partName]:Lerp(targetPositions[partName], snakeSmoothing)
                    currentPart.CFrame = smoothCFrame
                    currentPart.AssemblyLinearVelocity = Vector3.zero
                    currentPart.AssemblyAngularVelocity = Vector3.zero
                    previousPositions[partName] = smoothCFrame
                end
            end
        end
    else
        -- "Route-follow" mode: all parts follow the exact path of the root, spaced by snakeDistance
        -- Build a cumulative distance array along the path
        local pathLen = #pathHistory
        local cumDist = {}
        cumDist[1] = 0
        for j = 2, pathLen do
            cumDist[j] = cumDist[j-1] + (pathHistory[j-1].pos - pathHistory[j].pos).Magnitude
        end

        for i = 1, #activeSnakeParts do
            local partName = activeSnakeParts[i]
            local currentPart = originalCharacter:FindFirstChild(partName)
            if currentPart then
                -- Each part should be offset by (i-1)*snakeDistance along the path
                local desiredDist = (i-1) * snakeDistance
                -- Find the two path points between which this distance falls
                local idx = nil
                for j = 2, pathLen do
                    if cumDist[j] >= desiredDist then
                        idx = j
                        break
                    end
                end
                if idx and pathHistory[idx] and pathHistory[idx-1] then
                    local d1 = cumDist[idx-1]
                    local d2 = cumDist[idx]
                    local alpha = (desiredDist - d1) / math.max(1e-6, d2 - d1)
                    local pos1 = pathHistory[idx-1].pos
                    local pos2 = pathHistory[idx].pos
                    local rot1 = pathHistory[idx-1].rot
                    local rot2 = pathHistory[idx].rot
                    local interpPos = pos1:Lerp(pos2, alpha)
                    -- For rotation, just use the earlier one for simplicity
                    local interpRot = rot1
                    local targetCFrame = CFrame.new(interpPos) * interpRot
                    if not previousPositions[partName] then previousPositions[partName] = currentPart.CFrame end
                    if not targetPositions[partName] then targetPositions[partName] = currentPart.CFrame end
                    targetPositions[partName] = targetCFrame
                    local smoothCFrame = previousPositions[partName]:Lerp(targetPositions[partName], snakeSmoothing)
                    currentPart.CFrame = smoothCFrame
                    currentPart.AssemblyLinearVelocity = Vector3.zero
                    currentPart.AssemblyAngularVelocity = Vector3.zero
                    previousPositions[partName] = smoothCFrame
                else
                    -- Not enough path history, space out at current root position
                    local rootCFrame = rootPart.CFrame
                    local offset = rootCFrame.LookVector * (-(i-1) * snakeDistance)
                    local spacedCFrame = rootCFrame + offset
                    currentPart.CFrame = spacedCFrame
                    previousPositions[partName] = spacedCFrame
                end
            end
        end
    end
end

-- Toggle ghost mode (Unchanged Core Logic, just initialization/cleanup references fixed)
local function setGhostEnabled(newState)
    ghostEnabled = newState

    if ghostEnabled then
        local char = LocalPlayer.Character
        if not char then return end
        local humanoid = char:FindFirstChildWhichIsA("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if not humanoid or not root then return end
        if originalCharacter or ghostClone then return end -- Already enabled

        originalCharacter = char
        originalCFrame = root.CFrame
        char.Archivable = true
        ghostClone = char:Clone()
        char.Archivable = false
        ghostClone.Name = originalCharacter.Name .. "_clone"
        local ghostHumanoid = ghostClone:FindFirstChildWhichIsA("Humanoid")
        if ghostHumanoid then
            ghostHumanoid.DisplayName = originalCharacter.Name .. "_clone"
            ghostHumanoid:ChangeState(Enum.HumanoidStateType.Physics) -- Ensures it follows physics
        end
        if not ghostClone.PrimaryPart then
            local hrp = ghostClone:FindFirstChild("HumanoidRootPart")
            if hrp then ghostClone.PrimaryPart = hrp else warn("Clone HRP not found!") end
        end
        for _, part in ipairs(ghostClone:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 1; part.CanCollide = false; part.Anchored = false; part.CanQuery = false
            elseif part:IsA("Decal") then part.Transparency = 1
            elseif part:IsA("Accessory") then
                local handle = part:FindFirstChild("Handle")
                if handle then handle.Transparency = 1; handle.CanCollide = false; handle.CanQuery = false end
            end
        end
        local animate = originalCharacter:FindFirstChild("Animate")
        if animate then originalAnimateScript = animate; originalAnimateScript.Disabled = true; originalAnimateScript.Parent = ghostClone end
        preserveGuis()
        ghostClone.Parent = Workspace
        LocalPlayer.Character = ghostClone
        if ghostHumanoid then Workspace.CurrentCamera.CameraSubject = ghostHumanoid end
        restoreGuis()
        if originalAnimateScript and originalAnimateScript.Parent == ghostClone then originalAnimateScript.Disabled = false end
        ReplicatedStorage.RagdollEvent:FireServer() -- Assuming this event handles ragdoll physics/state on the server

        -- Initialize positions
        targetPositions = {}
        previousPositions = {}
        lastUpdateTime = tick()

        -- Disconnect existing connections if any
        if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
        if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end

        -- Use Heartbeat for physics-related updates
        updateConnection = RunService.Heartbeat:Connect(updateSnakeParts)
        -- RenderStepped connection removed as Heartbeat should suffice and simplifies logic

    else -- Disabling
        if not originalCharacter or not ghostClone then return end -- Already disabled or in weird state
        if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
        if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end -- Just in case

        ReplicatedStorage.UnragdollEvent:FireServer() -- Assuming this reverses the server-side ragdoll state

        local targetCFrame = originalCFrame
        local ghostPrimary = ghostClone.PrimaryPart
        if ghostPrimary then targetCFrame = ghostPrimary.CFrame else warn("Clone PrimaryPart not found for CFrame!") end

        local animate = ghostClone:FindFirstChild("Animate")
        if animate then animate.Disabled = true; animate.Parent = originalCharacter end -- Move Animate script back

        ghostClone:Destroy(); ghostClone = nil -- Destroy the clone

        if originalCharacter and originalCharacter.Parent then
            local origRoot = originalCharacter:FindFirstChild("HumanoidRootPart")
            local origHumanoid = originalCharacter:FindFirstChildWhichIsA("Humanoid")

            if origRoot then
                 origRoot.CFrame = targetCFrame -- Restore position
                 origRoot.AssemblyLinearVelocity = Vector3.zero -- Stop movement
                 origRoot.AssemblyAngularVelocity = Vector3.zero
            end
            preserveGuis()
            LocalPlayer.Character = originalCharacter -- Assign control back
            if origHumanoid then
                 Workspace.CurrentCamera.CameraSubject = origHumanoid -- Restore camera
                 origHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp) -- Trigger get up animation
            end
            restoreGuis()
            if animate and animate.Parent == originalCharacter then task.wait(0.1); animate.Disabled = false end -- Re-enable Animate script
        else
            print("Original character lost during disable.")
        end
        originalCharacter = nil; originalAnimateScript = nil
    end
end

-- Create GUI (Modified for black theme with transparency)
local function createGui()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SnakeReanimationGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    -- Main Frame (Smaller)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 260, 0, 140) -- Reduced Height
    frame.Position = UDim2.new(0.5, -130, 0.1, 0) -- Centered
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20) -- Darker black theme
    frame.BackgroundTransparency = 0.5-- Slight transparency
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    frame.Active = true -- Allows detecting input within frame bounds
    frame.Draggable = false -- Dragging handled by title bar

    -- Add UIStroke to main frame
    local frameStroke = Instance.new("UIStroke")
    frameStroke.Color = Color3.fromRGB(80, 80, 80)
    frameStroke.Thickness = 1
    frameStroke.Parent = frame

    -- Title bar for dragging the window
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Slightly lighter dark gray
    titleBar.BackgroundTransparency = 0.4 -- Slight transparency
    titleBar.BorderSizePixel = 0
    titleBar.Parent = frame
    titleBar.Active = true -- Make sure title bar can capture input

    -- Title text
    local titleText = Instance.new("TextLabel")
    titleText.Size = UDim2.new(1, -35, 1, 0) -- Leave space for close button
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "Snake Reanimation"
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 14
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar

    -- Drag functionality for the title bar
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    titleBar.InputEnded:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and dragging then
            dragging = false
        end
    end)

    -- Use UserInputService.InputChanged for smoother dragging updates
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame

    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = titleBar

    -- Enable/Disable Button
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, -20, 0, 30)
    button.Position = UDim2.new(0.5, 0, 0, 40) -- Position below title bar
    button.AnchorPoint = Vector2.new(0.5, 0)
    button.BackgroundColor3 = Color3.fromRGB(30, 100, 30) -- Dark green for "Enable"
    button.Text = "Enable Snake Reanimation"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 14
    button.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = button

    -- Add UIStroke to enable/disable button
    

    -- Close Button
    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 25, 0, 25)
    closeButton.Position = UDim2.new(1, -5, 0.5, 0) -- Top right of title bar
    closeButton.AnchorPoint = Vector2.new(1, 0.5)
    closeButton.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 14
    closeButton.Parent = titleBar

    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton

    -- Add UIStroke to close button
    

    -- Slider Helper Function (Mobile Friendly)
    local function createSlider(parent, yPosition, labelText, minValue, maxValue, defaultValue, valueChangedCallback)
        local sliderY = yPosition
        local sliderHeight = 20
        local knobSize = 16
        local currentValue = defaultValue

        -- Container for the entire slider
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Size = UDim2.new(1, -20, 0, sliderHeight)
        sliderContainer.Position = UDim2.new(0, 10, 0, sliderY) -- Use X=10 for padding
        sliderContainer.BackgroundTransparency = 1
        sliderContainer.Parent = parent

        -- Label
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0, 60, 1, 0) -- Use full height
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = labelText .. ":"
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.Font = Enum.Font.Gotham
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.TextYAlignment = Enum.TextYAlignment.Center
        label.Parent = sliderContainer

        -- Value Display
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0, 40, 1, 0) -- Use full height
        valueLabel.Position = UDim2.new(1, 0, 0, 0)
        valueLabel.AnchorPoint = Vector2.new(1, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = string.format("%.2f", defaultValue) -- Format to 2 decimals
        valueLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
        valueLabel.Font = Enum.Font.Gotham
        valueLabel.TextSize = 12
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.TextYAlignment = Enum.TextYAlignment.Center
        valueLabel.Parent = sliderContainer

        -- Slider Track
        local sliderTrack = Instance.new("Frame")
        sliderTrack.Size = UDim2.new(1, -110, 0, 4) -- Width relative to container minus labels/padding
        sliderTrack.Position = UDim2.new(0, 65, 0.5, 0) -- Position after label + padding
        sliderTrack.AnchorPoint = Vector2.new(0, 0.5)
        sliderTrack.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        sliderTrack.BorderSizePixel = 0
        sliderTrack.Parent = sliderContainer
        sliderTrack.Active = true -- Enable input detection

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(0, 2)
        trackCorner.Parent = sliderTrack

        -- Slider Knob
        local sliderKnob = Instance.new("Frame")
        sliderKnob.Size = UDim2.new(0, knobSize, 0, knobSize)
        sliderKnob.AnchorPoint = Vector2.new(0.5, 0.5) -- Center anchor for positioning
        sliderKnob.BackgroundColor3 = Color3.fromRGB(180, 180, 180) -- Light gray for contrast
        sliderKnob.BorderSizePixel = 0
        sliderKnob.ZIndex = 2
        sliderKnob.Parent = sliderContainer
        sliderKnob.Active = true -- Enable input detection

        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(0, knobSize/2)
        knobCorner.Parent = sliderKnob

        -- Add UIStroke to slider knob
        
        -- Function to update knob position based on value
        local function updateKnobPosition()
            local ratio = (currentValue - minValue) / (maxValue - minValue)
            local trackWidth = sliderTrack.AbsoluteSize.X
            local knobX = sliderTrack.Position.X.Offset + ratio * trackWidth
            sliderKnob.Position = UDim2.new(0, knobX, 0.5, 0)
        end

        -- Initialize knob position
        task.defer(updateKnobPosition) -- Defer ensures AbsoluteSize is calculated
        sliderTrack:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateKnobPosition) -- Update if size changes

        -- Slider Functionality
        local isDraggingSlider = false
        local sliderDragInput = nil

        local function updateValueFromInput(inputPos)
            local trackStart = sliderTrack.AbsolutePosition.X
            local trackWidth = sliderTrack.AbsoluteSize.X
            local trackEnd = trackStart + trackWidth

            if trackWidth <= 0 then return end -- Avoid division by zero

            local clampedX = math.clamp(inputPos.X, trackStart, trackEnd)
            local relativeX = clampedX - trackStart
            local ratio = relativeX / trackWidth

            currentValue = minValue + ratio * (maxValue - minValue)
            currentValue = math.floor(currentValue * 100 + 0.5) / 100 -- Round to 2 decimal places

            valueLabel.Text = string.format("%.2f", currentValue)
            updateKnobPosition() -- Update knob based on the new value

            if valueChangedCallback then
                valueChangedCallback(currentValue)
            end
        end

        -- Combined Input Handler for Track and Knob
        local function handleInputBegan(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDraggingSlider = true
                sliderDragInput = input -- Store the input object
                updateValueFromInput(input.Position) -- Update value immediately on click/tap
            end
        end

        sliderKnob.InputBegan:Connect(handleInputBegan)
        sliderTrack.InputBegan:Connect(handleInputBegan)

        -- Use UserInputService for global tracking of movement and release
        UserInputService.InputChanged:Connect(function(input)
            if isDraggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                updateValueFromInput(input.Position)
            end
        end)

        UserInputService.InputEnded:Connect(function(input)
            if isDraggingSlider and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
                isDraggingSlider = false
                sliderDragInput = nil
            end
        end)

        -- Function to update the slider from outside (e.g., loading settings)
        local function updateSliderExternally(newValue)
            currentValue = math.clamp(newValue, minValue, maxValue)
            valueLabel.Text = string.format("%.2f", currentValue)
            updateKnobPosition()
        end

        return updateSliderExternally -- Return the function to update externally if needed
    end

    -- Create Slider for Snake Distance ONLY
    local distanceSlider = createSlider(frame, 80, "Distance", MIN_DISTANCE, MAX_DISTANCE, snakeDistance, function(value)
        snakeDistance = value
    end)

    -- Swing Toggle Button
    local swingButton = Instance.new("TextButton")
    swingButton.Size = UDim2.new(1, -20, 0, 28)
    swingButton.Position = UDim2.new(0, 10, 0, 110)
    swingButton.BackgroundColor3 = Color3.fromRGB(30, 60, 100) -- Dark blue for "ON"
    swingButton.Text = "Swing: ON"
    swingButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    swingButton.Font = Enum.Font.GothamBold
    swingButton.TextSize = 14
    swingButton.Parent = frame

    local swingCorner = Instance.new("UICorner")
    swingCorner.CornerRadius = UDim.new(0, 8)
    swingCorner.Parent = swingButton

    -- Add UIStroke to swing button
    
    local function updateSwingButton()
        swingButton.Text = swingEnabled and "Swing: ON" or "Swing: OFF"
        swingButton.BackgroundColor3 = swingEnabled and Color3.fromRGB(30, 60, 100) or Color3.fromRGB(60, 60, 60)
    end

    swingButton.MouseButton1Click:Connect(function()
        swingEnabled = not swingEnabled
        updateSwingButton()
    end)
    updateSwingButton()

    -- Button Event Handlers
    button.MouseButton1Click:Connect(function()
        local newState = not ghostEnabled
        setGhostEnabled(newState)
        button.BackgroundColor3 = newState and Color3.fromRGB(100, 30, 30) or Color3.fromRGB(30, 100, 30)
        button.Text = newState and "Disable Snake Reanimation" or "Enable Snake Reanimation"
    end)

    closeButton.MouseButton1Click:Connect(function()
        -- Ensure disabled before destroying GUI
        if ghostEnabled then
            setGhostEnabled(false)
            button.BackgroundColor3 = Color3.fromRGB(30, 100, 30) -- Reset button state visually
            button.Text = "Enable Snake Reanimation"
        end
        screenGui:Destroy()
    end)

    screenGui.Parent = LocalPlayer:FindFirstChildWhichIsA("PlayerGui") or Players.PlayerGui -- Add to PlayerGui
    return screenGui
end

-- Initialisiere das Script
local gui = createGui()

-- Cleanup beim Beenden
local screenGui = gui -- Reference the created GUI
local function cleanup()
    print("Cleaning up Snake Reanimation script...")
    if ghostEnabled then
        setGhostEnabled(false) -- Attempt to disable the effect
    end
    if screenGui and screenGui.Parent then
        screenGui:Destroy() -- Destroy the GUI
    end
    -- Disconnect RunService connections if they might still exist somehow
    if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
    if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end
end

-- Connect cleanup to script removal
script.Destroying:Connect(cleanup)

-- Optional: Connect cleanup if the character resets (might be redundant with ResetOnSpawn=false)
if LocalPlayer.Character then
    LocalPlayer.Character.Destroying:Connect(function()
        if ghostEnabled then
            -- If the character is destroyed while active, we might need immediate cleanup
            if updateConnection then updateConnection:Disconnect(); updateConnection = nil end
            if renderStepConnection then renderStepConnection:Disconnect(); renderStepConnection = nil end
            if ghostClone then ghostClone:Destroy(); ghostClone = nil end
            originalCharacter = nil -- Prevent trying to re-enable on a destroyed character
            ghostEnabled = false
            if gui then -- Reset button state if GUI still exists
                local button = gui:FindFirstChild("Frame", true):FindFirstChild("TextButton", true)
                if button then
                     button.BackgroundColor3 = Color3.fromRGB(30, 100, 30)
                     button.Text = "Enable Snake Reanimation"
                end
            end
        end
    end)
end


--[[ invis ]]
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local CloseButton = Instance.new("TextButton")
local ToggleButton = Instance.new("TextButton")
local DragBar = Instance.new("Frame")
local Title = Instance.new("TextLabel")

ScreenGui.Parent = game.CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
MainFrame.Position = UDim2.new(0.5, -100, 0.5, -75)
MainFrame.Size = UDim2.new(0, 200, 0, 150)
MainFrame.BorderSizePixel = 0

DragBar.Name = "DragBar"
DragBar.Parent = MainFrame
DragBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
DragBar.Size = UDim2.new(1, 0, 0, 25)
DragBar.BorderSizePixel = 0

Title.Parent = DragBar
Title.BackgroundTransparency = 1
Title.Size = UDim2.new(1, -20, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.Font = Enum.Font.GothamBold
Title.Text = "Invisible toggle"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14
Title.TextXAlignment = Enum.TextXAlignment.Left

CloseButton.Parent = DragBar
CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
CloseButton.Position = UDim2.new(1, -20, 0, 5)
CloseButton.Size = UDim2.new(0, 15, 0, 15)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 14

ToggleButton.Parent = MainFrame
ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
ToggleButton.Position = UDim2.new(0.1, 0, 0.4, 0)
ToggleButton.Size = UDim2.new(0.8, 0, 0.3, 0)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = "ACTIVATE"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 18

local Dragging = false
local DragStart = nil
local StartPos = nil
local BodyLifted = false
local UpdateConnection = nil

local bodyParts = {
    "UpperTorso",
    "LowerTorso",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand",
    "LeftUpperLeg",
    "LeftLowerLeg",
    "LeftFoot",
    "RightUpperLeg",
    "RightLowerLeg",
    "RightFoot"
}

local stationaryParts = {
    "Head",
    "HumanoidRootPart"
}

local function startDrag(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        Dragging = true
        DragStart = input.Position
        StartPos = MainFrame.Position
    end
end

local function updateDrag(input)
    if Dragging then
        local delta = input.Position - DragStart
        MainFrame.Position = UDim2.new(
            StartPos.X.Scale,
            StartPos.X.Offset + delta.X,
            StartPos.Y.Scale,
            StartPos.Y.Offset + delta.Y
        )
    end
end

local function stopDrag(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        Dragging = false
    end
end

DragBar.InputBegan:Connect(startDrag)
UserInputService.InputChanged:Connect(updateDrag)
UserInputService.InputEnded:Connect(stopDrag)

CloseButton.MouseButton1Click:Connect(function()
    if BodyLifted then
        BodyLifted = false
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
    end
    ScreenGui:Destroy()
end)

local function UpdateBody()
    local player = Players.LocalPlayer
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        
        if humanoidRootPart and humanoid then
            humanoid.WalkSpeed = 16
            
            for _, partName in ipairs(bodyParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    if BodyLifted then
                        local currentPos = part.Position
                        part.CFrame = part.CFrame * CFrame.new(0, 10, 0)
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    end
                end
            end
            
            for _, partName in ipairs(stationaryParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    if partName == "HumanoidRootPart" then
                        local currentPos = part.Position
                        part.CFrame = CFrame.new(currentPos.X, currentPos.Y, currentPos.Z)
                    end
                end
            end
        end
    end
end

ToggleButton.MouseButton1Click:Connect(function()
    BodyLifted = not BodyLifted
    
    if BodyLifted then
        ToggleButton.Text = "DEACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
        
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        UpdateConnection = RunService.Heartbeat:Connect(UpdateBody)
        
        ReplicatedStorage.RagdollEvent:FireServer()
    else
        ToggleButton.Text = "ACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
        
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        
        local character = Players.LocalPlayer.Character
        if character then
            for _, partName in ipairs(bodyParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    part.CFrame = part.CFrame * CFrame.new(0, -10, 0)
                end
            end
        end
        
        ReplicatedStorage.UnragdollEvent:FireServer()
    end
end)


--[[ pickuptools ]]
local p = game:GetService("Players").LocalPlayer
local c = p.Character
if c and c:FindFirstChild("Humanoid") then
    for i, v in pairs(game:GetService("Workspace"):GetDescendants()) do
        if v:IsA("Tool") then c:FindFirstChild("Humanoid"):EquipTool(v) end
    end
end

do
end


--[[ annoynearest ]]
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- GUI Erstellung
local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local UICorner = Instance.new("UICorner") -- For rounded corners on MainFrame
local CloseButton = Instance.new("TextButton")
local ToggleButton = Instance.new("TextButton")
local DragBar = Instance.new("Frame")
local Title = Instance.new("TextLabel")

-- GUI zum CoreGui hinzufügen
ScreenGui.Parent = game.CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Hauptframe (kleiner und mit abgerundeten Ecken)
MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
MainFrame.Position = UDim2.new(0.5, -75, 0.5, -50) -- adjusted for smaller size
MainFrame.Size = UDim2.new(0, 150, 0, 100) -- smaller than original (150x100 instead of 200x150)
MainFrame.BorderSizePixel = 0

-- Abgerundete Ecken für MainFrame
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = MainFrame

-- DragBar
DragBar.Name = "DragBar"
DragBar.Parent = MainFrame
DragBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
DragBar.Size = UDim2.new(1, 0, 0, 20) -- slightly smaller than original
DragBar.BorderSizePixel = 0

-- Titel
Title.Parent = DragBar
Title.BackgroundTransparency = 1
Title.Size = UDim2.new(1, -20, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.Font = Enum.Font.GothamBold
Title.Text = "annoy nearest"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 12 -- reduced text size for smaller GUI
Title.TextXAlignment = Enum.TextXAlignment.Left

-- Close Button (kleiner und abgerundet)
CloseButton.Parent = DragBar
CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
CloseButton.Position = UDim2.new(1, -18, 0, 2)
CloseButton.Size = UDim2.new(0, 15, 0, 15)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 10

-- Toggle Button (kleiner und abgerundet)
ToggleButton.Parent = MainFrame
ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
ToggleButton.Position = UDim2.new(0.1, 0, 0.4, 0)
ToggleButton.Size = UDim2.new(0.8, 0, 0.3, 0)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = "ACTIVATE"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 14

local function ApplyRoundedCorners(button)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button
end
ApplyRoundedCorners(CloseButton)
ApplyRoundedCorners(ToggleButton)

-- Drag-Funktion für Maus und Touch
local Dragging = false
local DragStart = nil
local StartPos = nil

local function StartDrag(input)
    Dragging = true
    DragStart = input.Position
    StartPos = MainFrame.Position
end

local function UpdateDrag(input)
    if Dragging then
        local delta = input.Position - DragStart
        MainFrame.Position = UDim2.new(
            StartPos.X.Scale,
            StartPos.X.Offset + delta.X,
            StartPos.Y.Scale,
            StartPos.Y.Offset + delta.Y
        )
    end
end

local function StopDrag()
    Dragging = false
end

DragBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        UpdateDrag(input)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StopDrag()
    end
end)

--------------------------------------------------------------------------------
-- Körper Lifting Variablen und Funktionen
local BodyLifted = false
local UpdateConnection = nil
local originalPositions = {}      -- Speichert die ursprünglichen CFrames der Körperteile (inkl. Y-Rotation)
local currentKeyframe = 1
local animationTime = 0
local lastKeyframeTime = 0
local nearestTargetPlayers = {}
local farthestTargetPlayers = {}
local randomTargetPlayers = {}
local initialHumanoidRootPartCFrame = nil -- Ursprünglicher CFrame des HumanoidRootPart (mit Y-Achse)

-- Neue Variablen für Sitzplätze
local seatBackup = {}       -- Hier speichern wir die entfernten Sitzplätze (Objekt + ursprünglicher Parent)
local seatAddedConnection = nil  -- Verbindung zum Überwachen neu hinzugefügter Sitzplätze

-- Keyframe System
local keyframes = {
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "nearest",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(-10, 5, 10),
                rotation = Vector3.new(0, 15, 10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(-8, 3, 12),
                rotation = Vector3.new(5, -5, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(12, -2, -10),
                rotation = Vector3.new(-5, 10, 5),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(-10, 2, 8),
                rotation = Vector3.new(15, 30, -10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(-2, 7, 5),
                rotation = Vector3.new(0, 45, 20),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(3, 10, -2),
                rotation = Vector3.new(10, 60, -15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(-7, -4, -12),
                rotation = Vector3.new(-20, -15, 10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(4, -8, -5),
                rotation = Vector3.new(15, -40, -25),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(-3, -12, 3),
                rotation = Vector3.new(-10, -55, 30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(-12, -3, 10),
                rotation = Vector3.new(25, 10, -5),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(8, -7, -8),
                rotation = Vector3.new(-10, 20, 15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(5, -10, 2),
                rotation = Vector3.new(0, -15, -35),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(10, 4, 12),
                rotation = Vector3.new(-30, -25, 5),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(-9, 6, -10),
                rotation = Vector3.new(5, -35, -10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(2, 9, -4),
                rotation = Vector3.new(-5, 25, 40),
                targetPlayer = "nearest",
                matchTargetPart = true
            }
        }
    },
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "nearest",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(5, -8, -5),
                rotation = Vector3.new(15, -30, -20),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(3, -5, -7),
                rotation = Vector3.new(-10, 20, 15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(-6, 4, 6),
                rotation = Vector3.new(5, -15, -25),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(4, -3, -4),
                rotation = Vector3.new(-25, 10, 30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(-2, -7, 2),
                rotation = Vector3.new(15, -40, -10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(0, -9, -1),
                rotation = Vector3.new(-10, 25, 45),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(-5, 6, 3),
                rotation = Vector3.new(30, -20, -15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(2, 8, -2),
                rotation = Vector3.new(-15, 45, 20),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(-1, 10, 1),
                rotation = Vector3.new(10, -30, -35),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(7, 2, -5),
                rotation = Vector3.new(-20, 15, 40),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(-4, -1, 4),
                rotation = Vector3.new(10, -25, -10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(3, 5, -3),
                rotation = Vector3.new(-5, 15, 25),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(-6, -4, 6),
                rotation = Vector3.new(25, -10, -30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(4, 3, -4),
                rotation = Vector3.new(-10, 20, 15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(-2, -6, 2),
                rotation = Vector3.new(5, -35, -20),
                targetPlayer = "nearest",
                matchTargetPart = true
            }
        }
    },
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "nearest",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(-5, 8, 5),
                rotation = Vector3.new(-15, 30, 20),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(-3, 5, 7),
                rotation = Vector3.new(10, -20, -15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(6, -4, -6),
                rotation = Vector3.new(-5, 15, 25),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(-4, 3, 4),
                rotation = Vector3.new(25, -10, -30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(2, 7, -2),
                rotation = Vector3.new(-15, 40, 10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(0, 9, 1),
                rotation = Vector3.new(10, -25, -45),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(5, -6, -3),
                rotation = Vector3.new(-30, 20, 15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(-2, -8, 2),
                rotation = Vector3.new(15, -45, -20),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(1, -10, -1),
                rotation = Vector3.new(-10, 30, 35),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(-7, -2, 5),
                rotation = Vector3.new(20, -15, -40),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(4, 1, -4),
                rotation = Vector3.new(-10, 25, 10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(-3, -5, 3),
                rotation = Vector3.new(5, -15, -25),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(6, 4, -6),
                rotation = Vector3.new(-25, 10, 30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(-4, -3, 4),
                rotation = Vector3.new(10, -20, -15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(2, 6, -2),
                rotation = Vector3.new(-5, 35, 20),
                targetPlayer = "nearest",
                matchTargetPart = true
            }
        }
    },
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "nearest",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(10, -5, -10),
                rotation = Vector3.new(0, -15, -10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(8, -3, -12),
                rotation = Vector3.new(-5, 5, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(-12, 2, 10),
                rotation = Vector3.new(5, -10, -5),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(10, -2, -8),
                rotation = Vector3.new(-15, -30, 10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(2, -7, -5),
                rotation = Vector3.new(0, -45, -20),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(-3, -10, 2),
                rotation = Vector3.new(-10, -60, 15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(7, 4, 12),
                rotation = Vector3.new(20, 15, -10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(-4, 8, 5),
                rotation = Vector3.new(-15, 40, 25),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(3, 12, -3),
                rotation = Vector3.new(10, 55, -30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(12, 3, -10),
                rotation = Vector3.new(-25, -10, 5),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(-8, 7, 8),
                rotation = Vector3.new(10, -20, -15),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(-5, 10, -2),
                rotation = Vector3.new(0, 15, 35),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(-10, -4, -12),
                rotation = Vector3.new(30, 25, -5),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(9, -6, 10),
                rotation = Vector3.new(-5, 35, 10),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(-2, -9, 4),
                rotation = Vector3.new(5, -25, -40),
                targetPlayer = "nearest",
                matchTargetPart = true
            }
        }
    },
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "nearest",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(0, 10, 0),
                rotation = Vector3.new(45, 0, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(0, 8, 0),
                rotation = Vector3.new(0, 45, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(0, 6, 0),
                rotation = Vector3.new(0, 0, 45),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(5, 7, 5),
                rotation = Vector3.new(30, 60, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(-5, 9, -5),
                rotation = Vector3.new(0, 90, 45),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(10, 5, 0),
                rotation = Vector3.new(45, 180, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(-5, 7, -5),
                rotation = Vector3.new(60, 0, 30),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(5, 9, 5),
                rotation = Vector3.new(90, 45, 0),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(-10, 5, 0),
                rotation = Vector3.new(180, 0, 45),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(0, 3, 10),
                rotation = Vector3.new(0, 0, -60),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(0, 7, -10),
                rotation = Vector3.new(45, 45, 90),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(8, -4, 0),
                rotation = Vector3.new(-45, 90, -45),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(0, 3, -10),
                rotation = Vector3.new(0, 0, 60),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(0, 7, 10),
                rotation = Vector3.new(45, -45, -90),
                targetPlayer = "nearest",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(-8, -4, 0),
                rotation = Vector3.new(-45, -90, 45),
                targetPlayer = "nearest",
                matchTargetPart = true
            }
        }
    },
}

-- Liste der Körperteile (wird hier nicht weiter verwendet, da wir über die keyframe-Konfiguration iterieren)
local bodyParts = {}
for partName, _ in pairs(keyframes[1].config) do
    table.insert(bodyParts, partName)
end

-- Hilfsfunktion zum Interpolieren zwischen zwei Vektoren
local function LerpVector3(start, target, alpha)
    return start:Lerp(target, alpha)
end

-- Funktion zum Finden eines Spielers anhand eines Teilnamens (unterstützt "nearest", "farthest" und "random")
local function FindPlayerByPartialName(partialName, partName)
    if partialName == "nearest" then
        if nearestTargetPlayers[partName] then
            return nearestTargetPlayers[partName]
        else
            local localPlayer = Players.LocalPlayer
            local localCharacter = localPlayer.Character
            if not localCharacter then return nil end
            local localHumanoidRootPart = localCharacter:FindFirstChild("HumanoidRootPart")
            if not localHumanoidRootPart then return nil end

            local nearestPlayer = nil
            local nearestDistance = math.huge
            
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    local character = player.Character
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local distance = (localHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if distance < nearestDistance then
                                nearestDistance = distance
                                nearestPlayer = player
                            end
                        end
                    end
                end
            end
            nearestTargetPlayers[partName] = nearestPlayer
            return nearestPlayer
        end
    elseif partialName == "farthest" then
        if farthestTargetPlayers[partName] then
            return farthestTargetPlayers[partName]
        else
            local localPlayer = Players.LocalPlayer
            local localCharacter = localPlayer.Character
            if not localCharacter then return nil end
            local localHumanoidRootPart = localCharacter:FindFirstChild("HumanoidRootPart")
            if not localHumanoidRootPart then return nil end

            local farthestPlayer = nil
            local farthestDistance = -math.huge
            
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    local character = player.Character
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local distance = (localHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if distance > farthestDistance then
                                farthestDistance = distance
                                farthestPlayer = player
                            end
                        end
                    end
                end
            end
            farthestTargetPlayers[partName] = farthestPlayer
            return farthestPlayer
        end
    elseif partialName == "random" then
        if randomTargetPlayers[partName] then
            return randomTargetPlayers[partName]
        else
            local allPlayers = Players:GetPlayers()
            local validPlayers = {}
            for _, player in ipairs(allPlayers) do
                if player ~= Players.LocalPlayer then
                    table.insert(validPlayers, player)
                end
            end
            if #validPlayers > 0 then
                local randomIndex = math.random(1, #validPlayers)
                local randomPlayer = validPlayers[randomIndex]
                randomTargetPlayers[partName] = randomPlayer
                return randomPlayer
            end
            return nil
        end
    end
    
    partialName = partialName:lower()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Name:lower():find(partialName) or (player.DisplayName and player.DisplayName:lower():find(partialName)) then
            return player
        end
    end
    return nil
end

-- Drag-Funktionalität der GUI (bereits oben integriert)

--------------------------------------------------------------------------------
-- SPEICHERN DER URSPRÜNGLICHEN POSITIONEN UND ROTATIONEN
local function SaveOriginalPositions()
    local character = Players.LocalPlayer.Character
    if character then
        for partName, _ in pairs(keyframes[1].config) do
            if partName ~= "Humanoid" then
                local part = character:FindFirstChild(partName)
                if part then
                    originalPositions[partName] = part.CFrame
                end
            end
        end
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            initialHumanoidRootPartCFrame = humanoidRootPart.CFrame
        end
    end
end

--------------------------------------------------------------------------------
-- AKTUALISIEREN EINER EINZELNEN KÖRPERTEIL-POSITION
local function UpdateBodyPart(character, partName, currentConfig, nextConfig, alpha)
    local part = character:FindFirstChild(partName)
    if part and BodyLifted and partName ~= "Humanoid" then
        local baseCFrame = originalPositions[partName]
        if baseCFrame then
            local currentTargetCFrame = baseCFrame
            local nextTargetCFrame = baseCFrame
            
            if currentConfig.targetPlayer and currentConfig.targetPlayer ~= "" then
                local currentPlayer = FindPlayerByPartialName(currentConfig.targetPlayer, partName)
                if currentPlayer and currentPlayer.Character then
                    if currentConfig.matchTargetPart then
                        local targetPart = currentPlayer.Character:FindFirstChild(partName)
                        if targetPart then
                            currentTargetCFrame = CFrame.new(targetPart.Position)
                        end
                    else
                        local targetHumanoidRootPart = currentPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if targetHumanoidRootPart then
                            currentTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                        end
                    end
                end
            else
                currentTargetCFrame = CFrame.new(baseCFrame.Position)
            end
            
            if nextConfig.targetPlayer and nextConfig.targetPlayer ~= "" then
                local nextPlayer = FindPlayerByPartialName(nextConfig.targetPlayer, partName)
                if nextPlayer and nextPlayer.Character then
                    if nextConfig.matchTargetPart then
                        local targetPart = nextPlayer.Character:FindFirstChild(partName)
                        if targetPart then
                            nextTargetCFrame = CFrame.new(targetPart.Position)
                        end
                    else
                        local targetHumanoidRootPart = nextPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if targetHumanoidRootPart then
                            nextTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                        end
                    end
                end
            else
                nextTargetCFrame = CFrame.new(baseCFrame.Position)
            end
            
            local currentOffset = CFrame.new(currentConfig.position) *
                CFrame.Angles(
                    math.rad(currentConfig.rotation.X),
                    math.rad(currentConfig.rotation.Y),
                    math.rad(currentConfig.rotation.Z)
                )
            local nextOffset = CFrame.new(nextConfig.position) *
                CFrame.Angles(
                    math.rad(nextConfig.rotation.X),
                    math.rad(nextConfig.rotation.Y),
                    math.rad(nextConfig.rotation.Z)
                )
            
            local finalCurrentCFrame = currentTargetCFrame * currentOffset
            local finalNextCFrame = nextTargetCFrame * nextOffset
            local finalCFrame = finalCurrentCFrame:Lerp(finalNextCFrame, alpha)
            
            local _, origYaw, _ = baseCFrame:ToOrientation()
            finalCFrame = CFrame.new(finalCFrame.Position) * CFrame.Angles(0, origYaw, 0)
            
            part.CFrame = finalCFrame
            part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        end
    end
end

--------------------------------------------------------------------------------
-- AKTUALISIEREN DES HUMANOID (bzw. des HumanoidRootPart)
local function UpdateHumanoid(character, currentConfig, nextConfig, alpha)
    local humanoid = character:FindFirstChild("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoid and humanoidRootPart and initialHumanoidRootPartCFrame then
        local currentTargetCFrame = initialHumanoidRootPartCFrame
        local nextTargetCFrame = initialHumanoidRootPartCFrame
        
        if currentConfig.targetPlayer and currentConfig.targetPlayer ~= "" then
            local currentPlayer = FindPlayerByPartialName(currentConfig.targetPlayer, "Humanoid")
            if currentPlayer and currentPlayer.Character then
                local targetHumanoidRootPart = currentPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    currentTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                end
            end
        else
            currentTargetCFrame = CFrame.new(initialHumanoidRootPartCFrame.Position)
        end
        
        if nextConfig.targetPlayer and nextConfig.targetPlayer ~= "" then
            local nextPlayer = FindPlayerByPartialName(nextConfig.targetPlayer, "Humanoid")
            if nextPlayer and nextPlayer.Character then
                local targetHumanoidRootPart = nextPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    nextTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                end
            end
        else
            nextTargetCFrame = CFrame.new(initialHumanoidRootPartCFrame.Position)
        end
        
        local currentOffset = CFrame.new(currentConfig.position) *
            CFrame.Angles(
                math.rad(currentConfig.rotation.X),
                math.rad(currentConfig.rotation.Y),
                math.rad(currentConfig.rotation.Z)
            )
        local nextOffset = CFrame.new(nextConfig.position) *
            CFrame.Angles(
                math.rad(nextConfig.rotation.X),
                math.rad(nextConfig.rotation.Y),
                math.rad(nextConfig.rotation.Z)
            )
        
        local finalCurrentCFrame = currentTargetCFrame * currentOffset
        local finalNextCFrame = nextTargetCFrame * nextOffset
        local finalCFrame = finalCurrentCFrame:Lerp(finalNextCFrame, alpha)
        
        local _, origYaw, _ = initialHumanoidRootPartCFrame:ToOrientation()
        finalCFrame = CFrame.new(finalCFrame.Position) * CFrame.Angles(0, origYaw, 0)
        
        humanoidRootPart.CFrame = finalCFrame
        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        humanoid.WalkSpeed = 16
    end
end

--------------------------------------------------------------------------------
-- BODY UPDATE FUNKTION (wird jeden Heartbeat aufgerufen)
local function UpdateBody()
    local character = Players.LocalPlayer.Character
    if character and BodyLifted then
        local humanoid = character:FindFirstChild("Humanoid")
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoid and humanoidRootPart and initialHumanoidRootPartCFrame then
            local deltaTime = tick() - lastKeyframeTime
            animationTime = animationTime + deltaTime
            lastKeyframeTime = tick()
            
            local currentFrame = keyframes[currentKeyframe]
            local nextFrame = keyframes[currentKeyframe + 1]
            if not nextFrame then
                nextFrame = keyframes[1]
            end
            
            local alpha = math.min(animationTime / currentFrame.duration, 1)
            
            for partName, _ in pairs(currentFrame.config) do
                UpdateBodyPart(character, partName, currentFrame.config[partName], nextFrame.config[partName], alpha)
            end
            if currentFrame.config.Humanoid then
                UpdateHumanoid(character, currentFrame.config.Humanoid, nextFrame.config.Humanoid, alpha)
            end
            if alpha >= 1 then
                currentKeyframe = currentKeyframe + 1
                if currentKeyframe > #keyframes then
                    currentKeyframe = 1
                end
                animationTime = 0
            end
        end
    end
end

--------------------------------------------------------------------------------
-- FUNKTION ZUM SICHEREN DEAKTIVIERENS DES RAGDOLLS
local function SafeDeactivateRagdoll()
    for i = 1, 3 do
        ReplicatedStorage.UnragdollEvent:FireServer()
        task.wait(0.1)
    end
    
    local character = Players.LocalPlayer.Character
    if character then
        for partName, _ in pairs(keyframes[1].config) do
            if partName ~= "Humanoid" then
                local part = character:FindFirstChild(partName)
                if part and originalPositions[partName] then
                    part.CFrame = originalPositions[partName]
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end
        end
    end
    
    nearestTargetPlayers = {}
    farthestTargetPlayers = {}
    randomTargetPlayers = {}
    initialHumanoidRootPartCFrame = nil
end

--------------------------------------------------------------------------------
-- TOGGLE BUTTON FUNKTIONALITÄT
ToggleButton.MouseButton1Click:Connect(function()
    BodyLifted = not BodyLifted
    
    if BodyLifted then
        ToggleButton.Text = "DEACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
        
        SaveOriginalPositions()
        currentKeyframe = 1
        animationTime = 0
        lastKeyframeTime = tick()
        
        -- Entferne vorhandene Sitzplätze und sichere sie in seatBackup
        for _, obj in ipairs(game.Workspace:GetDescendants()) do
            if obj:IsA("Seat") or obj:IsA("VehicleSeat") then
                table.insert(seatBackup, {seat = obj, parent = obj.Parent})
                obj.Parent = nil
            end
        end
        
        -- Überwache neu hinzugefügte Sitzplätze und entferne diese sofort
        seatAddedConnection = game.Workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("Seat") or obj:IsA("VehicleSeat") then
                table.insert(seatBackup, {seat = obj, parent = obj.Parent})
                obj.Parent = nil
            end
        end)
        
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        UpdateConnection = RunService.Heartbeat:Connect(UpdateBody)
        
        ReplicatedStorage.RagdollEvent:FireServer()
    else
        ToggleButton.Text = "ACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
        
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        
        -- Beende die Überwachung neuer Sitzplätze
        if seatAddedConnection then
            seatAddedConnection:Disconnect()
            seatAddedConnection = nil
        end
        
        -- Stelle alle entfernten Sitzplätze wieder her
        for _, data in ipairs(seatBackup) do
            if data.seat and data.parent then
                data.seat.Parent = data.parent
            end
        end
        seatBackup = {}
        
        SafeDeactivateRagdoll()
    end
end)

--------------------------------------------------------------------------------
-- CLOSE BUTTON (beendet das Script)
CloseButton.MouseButton1Click:Connect(function()
    if BodyLifted then
        BodyLifted = false
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        -- Wiederherstellen der Sitzplätze beim Beenden
        if seatAddedConnection then
            seatAddedConnection:Disconnect()
            seatAddedConnection = nil
        end
        for _, data in ipairs(seatBackup) do
            if data.seat and data.parent then
                data.seat.Parent = data.parent
            end
        end
        seatBackup = {}
        SafeDeactivateRagdoll()
    end
    ScreenGui:Destroy()
end)

--------------------------------------------------------------------------------
-- RESET beim Respawn
Players.LocalPlayer.CharacterAdded:Connect(function()
    if BodyLifted then
        BodyLifted = false
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        ToggleButton.Text = "ACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
        
        if seatAddedConnection then
            seatAddedConnection:Disconnect()
            seatAddedConnection = nil
        end
        for _, data in ipairs(seatBackup) do
            if data.seat and data.parent then
                data.seat.Parent = data.parent
            end
        end
        seatBackup = {}
        
        SafeDeactivateRagdoll()
    end
end)


--[[ animrecord ]]
-- Animation Recorder by AI Assistant
-- Local script for recording and playing animation clips
-- Modified to remove whitelist system, make GUI fully draggable for mobile, remove webhook functionality,
-- add minimize functionality, mirror player animations 1:1 including exact speed and freeze states,
-- and reduce GUI size

-- SERVICES
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")

-- Retrieve player data
local LocalPlayer = Players.LocalPlayer

-- Variables
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local Animator = Humanoid:WaitForChild("Animator")

local GUI
local DraggableFrame
local RecordingClip = false
local CurrentClip = {}
local SavedClips = {}
local LoopingClips = {}
local KeyBinds = {}
local ClipsFolder = "AnimationClipsSaved"
local SaveFileName = "AnimationClips_" .. LocalPlayer.UserId .. ".json"
local SelectedPlayer = nil
local CurrentlyPlayingClip = nil
local CurrentStopFunc = nil
local IsMinimized = false

-- Track animation states
local TrackingAnimations = false
local AnimationTracks = {}
local LastAnimationTime = 0

-- Create GUI
local function CreateGUI()
    -- Main Frame (reduced size: 400x500 -> 300x375)
    GUI = Instance.new("ScreenGui")
    GUI.Name = "AnimationRecorderGUI"
    GUI.ResetOnSpawn = false

    DraggableFrame = Instance.new("Frame")
    DraggableFrame.Name = "MainFrame"
    DraggableFrame.Size = UDim2.new(0, 300, 0, 375)
    DraggableFrame.Position = UDim2.new(0.5, -150, 0.5, -187.5)
    DraggableFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    DraggableFrame.BorderSizePixel = 0
    DraggableFrame.Parent = GUI

    -- Round corners
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 8)
    UICorner.Parent = DraggableFrame

    -- Title Bar (height: 30 -> 22)
    local TitleBar = Instance.new("Frame")
    TitleBar.Name = "TitleBar"
    TitleBar.Size = UDim2.new(1, 0, 0, 22)
    TitleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    TitleBar.BorderSizePixel = 0
    TitleBar.Parent = DraggableFrame

    local TitleCorner = Instance.new("UICorner")
    TitleCorner.CornerRadius = UDim.new(0, 8)
    TitleCorner.Parent = TitleBar

    -- Fix corners for title bar
    local CornerFix = Instance.new("Frame")
    CornerFix.Name = "CornerFix"
    CornerFix.Size = UDim2.new(1, 0, 0.5, 0)
    CornerFix.Position = UDim2.new(0, 0, 0.5, 0)
    CornerFix.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    CornerFix.BorderSizePixel = 0
    CornerFix.Parent = TitleBar

    -- Title (font size: 14 -> 12)
    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Size = UDim2.new(1, -75, 1, 0)
    Title.Position = UDim2.new(0, 8, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Font = Enum.Font.GothamBold
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextSize = 12
    Title.Text = "Animation Recorder"
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = TitleBar

    -- Minimize Button (size: 20x20 -> 15x15)
    local MinimizeButton = Instance.new("TextButton")
    MinimizeButton.Name = "MinimizeButton"
    MinimizeButton.Size = UDim2.new(0, 15, 0, 15)
    MinimizeButton.Position = UDim2.new(1, -37, 0, 4)
    MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 200, 80)
    MinimizeButton.Text = "-"
    MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    MinimizeButton.Font = Enum.Font.GothamBold
    MinimizeButton.TextSize = 12
    MinimizeButton.Parent = TitleBar

    local MinimizeCorner = Instance.new("UICorner")
    MinimizeCorner.CornerRadius = UDim.new(1, 0)
    MinimizeCorner.Parent = MinimizeButton

    -- Close Button (size: 20x20 -> 15x15)
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Size = UDim2.new(0, 15, 0, 15)
    CloseButton.Position = UDim2.new(1, -19, 0, 4)
    CloseButton.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
    CloseButton.Text = ""
    CloseButton.Parent = TitleBar

    local CloseCorner = Instance.new("UICorner")
    CloseCorner.CornerRadius = UDim.new(1, 0)
    CloseCorner.Parent = CloseButton

    -- Main Content Container (adjusted for smaller frame)
    local ContentFrame = Instance.new("Frame")
    ContentFrame.Name = "ContentFrame"
    ContentFrame.Size = UDim2.new(1, -15, 1, -30)
    ContentFrame.Position = UDim2.new(0, 8, 0, 26)
    ContentFrame.BackgroundTransparency = 1
    ContentFrame.Parent = DraggableFrame

    -- Player Search Section (height: 60 -> 45)
    local SearchSection = Instance.new("Frame")
    SearchSection.Name = "SearchSection"
    SearchSection.Size = UDim2.new(1, 0, 0, 45)
    SearchSection.BackgroundTransparency = 1
    SearchSection.Parent = ContentFrame

    local SearchLabel = Instance.new("TextLabel")
    SearchLabel.Name = "SearchLabel"
    SearchLabel.Size = UDim2.new(1, 0, 0, 15)
    SearchLabel.BackgroundTransparency = 1
    SearchLabel.Font = Enum.Font.Gotham
    SearchLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    SearchLabel.TextSize = 12
    SearchLabel.Text = "Search Player:"
    SearchLabel.TextXAlignment = Enum.TextXAlignment.Left
    SearchLabel.Parent = SearchSection

    local SearchBox = Instance.new("TextBox")
    SearchBox.Name = "SearchBox"
    SearchBox.Size = UDim2.new(1, 0, 0, 22)
    SearchBox.Position = UDim2.new(0, 0, 0, 18)
    SearchBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    SearchBox.BorderSizePixel = 0
    SearchBox.Font = Enum.Font.Gotham
    SearchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    SearchBox.TextSize = 12
    SearchBox.PlaceholderText = "Enter username or display name..."
    SearchBox.Text = ""
    SearchBox.Parent = SearchSection

    local SearchBoxCorner = Instance.new("UICorner")
    SearchBoxCorner.CornerRadius = UDim.new(0, 4)
    SearchBoxCorner.Parent = SearchBox

    -- Dropdown for search results (item height: 30 -> 22)
    local DropdownFrame = Instance.new("Frame")
    DropdownFrame.Name = "DropdownFrame"
    DropdownFrame.Size = UDim2.new(1, 0, 0, 0)
    DropdownFrame.Position = UDim2.new(0, 0, 0, 45)
    DropdownFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    DropdownFrame.BorderSizePixel = 0
    DropdownFrame.Visible = false
    DropdownFrame.ZIndex = 5
    DropdownFrame.Parent = SearchSection

    local DropdownLayout = Instance.new("UIListLayout")
    DropdownLayout.SortOrder = Enum.SortOrder.LayoutOrder
    DropdownLayout.Parent = DropdownFrame

    local DropdownCorner = Instance.new("UICorner")
    DropdownCorner.CornerRadius = UDim.new(0, 4)
    DropdownCorner.Parent = DropdownFrame

    -- Recording Control Section (height: 40 -> 30)
    local ControlSection = Instance.new("Frame")
    ControlSection.Name = "ControlSection"
    ControlSection.Size = UDim2.new(1, 0, 0, 30)
    ControlSection.Position = UDim2.new(0, 0, 0, 52)
    ControlSection.BackgroundTransparency = 1
    ControlSection.Parent = ContentFrame

    -- Toggle Record Button
    local RecordButton = Instance.new("TextButton")
    RecordButton.Name = "RecordButton"
    RecordButton.Size = UDim2.new(1, 0, 1, 0)
    RecordButton.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
    RecordButton.Font = Enum.Font.GothamBold
    RecordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    RecordButton.TextSize = 12
    RecordButton.Text = "START RECORDING"
    RecordButton.Parent = ControlSection

    local RecordCorner = Instance.new("UICorner")
    RecordCorner.CornerRadius = UDim.new(0, 4)
    RecordCorner.Parent = RecordButton

    -- Status Label (height: 20 -> 15)
    local StatusLabel = Instance.new("TextLabel")
    StatusLabel.Name = "StatusLabel"
    StatusLabel.Size = UDim2.new(1, 0, 0, 15)
    StatusLabel.Position = UDim2.new(0, 0, 0, 90)
    StatusLabel.BackgroundTransparency = 1
    StatusLabel.Font = Enum.Font.Gotham
    StatusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    StatusLabel.TextSize = 10
    StatusLabel.Text = "Ready to record"
    StatusLabel.Parent = ContentFrame

    -- Clips List Section
    local ClipsSection = Instance.new("Frame")
    ClipsSection.Name = "ClipsSection"
    ClipsSection.Size = UDim2.new(1, 0, 1, -112)
    ClipsSection.Position = UDim2.new(0, 0, 0, 112)
    ClipsSection.BackgroundTransparency = 1
    ClipsSection.Parent = ContentFrame

    local ClipsLabel = Instance.new("TextLabel")
    ClipsLabel.Name = "ClipsLabel"
    ClipsLabel.Size = UDim2.new(1, 0, 0, 15)
    ClipsLabel.BackgroundTransparency = 1
    ClipsLabel.Font = Enum.Font.GothamBold
    ClipsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ClipsLabel.TextSize = 12
    ClipsLabel.Text = "Saved Clips"
    ClipsLabel.TextXAlignment = Enum.TextXAlignment.Left
    ClipsLabel.Parent = ClipsSection

    local ClipsScrollFrame = Instance.new("ScrollingFrame")
    ClipsScrollFrame.Name = "ClipsScrollFrame"
    ClipsScrollFrame.Size = UDim2.new(1, 0, 1, -18)
    ClipsScrollFrame.Position = UDim2.new(0, 0, 0, 18)
    ClipsScrollFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    ClipsScrollFrame.BorderSizePixel = 0
    ClipsScrollFrame.ScrollBarThickness = 3
    ClipsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    ClipsScrollFrame.Parent = ClipsSection

    local ClipsCorner = Instance.new("UICorner")
    ClipsCorner.CornerRadius = UDim.new(0, 4)
    ClipsCorner.Parent = ClipsScrollFrame

    local ClipsList = Instance.new("UIListLayout")
    ClipsList.Padding = UDim.new(0, 4)
    ClipsList.SortOrder = Enum.SortOrder.LayoutOrder
    ClipsList.Parent = ClipsScrollFrame

    local ClipsPadding = Instance.new("UIPadding")
    ClipsPadding.PaddingLeft = UDim.new(0, 4)
    ClipsPadding.PaddingRight = UDim.new(0, 4)
    ClipsPadding.PaddingTop = UDim.new(0, 4)
    ClipsPadding.PaddingBottom = UDim.new(0, 4)
    ClipsPadding.Parent = ClipsScrollFrame

    -- Set parent
    GUI.Parent = LocalPlayer:WaitForChild("PlayerGui")

    return {
        MainFrame = DraggableFrame,
        TitleBar = TitleBar,
        CloseButton = CloseButton,
        MinimizeButton = MinimizeButton,
        SearchBox = SearchBox,
        DropdownFrame = DropdownFrame,
        RecordButton = RecordButton,
        StatusLabel = StatusLabel,
        ClipsScrollFrame = ClipsScrollFrame,
        ContentFrame = ContentFrame
    }
end

-- Make Frame Draggable (Enhanced for Mobile)
local function MakeDraggable(frame)
    local dragging = false
    local dragStart
    local frameStart

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            frameStart = frame.Position
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(
                frameStart.X.Scale,
                frameStart.X.Offset + delta.X,
                frameStart.Y.Scale,
                frameStart.Y.Offset + delta.Y
            )
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
end

-- Find player function
local function FindPlayer(searchText)
    if searchText == "" then return {} end

    local results = {}
    for _, player in pairs(Players:GetPlayers()) do
        if string.lower(player.Name):find(string.lower(searchText)) then
            table.insert(results, player)
        elseif string.lower(player.DisplayName):find(string.lower(searchText)) then
            table.insert(results, player)
        end
        
        if #results >= 5 then
            break
        end
    end

    return results
end

-- Update dropdown with search results
local function UpdateDropdown(guiElements, results)
    local dropdown = guiElements.DropdownFrame

    for _, child in pairs(dropdown:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end

    if #results == 0 then
        dropdown.Visible = false
        dropdown.Size = UDim2.new(1, 0, 0, 0)
        return
    end

    for i, player in ipairs(results) do
        local button = Instance.new("TextButton")
        button.Name = "Result" .. i
        button.Size = UDim2.new(1, 0, 0, 22)
        button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        button.BorderSizePixel = 0
        button.Font = Enum.Font.Gotham
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextSize = 12
        button.Text = player.DisplayName .. " (@" .. player.Name .. ")"
        button.ZIndex = 5
        button.Parent = dropdown
        
        button.MouseEnter:Connect(function()
            button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        end)
        
        button.MouseLeave:Connect(function()
            button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end)
        
        button.MouseButton1Click:Connect(function()
            SelectedPlayer = player
            guiElements.SearchBox.Text = player.DisplayName .. " (@" .. player.Name .. ")"
            dropdown.Visible = false
            guiElements.StatusLabel.Text = "Ready to record " .. player.DisplayName .. "'s animations"
        end)
    end

    dropdown.Size = UDim2.new(1, 0, 0, 22 * #results)
    dropdown.Visible = true
end

-- Generate clip name with auto-incrementing number for duplicates
local function GenerateClipName(playerName)
    local baseName = playerName .. "'s clip"
    local highestNumber = 0

    for _, clip in ipairs(SavedClips) do
        if clip.PlayerName == playerName then
            local clipNumber = clip.Name:match(baseName .. " (%d+)")
            if clipNumber then
                clipNumber = tonumber(clipNumber)
                if clipNumber and clipNumber > highestNumber then
                    highestNumber = clipNumber
                end
            end
        end
    end

    if highestNumber == 0 then
        return baseName .. " 1"
    else
        return baseName .. " " .. (highestNumber + 1)
    end
end

-- Start tracking animations of a player
local function StartTrackingAnimations(player)
    if not player then return end

    local character = player.Character
    if not character then
        player.CharacterAdded:Wait()
        character = player.Character
    end

    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")

    TrackingAnimations = true
    AnimationTracks = {}

    local clipName = GenerateClipName(player.Name)

    CurrentClip = {
        Name = clipName,
        PlayerName = player.Name,
        Events = {},
        StartTime = tick(),
        InitialCFrame = character:GetPivot(),
        InitialCameraCFrame = workspace.CurrentCamera.CFrame
    }

    local function TrackCharacterTransform()
        local currentTime = tick() - CurrentClip.StartTime
        local currentCFrame = character:GetPivot()
        
        table.insert(CurrentClip.Events, {
            Type = "Transform",
            Time = currentTime,
            CFrame = currentCFrame,
            LookVector = currentCFrame.LookVector
        })
    end

    local equippedTool = nil

    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") and item.Parent == character then
            equippedTool = item
            break
        end
    end

    local toolConnection = character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            equippedTool = child
        end
    end)

    local toolRemovedConnection = character.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") and child == equippedTool then
            equippedTool = nil
        end
    end)

    local function UpdateAnimationTracks()
        local tracks = animator:GetPlayingAnimationTracks()
        local currentTime = tick() - CurrentClip.StartTime
        
        for _, track in pairs(tracks) do
            local trackId = track.Animation.AnimationId
            
            local skipTrack = false
            if equippedTool then
                if trackId:match("tool") or trackId:match("equip") or trackId:match("weapon") then
                    skipTrack = true
                end
            end
            
            if not skipTrack then
                if not AnimationTracks[trackId] or AnimationTracks[trackId].Stopped then
                    AnimationTracks[trackId] = {
                        Track = track,
                        Stopped = false,
                        StartTime = currentTime,
                        LastTimePosition = track.TimePosition,
                        LastUpdateTime = currentTime,
                        LastSpeed = track.Speed,
                        IsFrozen = false
                    }
                    
                    table.insert(CurrentClip.Events, {
                        Type = "Start",
                        AnimationId = trackId,
                        Time = currentTime,
                        Speed = track.Speed,
                        Weight = track.WeightCurrent,
                        TimePosition = track.TimePosition
                    })
                else
                    local trackData = AnimationTracks[trackId]
                    local expectedPosition = trackData.LastTimePosition + 
                        (currentTime - trackData.LastUpdateTime) * trackData.LastSpeed
                    
                    -- Check for freeze state (animation paused)
                    local isFrozen = math.abs(track.TimePosition - trackData.LastTimePosition) < 0.01 and track.Speed ~= 0
                    if isFrozen ~= trackData.IsFrozen then
                        table.insert(CurrentClip.Events, {
                            Type = "Freeze",
                            AnimationId = trackId,
                            Time = currentTime,
                            IsFrozen = isFrozen
                        })
                        trackData.IsFrozen = isFrozen
                    end
                    
                    -- Check for significant time position jump
                    if math.abs(track.TimePosition - expectedPosition) > 0.1 then
                        table.insert(CurrentClip.Events, {
                            Type = "TimeJump",
                            AnimationId = trackId,
                            Time = currentTime,
                            PreviousPosition = trackData.LastTimePosition,
                            NewPosition = track.TimePosition
                        })
                    end
                    
                    -- Record speed changes
                    if math.abs(track.Speed - trackData.LastSpeed) > 0.01 then
                        table.insert(CurrentClip.Events, {
                            Type = "Speed",
                            AnimationId = trackId,
                            Time = currentTime,
                            Speed = track.Speed
                        })
                        trackData.LastSpeed = track.Speed
                    end
                    
                    -- Record weight changes
                    if math.abs(track.WeightCurrent - trackData.Track.WeightCurrent) > 0.01 then
                        table.insert(CurrentClip.Events, {
                            Type = "Weight",
                            AnimationId = trackId,
                            Time = currentTime,
                            Weight = track.WeightCurrent
                        })
                    end
                    
                    trackData.Track = track
                    trackData.LastTimePosition = track.TimePosition
                    trackData.LastUpdateTime = currentTime
                end
            end
        end
        
        for id, data in pairs(AnimationTracks) do
            if not data.Stopped then
                local stillPlaying = false
                
                for _, track in pairs(tracks) do
                    if track.Animation.AnimationId == id then
                        stillPlaying = true
                        break
                    end
                end
                
                if not stillPlaying then
                    data.Stopped = true
                    
                    table.insert(CurrentClip.Events, {
                        Type = "Stop",
                        AnimationId = id,
                        Time = currentTime,
                        FinalPosition = data.LastTimePosition
                    })
                end
            end
        end
    end

    LastAnimationTime = tick()

    local trackingLoop = task.spawn(function()
        while TrackingAnimations do
            UpdateAnimationTracks()
            TrackCharacterTransform()
            task.wait(0.03)
        end
        
        toolConnection:Disconnect()
        toolRemovedConnection:Disconnect()
    end)
end

-- Stop tracking animations
local function StopTrackingAnimations()
    TrackingAnimations = false

    if CurrentClip and #CurrentClip.Events > 0 then
        CurrentClip.Duration = tick() - CurrentClip.StartTime
        
        CurrentClip.Id = HttpService:GenerateGUID(false)
        
        table.insert(SavedClips, CurrentClip)
        
        SaveClipsToFile()
        
        return true
    end

    return false
end

-- Play an animation clip on local character
local function PlayClip(clip, loop)
    if CurrentStopFunc then
        CurrentStopFunc()
        CurrentStopFunc = nil
    end

    local character = LocalPlayer.Character
    if not character then return end

    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")

    local originalCFrame = character:GetPivot()
    local originalLookVector = originalCFrame.LookVector

    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        track:Stop()
    end

    local clipTracks = {}
    CurrentlyPlayingClip = clip.Id

    local function PlayClipOnce()
        local startTime = tick()
        local eventsProcessed = {}
        
        local connection
        connection = RunService.Heartbeat:Connect(function()
            local elapsed = tick() - startTime
            
            if elapsed > clip.Duration and not loop then
                connection:Disconnect()
                
                for _, trackData in pairs(clipTracks) do
                    if trackData.Track and trackData.Track.IsPlaying then
                        trackData.Track:Stop()
                    end
                end
                
                if CurrentlyPlayingClip == clip.Id then
                    CurrentlyPlayingClip = nil
                    for _, child in pairs(GUI.MainFrame.ContentFrame.ClipsSection.ClipsScrollFrame:GetChildren()) do
                        if child:IsA("Frame") and child.Name == "Clip_" .. clip.Id then
                            local playButton = child.Actions.PlayButton
                            playButton.Text = "PLAY"
                            playButton.BackgroundColor3 = Color3.fromRGB(60, 180, 75)
                            break
                        end
                    end
                end
                
                return
            end
            
            if loop and elapsed > clip.Duration then
                startTime = tick()
                table.clear(eventsProcessed)
                elapsed = 0
                
                for _, trackData in pairs(clipTracks) do
                    if trackData.Track and trackData.Track.IsPlaying then
                        trackData.Track:Stop()
                    end
                end
            end
            
            for i, event in ipairs(clip.Events) do
                if not eventsProcessed[i] and elapsed >= event.Time then
                    eventsProcessed[i] = true
                    
                    if event.Type == "Start" then
                        local animation = Instance.new("Animation")
                        animation.AnimationId = event.AnimationId
                        
                        local track = animator:LoadAnimation(animation)
                        track:AdjustSpeed(event.Speed)
                        
                        if event.TimePosition then
                            track.TimePosition = event.TimePosition
                        end
                        
                        track:Play()
                        
                        clipTracks[event.AnimationId] = {
                            Track = track,
                            Animation = animation
                        }
                        
                    elseif event.Type == "Stop" then
                        if clipTracks[event.AnimationId] and clipTracks[event.AnimationId].Track then
                            clipTracks[event.AnimationId].Track:Stop()
                        end
                        
                    elseif event.Type == "Speed" then
                        if clipTracks[event.AnimationId] and clipTracks[event.AnimationId].Track then
                            clipTracks[event.AnimationId].Track:AdjustSpeed(event.Speed)
                        end
                        
                    elseif event.Type == "Weight" then
                        if clipTracks[event.AnimationId] and clipTracks[event.AnimationId].Track then
                            clipTracks[event.AnimationId].Track:AdjustWeight(event.Weight)
                        end
                        
                    elseif event.Type == "TimeJump" then
                        if clipTracks[event.AnimationId] and clipTracks[event.AnimationId].Track then
                            clipTracks[event.AnimationId].Track.TimePosition = event.NewPosition
                        end
                        
                    elseif event.Type == "Freeze" then
                        if clipTracks[event.AnimationId] and clipTracks[event.AnimationId].Track then
                            local track = clipTracks[event.AnimationId].Track
                            if event.IsFrozen then
                                track:AdjustSpeed(0)
                            else
                                track:AdjustSpeed(1)
                            end
                        end
                        
                    elseif event.Type == "Transform" then
                        if event.LookVector then
                            local recordedLookVec = event.LookVector
                            local initialLookVec = clip.InitialCFrame.LookVector
                            
                            local angle = math.atan2(
                                recordedLookVec.X - initialLookVec.X,
                                recordedLookVec.Z - initialLookVec.Z
                            )
                            
                            local currentPos = originalCFrame.Position
                            local rotatedLookVec = CFrame.Angles(0, angle, 0) * originalLookVector
                            
                            local newOrientation = CFrame.new(
                                currentPos,
                                currentPos + rotatedLookVec
                            )
                            
                            local rootPart = character:FindFirstChild("HumanoidRootPart")
                            if rootPart then
                                rootPart.CFrame = CFrame.new(rootPart.Position) * (newOrientation - newOrientation.Position)
                            end
                        end
                    end
                end
            end
        end)
        
        return connection
    end

    local playConnection = PlayClipOnce()

    return function()
        if playConnection then
            playConnection:Disconnect()
        end
        
        CurrentlyPlayingClip = nil
        
        for _, trackData in pairs(clipTracks) do
            if trackData.Track and trackData.Track.IsPlaying then
                trackData.Track:Stop()
            end
        end
    end
end

-- Create a clip entry for the UI (clip height: 80 -> 60)
local function CreateClipEntry(guiElements, clip, index)
    local clipFrame = Instance.new("Frame")
    clipFrame.Name = "Clip_" .. clip.Id
    clipFrame.Size = UDim2.new(1, 0, 0, 60)
    clipFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    clipFrame.BorderSizePixel = 0
    clipFrame.LayoutOrder = index

    local clipCorner = Instance.new("UICorner")
    clipCorner.CornerRadius = UDim.new(0, 4)
    clipCorner.Parent = clipFrame

    local clipHeader = Instance.new("Frame")
    clipHeader.Name = "Header"
    clipHeader.Size = UDim2.new(1, 0, 0, 22)
    clipHeader.BackgroundTransparency = 1
    clipHeader.Parent = clipFrame

    local nameBox = Instance.new("TextBox")
    nameBox.Name = "NameBox"
    nameBox.Size = UDim2.new(1, -82, 1, 0)
    nameBox.Position = UDim2.new(0, 4, 0, 0)
    nameBox.BackgroundTransparency = 1
    nameBox.Font = Enum.Font.GothamBold
    nameBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameBox.TextSize = 12
    nameBox.Text = clip.Name
    nameBox.TextXAlignment = Enum.TextXAlignment.Left
    nameBox.ClearTextOnFocus = false
    nameBox.Parent = clipHeader

    local durationLabel = Instance.new("TextLabel")
    durationLabel.Name = "Duration"
    durationLabel.Size = UDim2.new(0, 75, 1, 0)
    durationLabel.Position = UDim2.new(1, -79, 0, 0)
    durationLabel.BackgroundTransparency = 1
    durationLabel.Font = Enum.Font.Gotham
    durationLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    durationLabel.TextSize = 10
    durationLabel.Text = string.format("%.1fs", clip.Duration or 0)
    durationLabel.Parent = clipHeader

    local actionsFrame = Instance.new("Frame")
    actionsFrame.Name = "Actions"
    actionsFrame.Size = UDim2.new(1, 0, 0, 30)
    actionsFrame.Position = UDim2.new(0, 0, 0, 26)
    actionsFrame.BackgroundTransparency = 1
    actionsFrame.Parent = clipFrame

    local playButton = Instance.new("TextButton")
    playButton.Name = "PlayButton"
    playButton.Size = UDim2.new(0.23, 0, 0, 22)
    playButton.Position = UDim2.new(0, 4, 0, 0)
    playButton.BackgroundColor3 = Color3.fromRGB(60, 180, 75)
    playButton.Font = Enum.Font.GothamBold
    playButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    playButton.TextSize = 10
    playButton.Text = "PLAY"
    playButton.Parent = actionsFrame

    local playCorner = Instance.new("UICorner")
    playCorner.CornerRadius = UDim.new(0, 4)
    playCorner.Parent = playButton

    local loopButton = Instance.new("TextButton")
    loopButton.Name = "LoopButton"
    loopButton.Size = UDim2.new(0.23, 0, 0, 22)
    loopButton.Position = UDim2.new(0.25, 4, 0, 0)
    loopButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    loopButton.Font = Enum.Font.GothamBold
    loopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    loopButton.TextSize = 10
    loopButton.Text = "LOOP"
    loopButton.Parent = actionsFrame

    local loopCorner = Instance.new("UICorner")
    loopCorner.CornerRadius = UDim.new(0, 4)
    loopCorner.Parent = loopButton

    local keybindButton = Instance.new("TextButton")
    keybindButton.Name = "KeybindButton"
    keybindButton.Size = UDim2.new(0.23, 0, 0, 22)
    keybindButton.Position = UDim2.new(0.5, 4, 0, 0)
    keybindButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    keybindButton.Font = Enum.Font.GothamBold
    keybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    keybindButton.TextSize = 10
    keybindButton.Text = "KEYBIND"
    keybindButton.Parent = actionsFrame

    local keybindCorner = Instance.new("UICorner")
    keybindCorner.CornerRadius = UDim.new(0, 4)
    keybindCorner.Parent = keybindButton

    local deleteButton = Instance.new("TextButton")
    deleteButton.Name = "DeleteButton"
    deleteButton.Size = UDim2.new(0.23, 0, 0, 22)
    deleteButton.Position = UDim2.new(0.75, 4, 0, 0)
    deleteButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
    deleteButton.Font = Enum.Font.GothamBold
    deleteButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    deleteButton.TextSize = 10
    deleteButton.Text = "DELETE"
    deleteButton.Parent = actionsFrame

    local deleteCorner = Instance.new("UICorner")
    deleteCorner.CornerRadius = UDim.new(0, 4)
    deleteCorner.Parent = deleteButton

    local stopFunc = nil

    playButton.MouseButton1Click:Connect(function()
        if stopFunc then
            stopFunc()
            stopFunc = nil
            playButton.Text = "PLAY"
            playButton.BackgroundColor3 = Color3.fromRGB(60, 180, 75)
            return
        end
        
        local isLooping = LoopingClips[clip.Id] or false
        
        stopFunc = PlayClip(clip, isLooping)
        CurrentStopFunc = stopFunc
        playButton.Text = "STOP"
        playButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
    end)

    loopButton.MouseButton1Click:Connect(function()
        LoopingClips[clip.Id] = not LoopingClips[clip.Id]
        
        if LoopingClips[clip.Id] then
            loopButton.BackgroundColor3 = Color3.fromRGB(60, 120, 180)
        else
            loopButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        end
    end)

    keybindButton.MouseButton1Click:Connect(function()
        if KeyBinds[clip.Id] then
            KeyBinds[clip.Id] = nil
            keybindButton.Text = "KEYBIND"
            keybindButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
            return
        end
        
        keybindButton.Text = "PRESS KEY"
        keybindButton.BackgroundColor3 = Color3.fromRGB(180, 180, 60)
        
        local connection
        connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            
            if input.UserInputType == Enum.UserInputType.Keyboard then
                KeyBinds[clip.Id] = input.KeyCode
                keybindButton.Text = input.KeyCode.Name
                keybindButton.BackgroundColor3 = Color3.fromRGB(60, 120, 180)
                
                SaveKeybinds()
                
                connection:Disconnect()
            end
        end)
    end)

    deleteButton.MouseButton1Click:Connect(function()
        if CurrentlyPlayingClip == clip.Id and CurrentStopFunc then
            CurrentStopFunc()
            CurrentStopFunc = nil
            CurrentlyPlayingClip = nil
        end
        
        for i, savedClip in ipairs(SavedClips) do
            if savedClip.Id == clip.Id then
                table.remove(SavedClips, i)
                break
            end
        end
        
        KeyBinds[clip.Id] = nil
        LoopingClips[clip.Id] = nil
        
        clipFrame:Destroy()
        
        UpdateClipsCanvasSize(guiElements)
        
        SaveClipsToFile()
        SaveKeybinds()
    end)

    nameBox.FocusLost:Connect(function(enterPressed)
        for i, savedClip in ipairs(SavedClips) do
            if savedClip.Id == clip.Id then
                SavedClips[i].Name = nameBox.Text
                break
            end
        end
        
        SaveClipsToFile()
    end)

    if LoopingClips[clip.Id] then
        loopButton.BackgroundColor3 = Color3.fromRGB(60, 120, 180)
    end

    if KeyBinds[clip.Id] then
        keybindButton.Text = KeyBinds[clip.Id].Name
        keybindButton.BackgroundColor3 = Color3.fromRGB(60, 120, 180)
    end

    clipFrame.Parent = guiElements.ClipsScrollFrame
    return clipFrame
end

-- Update the canvas size of the clips scrolling frame
function UpdateClipsCanvasSize(guiElements)
    local scrollFrame = guiElements.ClipsScrollFrame
    local contentSize = scrollFrame.UIListLayout.AbsoluteContentSize.Y
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize + 8)
end

-- Save clips to file
function SaveClipsToFile()
    local success, errorMsg = pcall(function()
        local saveData = {
            Clips = SavedClips,
            Version = 1
        }

        local jsonData = HttpService:JSONEncode(saveData)
        
        if not isfolder(ClipsFolder) then
            makefolder(ClipsFolder)
        end
        
        writefile(ClipsFolder .. "/" .. SaveFileName, jsonData)
    end)

    if not success then
        warn("Failed to save clips: " .. errorMsg)
    end
end

-- Save keybinds to file
function SaveKeybinds()
    local success, errorMsg = pcall(function()
        local keybindData = {}
        for id, keyCode in pairs(KeyBinds) do
            keybindData[id] = keyCode.Name
        end

        local saveData = {
            KeyBinds = keybindData,
            LoopingClips = LoopingClips,
            Version = 1
        }
        
        local jsonData = HttpService:JSONEncode(saveData)
        
        if not isfolder(ClipsFolder) then
            makefolder(ClipsFolder)
        end
        
        writefile(ClipsFolder .. "/Keybinds_" .. LocalPlayer.UserId .. ".json", jsonData)
    end)

    if not success then
        warn("Failed to save keybinds: " .. errorMsg)
    end
end

-- Load clips from file
local function LoadClipsFromFile()
    local success, result = pcall(function()
        if not isfolder(ClipsFolder) then
            makefolder(ClipsFolder)
            return false
        end

        if not isfile(ClipsFolder .. "/" .. SaveFileName) then
            return false
        end
        
        local jsonData = readfile(ClipsFolder .. "/" .. SaveFileName)
        local saveData = HttpService:JSONDecode(jsonData)
        
        if saveData and saveData.Clips then
            SavedClips = saveData.Clips
            return true
        end
        
        return false
    end)

    if not success or result == false then
        SavedClips = {}
    end
end

-- Load keybinds from file
local function LoadKeybinds()
    local success, result = pcall(function()
        if not isfolder(ClipsFolder) then
            makefolder(ClipsFolder)
            return false
        end

        local keybindFileName = ClipsFolder .. "/Keybinds_" .. LocalPlayer.UserId .. ".json"
        if not isfile(keybindFileName) then
            return false
        end
        
        local jsonData = readfile(keybindFileName)
        local saveData = HttpService:JSONDecode(jsonData)
        
        if saveData then
            for id, keyName in pairs(saveData.KeyBinds) do
                KeyBinds[id] = Enum.KeyCode[keyName]
            end
            
            LoopingClips = saveData.LoopingClips
            
            return true
        end
        
        return false
    end)

    if not success or result == false then
        KeyBinds = {}
        LoopingClips = {}
    end
end

-- Initialize the UI and functionality
local function Initialize()
    local guiElements = CreateGUI()

    MakeDraggable(guiElements.MainFrame)

    -- Minimize button functionality (minimized height: 30 -> 22)
    guiElements.MinimizeButton.MouseButton1Click:Connect(function()
        IsMinimized = not IsMinimized
        if IsMinimized then
            guiElements.ContentFrame.Visible = false
            guiElements.MainFrame.Size = UDim2.new(0, 300, 0, 22)
            guiElements.MinimizeButton.Text = "+"
        else
            guiElements.ContentFrame.Visible = true
            guiElements.MainFrame.Size = UDim2.new(0, 300, 0, 375)
            guiElements.MinimizeButton.Text = "-"
        end
    end)

    guiElements.CloseButton.MouseButton1Click:Connect(function()
        GUI:Destroy()
    end)

    guiElements.SearchBox.Changed:Connect(function(property)
        if property == "Text" then
            local results = FindPlayer(guiElements.SearchBox.Text)
            UpdateDropdown(guiElements, results)
        end
    end)

    guiElements.SearchBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local results = FindPlayer(guiElements.SearchBox.Text)
            if #results == 1 then
                SelectedPlayer = results[1]
                guiElements.SearchBox.Text = results[1].DisplayName .. " (@" .. results[1].Name .. ")"
                guiElements.DropdownFrame.Visible = false
                guiElements.StatusLabel.Text = "Ready to record " .. results[1].DisplayName .. "'s animations"
            end
        end
    end)

    guiElements.RecordButton.MouseButton1Click:Connect(function()
        if RecordingClip then
            RecordingClip = false
            guiElements.RecordButton.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
            guiElements.RecordButton.Text = "START RECORDING"
            
            local clipSaved = StopTrackingAnimations()
            
            if clipSaved then
                guiElements.StatusLabel.Text = "Clip saved"
                
                local newClip = SavedClips[#SavedClips]
                CreateClipEntry(guiElements, newClip, #SavedClips)
                
                UpdateClipsCanvasSize(guiElements)
            else
                guiElements.StatusLabel.Text = "Recording canceled (no animations recorded)"
            end
        else
            if not SelectedPlayer then
                guiElements.StatusLabel.Text = "Please select a player first"
                return
            end
            
            RecordingClip = true
            guiElements.RecordButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
            guiElements.RecordButton.Text = "STOP RECORDING"
            guiElements.StatusLabel.Text = "Recording " .. SelectedPlayer.DisplayName .. "'s animations..."
            
            StartTrackingAnimations(SelectedPlayer)
        end
    end)

    LoadClipsFromFile()
    LoadKeybinds()

    for i, clip in ipairs(SavedClips) do
        CreateClipEntry(guiElements, clip, i)
    end

    UpdateClipsCanvasSize(guiElements)

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Keyboard then
            for clipId, keyCode in pairs(KeyBinds) do
                if keyCode == input.KeyCode then
                    local clipToPlay = nil
                    for _, clip in ipairs(SavedClips) do
                        if clip.Id == clipId then
                            clipToPlay = clip
                            break
                        end
                    end
                    
                    if clipToPlay then
                        local isLooping = LoopingClips[clipId] or false
                        
                        if CurrentlyPlayingClip == clipId and CurrentStopFunc then
                            CurrentStopFunc()
                            CurrentStopFunc = nil
                            CurrentlyPlayingClip = nil
                            
                            for _, child in pairs(GUI.MainFrame.ContentFrame.ClipsSection.ClipsScrollFrame:GetChildren()) do
                                if child:IsA("Frame") and child.Name == "Clip_" .. clipId then
                                    local playButton = child.Actions.PlayButton
                                    playButton.Text = "PLAY"
                                    playButton.BackgroundColor3 = Color3.fromRGB(60, 180, 75)
                                    break
                                end
                            end
                        else
                            if CurrentStopFunc then
                                CurrentStopFunc()
                                CurrentStopFunc = nil
                                
                                if CurrentlyPlayingClip then
                                    for _, child in pairs(GUI.MainFrame.ContentFrame.ClipsSection.ClipsScrollFrame:GetChildren()) do
                                        if child:IsA("Frame") and child.Name == "Clip_" .. CurrentlyPlayingClip then
                                            local playButton = child.Actions.PlayButton
                                            playButton.Text = "PLAY"
                                            playButton.BackgroundColor3 = Color3.fromRGB(60, 180, 75)
                                            break
                                        end
                                    end
                                end
                            end
                            
                            CurrentStopFunc = PlayClip(clipToPlay, isLooping)
                            
                            for _, child in pairs(GUI.MainFrame.ContentFrame.ClipsSection.ClipsScrollFrame:GetChildren()) do
                                if child:IsA("Frame") and child.Name == "Clip_" .. clipId then
                                    local playButton = child.Actions.PlayButton
                                    playButton.Text = "STOP"
                                    playButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end)

    guiElements.StatusLabel.Text = "Ready to record"
end

-- Run the script
Initialize()

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    Animator = Humanoid:WaitForChild("Animator")
end)


--[[ tptoplr ]]
-- LocalScript inside the TPtoPlr Tool

local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Create the teleportation tool
local tool = Instance.new("Tool")
tool.Name = "TPtoPlr"  -- Changed the tool name here
tool.RequiresHandle = false
tool.Parent = player:WaitForChild("Backpack") -- Adds the tool to the player's backpack

-- Function to teleport the local player to the clicked target player
local function teleportToPlayer(targetPlayer)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
        print("Teleported " .. player.Name .. " to " .. targetPlayer.Name)
    else
        print("Teleport failed: Make sure both players' characters are loaded and have HumanoidRootParts.")
    end
end

-- Function to handle clicking on other players
local function onMouseClick(target)
    local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
    if targetPlayer and targetPlayer ~= player then -- Ensure we're targeting another player
        teleportToPlayer(targetPlayer)
    end
end

-- Set up mouse click detection when the tool is equipped
tool.Equipped:Connect(function()
    local mouse = player:GetMouse()
    
    -- Function to detect mouse clicks
    mouse.Button1Down:Connect(function()
        if mouse.Target and mouse.Target.Parent then
            onMouseClick(mouse.Target)
        end
    end)
end)

-- Cleanup when the tool is unequipped
tool.Unequipped:Connect(function()
    -- Optionally, you could disconnect the mouse click listener here if you stored it.
    print("TPtoPlr tool unequipped")
end)


--[[ chattroll ]]
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/0x"))()
local window = library:Window("Chat Interface")

local INVISIBLE_CHAR = "\u{001E}"
local NEWLINE = "\u{000D}"

-- Create a table to store presets
local presets = {}

local function chatMessage(str)
    str = tostring(str)
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        TextChatService.TextChannels.RBXGeneral:SendAsync(str)
    else
        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str, "All")
    end
end

local function createButton(text, parent, size, position, backgroundColor)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = size
    button.Position = position
    button.BackgroundColor3 = backgroundColor or Color3.fromRGB(60, 60, 60)
    button.BorderSizePixel = 0
    button.Font = Enum.Font.GothamSemibold
    button.TextSize = 14
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.AutoButtonColor = true
    button.Parent = parent

    -- Create rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button

    -- Add hover effect
    local originalColor = button.BackgroundColor3
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = backgroundColor and backgroundColor:Lerp(Color3.fromRGB(255, 255, 255), 0.2) or Color3.fromRGB(80, 80, 80)
        }):Play()
    end)

    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = originalColor
        }):Play()
    end)

    return button
end

local function addShadow(frame)
    local shadow = Instance.new("ImageLabel")
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://297774371"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.8
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame
end

local drawingGui = nil
local selectedEmoji = "❓"

local function createDrawingInterface()
    local gui = Instance.new("ScreenGui")
    local mainFrame = Instance.new("Frame")

    -- Main frame (matches dark theme in image)
    mainFrame.Size = UDim2.new(0, 300, 0, 490)  -- Increased height
    mainFrame.Position = UDim2.new(0.5, -150, 0.5, -245)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = gui

    -- Add rounded corners to main frame
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = mainFrame

    addShadow(mainFrame)

    -- Title bar
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame

    -- Add rounded corners to title bar
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleBar

    local titleText = Instance.new("TextLabel")
    titleText.Text = "Drawing Interface"
    titleText.Size = UDim2.new(1, -40, 1, 0)
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Font = Enum.Font.Gotham
    titleText.TextSize = 14
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar

    -- Close button (red X in corner)
    local closeButton = createButton("X", titleBar, UDim2.new(0, 30, 0, 30), UDim2.new(1, -30, 0, 0), Color3.fromRGB(220, 50, 50))
    closeButton.MouseButton1Click:Connect(function()
        gui.Enabled = false
    end)

    -- Grid setup
    local GRID_SIZE = 7
    local CELL_SIZE = 35
    local grid = {}

    local gridFrame = Instance.new("Frame")
    gridFrame.Size = UDim2.new(0, GRID_SIZE * CELL_SIZE, 0, GRID_SIZE * CELL_SIZE)
    gridFrame.Position = UDim2.new(0.5, -(GRID_SIZE * CELL_SIZE)/2, 0, 40)  -- Positioned below title
    gridFrame.BackgroundTransparency = 1
    gridFrame.Parent = mainFrame

    -- Create grid cells
    for i = 1, GRID_SIZE do
        grid[i] = {}
        for j = 1, GRID_SIZE do
            local cell = Instance.new("TextButton")
            cell.Size = UDim2.new(0, CELL_SIZE - 2, 0, CELL_SIZE - 2)
            cell.Position = UDim2.new(0, (j-1) * CELL_SIZE + 1, 0, (i-1) * CELL_SIZE + 1)
            cell.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            cell.BorderSizePixel = 0
            cell.Text = ""
            cell.Font = Enum.Font.Gotham
            cell.TextSize = 20
            cell.Parent = gridFrame

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 4)
            corner.Parent = cell

            grid[i][j] = ""

            cell.MouseButton1Down:Connect(function()
                grid[i][j] = selectedEmoji
                cell.Text = selectedEmoji
				-- Add subtle animation
				local scaleUp = TweenService:Create(cell, TweenInfo.new(0.1), {Size = UDim2.new(0, CELL_SIZE, 0, CELL_SIZE)})
				local scaleDown = TweenService:Create(cell, TweenInfo.new(0.1), {Size = UDim2.new(0, CELL_SIZE - 2, 0, CELL_SIZE - 2)})
				scaleUp:Play()
				scaleUp.Completed:Connect(function()
					scaleDown:Play()
				end)
            end)
        end
    end

    -- Emoji selector (with scrolling)
    local emojiScrollFrame = Instance.new("ScrollingFrame")
    emojiScrollFrame.Size = UDim2.new(0.95, 0, 0, 40)
    emojiScrollFrame.Position = UDim2.new(0.025, 0, 0, 295)  -- Positioned below grid
    emojiScrollFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    emojiScrollFrame.BorderSizePixel = 0
    emojiScrollFrame.ScrollBarThickness = 4
    emojiScrollFrame.ScrollingDirection = Enum.ScrollingDirection.X
    emojiScrollFrame.Parent = mainFrame

	    local emojiScrollFrameCorner = Instance.new("UICorner")
		emojiScrollFrameCorner.CornerRadius = UDim.new(0, 4)
        emojiScrollFrameCorner.Parent = emojiScrollFrame

    local emojis = {"⬜", "🏮", "🔴", "📕", "📙", "📒", "📗", "🔵", "📘", "💜", "🤎", "⬛",  "🔲", "🔳"}
	local emojiButtons = {}

    -- Calculate total width needed for emoji buttons
    local totalWidth = #emojis * 35  -- 30px button + 5px spacing
    emojiScrollFrame.CanvasSize = UDim2.new(0, totalWidth, 0, 0)

    for i, emoji in ipairs(emojis) do
        local emojiButton = Instance.new("TextButton")
        emojiButton.Text = emoji
        emojiButton.Size = UDim2.new(0, 30, 0, 30)
        emojiButton.Position = UDim2.new(0, (i-1) * 35 + 5, 0, 5)
        emojiButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        emojiButton.BorderSizePixel = 0
        emojiButton.Font = Enum.Font.Gotham
        emojiButton.TextSize = 20
        emojiButton.Parent = emojiScrollFrame

		local emojiCorner = Instance.new("UICorner")
        emojiCorner.CornerRadius = UDim.new(0, 4)
        emojiCorner.Parent = emojiButton

		table.insert(emojiButtons, emojiButton)

		emojiButton.MouseButton1Click:Connect(function()
			selectedEmoji = emoji
			for _, btn in ipairs(emojiButtons) do
				btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
			end
			emojiButton.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
		end)
    end

     -- Preset section
    local presetFrame = Instance.new("Frame")
    presetFrame.Size = UDim2.new(0.95, 0, 0, 125) -- Increased frame size
	presetFrame.Position = UDim2.new(0.025, 0, 0, 340)
    presetFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    presetFrame.BorderSizePixel = 0
	presetFrame.Parent = mainFrame

	local presetFrameCorner = Instance.new("UICorner")
	presetFrameCorner.CornerRadius = UDim.new(0, 6)
	presetFrameCorner.Parent = presetFrame

	-- Preset input
    local presetInput = Instance.new("TextBox")
    presetInput.Size = UDim2.new(0.7, 0, 0, 30)
    presetInput.Position = UDim2.new(0.025, 0, 0, 10)
    presetInput.PlaceholderText = "Enter preset name..."
	presetInput.Text = ""
    presetInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    presetInput.BorderSizePixel = 0
    presetInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    presetInput.Font = Enum.Font.Gotham
    presetInput.TextSize = 14
    presetInput.Parent = presetFrame

	local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 4)
    inputCorner.Parent = presetInput

    local savePresetButton = createButton("Save Preset", presetFrame, UDim2.new(0.225, 0, 0, 30), UDim2.new(0.75, 0, 0, 10), Color3.fromRGB(70, 170, 70))

	-- Preset list
    local presetList = Instance.new("ScrollingFrame")
    presetList.Size = UDim2.new(0.95, 0, 0, 80) -- Increased height
    presetList.Position = UDim2.new(0.025, 0, 0, 45) -- Adjusted position to fit inside presetFrame
    presetList.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    presetList.BorderSizePixel = 0
    presetList.ScrollBarThickness = 4
	presetList.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
	presetList.ScrollBarImageTransparency = 0.5
    presetList.Parent = presetFrame

	local listCorner = Instance.new("UICorner")
    listCorner.CornerRadius = UDim.new(0, 4)
    listCorner.Parent = presetList

	local function updatePresetList()
        for _, child in ipairs(presetList:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end

		local yOffset = 5
		for i, presetData in ipairs(presets) do
			local name = presetData.name
			local preset = presetData.grid
            local presetButton = createButton(name, presetList, UDim2.new(0.9, 0, 0, 25), UDim2.new(0.05, 0, 0, yOffset))

            -- Load preset
            presetButton.MouseButton1Click:Connect(function()
                for i = 1, GRID_SIZE do
                    for j = 1, GRID_SIZE do
                        grid[i][j] = preset[i][j]
                        gridFrame:GetChildren()[(i - 1) * GRID_SIZE + j].Text = preset[i][j]
                    end
                end
            end)

            -- Delete button
            local deleteButton = createButton("X", presetButton, UDim2.new(0, 20, 0, 20), UDim2.new(1, -25, 0, 2), Color3.fromRGB(200, 50, 50))
			deleteButton.TextSize = 12

            deleteButton.MouseButton1Click:Connect(function()
				table.remove(presets, i)
                updatePresetList()
            end)

            yOffset = yOffset + 30
        end

		presetList.CanvasSize = UDim2.new(0, 0, 0, yOffset)
    end

	savePresetButton.MouseButton1Click:Connect(function()
		local name = presetInput.Text
        if name ~= "" then
            local currentGrid = {}
            for i = 1, GRID_SIZE do
                currentGrid[i] = {}
                for j = 1, GRID_SIZE do
                    currentGrid[i][j] = grid[i][j]
                end
            end

			table.insert(presets, {name = name, grid = currentGrid})
            presetInput.Text = ""
            updatePresetList()
        end
    end)

    -- Action buttons at bottom
    local actionButtons = Instance.new("Frame")
    actionButtons.Size = UDim2.new(0.95, 0, 0, 35)
    actionButtons.Position = UDim2.new(0.025, 0, 0, 455) -- Lowered action buttons
    actionButtons.BackgroundTransparency = 1
    actionButtons.Parent = mainFrame

    local sendButton = createButton("Send", actionButtons, UDim2.new(0.48, 0, 1, 0), UDim2.new(0, 0, 0, 0), Color3.fromRGB(70, 170, 70))
    sendButton.MouseButton1Click:Connect(function()
        local art = ""
        for i = 1, GRID_SIZE do
            for j = 1, GRID_SIZE do
                art = art .. (grid[i][j] ~= "" and grid[i][j] or "⬜")
            end
            if i < GRID_SIZE then
                art = art .. NEWLINE
            end
        end
        chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 1) .. art)
    end)

    local clearButton = createButton("Clear", actionButtons, UDim2.new(0.48, 0, 1, 0), UDim2.new(0.52, 0, 0, 0), Color3.fromRGB(170, 70, 70))
    clearButton.MouseButton1Click:Connect(function()
        for i = 1, GRID_SIZE do
            for j = 1, GRID_SIZE do
                grid[i][j] = ""
                gridFrame:GetChildren()[(i - 1) * GRID_SIZE + j].Text = ""
            end
        end
    end)

     -- Make the interface draggable
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        local position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)

        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        TweenService:Create(mainFrame, tweenInfo, {Position = position}):Play()
    end

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)

    return gui
end

-- Initialize the GUI immediately when the script runs
drawingGui = createDrawingInterface()
drawingGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
drawingGui.Enabled = false

-- Main interface buttons
window:Button("ROBLOX Join", function()
    chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 80) .. "[Server]: Roblox has joined the game.")
end)

window:Button("Server Chat Clear", function()
    chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 100) .. "[Server]: Chat cleared.")
end)

window:Button("Custom Drawing", function()
    drawingGui.Enabled = not drawingGui.Enabled
end)
window:Button("Swastika", function()
    chatMessage(INVISIBLE_CHAR..string.rep(NEWLINE, 40).. "⬜⬜⬜⬜⬜⬜⬜"..NEWLINE.."⬜⬛⬜⬛⬛⬛⬜"..NEWLINE.."⬜⬛⬜⬛⬜⬜⬜"..NEWLINE.."⬜⬛⬛⬛⬛⬛⬜"..NEWLINE.."⬜⬜⬜⬛⬜⬛⬜"..NEWLINE.."⬜⬛⬛⬛⬜⬛⬜"..NEWLINE.."⬜⬜⬜⬜⬜⬜⬜")
end)
window:Button("Penis", function()
    chatMessage(NEWLINE.. "⬜⬜⬜⬜⬜⬜⬜⬜"..NEWLINE.."⬜⬜⬜⬛⬛⬜⬜⬜"..NEWLINE.."⬜⬜⬜⬛⬛⬜⬜⬜"..NEWLINE.."⬜⬜⬜⬛⬛⬜⬜⬜"..NEWLINE.."⬜⬜⬜⬛⬛⬜⬜⬜"..NEWLINE.."⬜⬛⬛⬛⬛⬛⬛⬜"..NEWLINE.."⬜⬛⬛⬜⬜⬛⬛⬜"..NEWLINE.."⬜⬜⬜⬜⬜⬜⬜⬜")
end)
local upArrow = INVISIBLE_CHAR..NEWLINE..
"⬜⬜⬜⬜⬜⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬛⬛⬛⬛⬜" .. NEWLINE ..
"⬛⬛⬛⬛⬛⬛" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬜⬜⬜⬜⬜"

-- Down Arrow
local downArrow = INVISIBLE_CHAR..NEWLINE..
"⬜⬜⬜⬜⬜⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬛⬛⬛⬛⬛⬛" .. NEWLINE ..
"⬜⬛⬛⬛⬛⬜" .. NEWLINE ..
"⬜⬜⬛⬛⬜⬜" .. NEWLINE ..
"⬜⬜⬜⬜⬜⬜"

window:Button("Heart", function()
    local heart = INVISIBLE_CHAR ..
      NEWLINE ..
        "⬜⬛⬛⬜⬛⬛⬜" .. NEWLINE ..
        "⬛⬛⬛⬛⬛⬛⬛" .. NEWLINE ..
        "⬛⬛⬛⬛⬛⬛⬛" .. NEWLINE ..
        "⬜⬛⬛⬛⬛⬛⬜" .. NEWLINE ..
        "⬜⬜⬛⬛⬛⬜⬜" .. NEWLINE ..
        "⬜⬜⬜⬛⬜⬜⬜"
    chatMessage(heart)
end)

window:Button("Up Arrow", function()
    chatMessage(upArrow)
end)

window:Button("Down Arrow", function()
    chatMessage(downArrow)
end)
window:Button("Fake Error", function()
    chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 50) .. "[Server]: ERROR - Connection Lost. Retrying...")
end)

window:Button("Player Banned", function()
local rdmnumber = math.random(1,#game.Players:GetChildren())

for i,player in pairs(game.Players:GetChildren()) do
if rdmnumber == i then
getgenv().player = player.DisplayName
break
end
end
    chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 60) .. "[Server]: Player '"..getgenv().player.."' has been permanently banned.")
end)

window:Button("GG", function()
    chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 30) .. "[Server]: GG! Well played everyone.")
end)

window:Button("Victory", function()
    chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 50) .. "[Server]: Congratulations! Your team has won the round.")
end)

-- Cleanup
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    if drawingGui then
        drawingGui.Enabled = false
    end
end)


--[[ chatlogs ]]
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ContextActionService = game:GetService("ContextActionService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

local INVISIBLE_CHAR = "\u{001E}"
local NEWLINE = "\u{000D}"
local PRESET_FILE_NAME = "drawing_presets.json"

-- Create a table to store presets
local presets = {}

local function chatMessage(str)
    str = tostring(str)
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        TextChatService.TextChannels.RBXGeneral:SendAsync(str)
    else
        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str, "All")
    end
end

local function createButton(text, parent, size, position, backgroundColor)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = size
    button.Position = position
    button.BackgroundColor3 = backgroundColor or Color3.fromRGB(60, 60, 60)
    button.BorderSizePixel = 0
    button.Font = Enum.Font.GothamSemibold
    button.TextSize = 14
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.AutoButtonColor = true
    button.Parent = parent

    -- Create rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button

    -- Add hover effect
    local originalColor = button.BackgroundColor3
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = backgroundColor and backgroundColor:Lerp(Color3.fromRGB(255, 255, 255), 0.2) or Color3.fromRGB(80, 80, 80)
        }):Play()
    end)

    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.3), {
            BackgroundColor3 = originalColor
        }):Play()
    end)

    return button
end

local function addShadow(frame)
    local shadow = Instance.new("ImageLabel")
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://297774371"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.8
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame
end

local drawingGui = nil
local selectedEmoji = "❓"
local interfaceEnabled = false -- Keep track of the UI state
local savedGrid = {}  -- Table to store the grid between sessions
local actionBound = false -- Prevent double binding of ContextAction
local drawing = false


-- Function to save presets to a file
local function savePresetsToFile()
	local success, errorMessage = pcall(function()
		local jsonString = HttpService:JSONEncode(presets)
		writefile(PRESET_FILE_NAME, jsonString)
	end)
    if not success then
        warn("Error saving presets:", errorMessage)
    end
end

-- Function to load presets from a file
local function loadPresetsFromFile()
    local success, fileContent = pcall(function()
        return readfile(PRESET_FILE_NAME)
    end)
	
    if success and fileContent then
        local decodeSuccess, decodedData = pcall(function()
            return HttpService:JSONDecode(fileContent)
        end)
        
        if decodeSuccess and decodedData then
            presets = decodedData
        else
            warn("Error decoding presets: ", decodedData)
        end
    else
        warn("Error loading or reading the file:", fileContent)
    end
end

local function createDrawingInterface()
    local gui = Instance.new("ScreenGui")
    gui.Name = "DrawingInterface"
	gui.DisplayOrder = 2 -- Ensure it's on top
    gui.ResetOnSpawn = false -- Prevent reset on respawn
    gui.Parent = CoreGui

    local isTouchEnabled = UserInputService.TouchEnabled

    -- Determine scale based on platform
    local mainFrameScale = isTouchEnabled and 0.7 or 1
	
	local baseWidth = 300
	local baseHeight = 490
	local baseX = -150
	local baseY = -245

	
	local scaledWidth = baseWidth * mainFrameScale
	local scaledHeight = baseHeight * mainFrameScale
	local scaledX = baseX * mainFrameScale
	local scaledY = baseY * mainFrameScale


    local mainFrame = Instance.new("Frame")

    -- Main frame (matches dark theme in image)
    mainFrame.Size = UDim2.new(0, scaledWidth, 0, scaledHeight)  -- Increased height
    mainFrame.Position = UDim2.new(0.5, scaledX, 0.5, scaledY)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = gui

    -- Add rounded corners to main frame
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10 * mainFrameScale)
    corner.Parent = mainFrame

    addShadow(mainFrame)

     -- Title bar
    local titleBarHeight = 30 * mainFrameScale
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, titleBarHeight)
    titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame

    -- Add rounded corners to title bar
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10 * mainFrameScale)
    titleCorner.Parent = titleBar


     -- Title text
    local titleTextOffset = 10 * mainFrameScale
    local titleText = Instance.new("TextLabel")
    titleText.Text = "Drawing Interface"
    titleText.Size = UDim2.new(1, -40 * mainFrameScale, 1, 0)
    titleText.Position = UDim2.new(0, titleTextOffset, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Font = Enum.Font.Gotham
    titleText.TextSize = 14 * mainFrameScale
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = titleBar

    -- Close button (red X in corner)
    local closeButtonSize = 30 * mainFrameScale
    local closeButtonOffset = -30 * mainFrameScale
    local closeButton = createButton("X", titleBar, UDim2.new(0, closeButtonSize, 0, closeButtonSize), UDim2.new(1, closeButtonOffset, 0, 0), Color3.fromRGB(220, 50, 50))
    closeButton.MouseButton1Click:Connect(function()
        gui.Enabled = false
        interfaceEnabled = false
    end)

    -- Grid setup
    local GRID_SIZE = 7
    local CELL_SIZE = 35 * mainFrameScale
    local grid = {}
    local cells = {}
	
	local gridOffsetX = -(GRID_SIZE * CELL_SIZE) / 2
	local gridOffsetY = 40 * mainFrameScale

    local gridFrame = Instance.new("Frame")
    gridFrame.Size = UDim2.new(0, GRID_SIZE * CELL_SIZE, 0, GRID_SIZE * CELL_SIZE)
    gridFrame.Position = UDim2.new(0.5, gridOffsetX, 0, gridOffsetY)  -- Positioned below title
    gridFrame.BackgroundTransparency = 1
    gridFrame.Parent = mainFrame
	
	local function updateCell(cell, i, j)
        grid[i][j] = selectedEmoji
        cell.Text = selectedEmoji
        -- Add subtle animation
        local scaleUp = TweenService:Create(cell, TweenInfo.new(0.1), {Size = UDim2.new(0, CELL_SIZE, 0, CELL_SIZE)})
        local scaleDown = TweenService:Create(cell, TweenInfo.new(0.1), {Size = UDim2.new(0, CELL_SIZE - 2 * mainFrameScale, 0, CELL_SIZE - 2 * mainFrameScale)})
        scaleUp:Play()
        scaleUp.Completed:Connect(function()
            scaleDown:Play()
        end)
	end
    -- Create grid cells
    for i = 1, GRID_SIZE do
        grid[i] = {}
        cells[i] = {}
        for j = 1, GRID_SIZE do
			local cellOffsetX = (j - 1) * CELL_SIZE + 1 * mainFrameScale
			local cellOffsetY = (i - 1) * CELL_SIZE + 1 * mainFrameScale
            local cell = createButton("", gridFrame, UDim2.new(0, CELL_SIZE - 2 * mainFrameScale, 0, CELL_SIZE - 2 * mainFrameScale), UDim2.new(0, cellOffsetX, 0, cellOffsetY), Color3.fromRGB(45, 45, 45))
            cell.Font = Enum.Font.Gotham
            cell.TextSize = 20 * mainFrameScale
            cell.Text = ""

            grid[i][j] = ""
			cells[i][j] = cell
			
			cell.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					drawing = true
					updateCell(cell, i, j)
				end
			end)
			cell.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					if drawing then
						updateCell(cell, i, j)
					end
				end
			end)
			cell.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					drawing = false
				end
			end)
        end
    end
	

    -- Load saved grid
    if #savedGrid > 0 then
        for x = 1, GRID_SIZE do
            for y = 1, GRID_SIZE do
                grid[x][y] = savedGrid[x][y]
                gridFrame:GetChildren()[(x - 1) * GRID_SIZE + y].Text = savedGrid[x][y]
            end
        end
    end

    -- Emoji selector (with scrolling)
	local emojiScrollFrameHeight = 40 * mainFrameScale
	local emojiScrollFrameOffsetY = 295 * mainFrameScale

    local emojiScrollFrame = Instance.new("ScrollingFrame")
    emojiScrollFrame.Size = UDim2.new(0.95, 0, 0, emojiScrollFrameHeight)
    emojiScrollFrame.Position = UDim2.new(0.025, 0, 0, emojiScrollFrameOffsetY)  -- Positioned below grid
    emojiScrollFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    emojiScrollFrame.BorderSizePixel = 0
    emojiScrollFrame.ScrollBarThickness = 4 * mainFrameScale
    emojiScrollFrame.ScrollingDirection = Enum.ScrollingDirection.X
    emojiScrollFrame.Parent = mainFrame

    local emojiScrollFrameCorner = Instance.new("UICorner")
    emojiScrollFrameCorner.CornerRadius = UDim.new(0, 4 * mainFrameScale)
    emojiScrollFrameCorner.Parent = emojiScrollFrame
	
    local emojis = {"","⬜", "⬛", "🔲", "🔳", "🏮", "🔴", "🔵", "💜", "🤎", "❤️", "💛", "💚", "💙", "💖", "🧡", "🌸", "🌺", "🌻", "🌼", "🌷", "🌹", "📕", "📙", "📒", "📗", "📘", "📔", "📚", "📖", "❓", "❗", "💯", "🔥", "⭐", "✨", "🌙", "🌞", "☁️", "🌈", "🍕", "🍔", "🍟", "🍦", "🍩", "🍪", "☕", "🍺", "🍷", "🍸", "⚽", "🏀", "🏈", "⚾", "🎾", "🎮", "🎧", "🎵", "🎸", "🎻", "🎺", "🎷", "🎤", "🎨", "📷", "💡", "💻", "📱", "⏰", "🔒", "🔑", "🎁", "🎈", "🎉", "🎀", "📌", "📍", "🗺️", "✂️", "✏️", "✒️", "📝", "📖", "🔒", "🔔", "📞", "🛒", "💰", "💳", "💎", "🔨", "🔧", "🧰", "🧱", "🧲", "🧪", "🔬", "🔭", "🚑", "🚒", "🚓", "🚕", "🚗", "🚌", "🚲", "🚂", "✈️", "🚢", "🚀", "🛸", "🗿", "🚧", "🚦", "🛑", "🚫", "✅", "❌", "❓", "❗", "💯", "🔥", "⭐", "✨", "🌙", "🌞", "☁️", "🌈", "🍕", "🍔", "🍟", "🍦", "🍩", "🍪", "☕", "🍺", "🍷", "🍸", "⚽", "🏀", "🏈", "⚾", "🎾", "🎮", "🎧", "🎵", "🎸", "🎻", "🎺", "🎷", "🎤", "🎨", "📷", "💡", "💻", "📱", "⏰", "🔒", "🔑", "🎁", "🎈", "🎉", "🎀", "📌", "📍", "🗺️", "✂️", "✏️", "✒️", "📝", "📖", "🔒", "🔔", "📞", "🛒", "💰", "💳", "💎", "🔨", "🔧", "🧰", "🧱", "🧲", "🧪", "🔬", "🔭", "🚑", "🚒", "🚓", "🚕", "🚗", "🚌", "🚲", "🚂", "✈️", "🚢", "🚀", "🛸", "🗿", "🚧", "🚦", "🛑", "🚫", "✅", "❌"}
    local emojiButtons = {}

    -- Calculate total width needed for emoji buttons
    local totalWidth = #emojis * 35 * mainFrameScale
    emojiScrollFrame.CanvasSize = UDim2.new(0, totalWidth, 0, 0)
	
    for i, emoji in ipairs(emojis) do
		local emojiButtonOffsetX = (i - 1) * 35 * mainFrameScale + 5 * mainFrameScale
        local emojiButton = createButton(emoji, emojiScrollFrame, UDim2.new(0, 30 * mainFrameScale, 0, 30 * mainFrameScale), UDim2.new(0, emojiButtonOffsetX, 0, 5 * mainFrameScale), Color3.fromRGB(60, 60, 60))
        emojiButton.Font = Enum.Font.Gotham
        emojiButton.TextSize = 20 * mainFrameScale
        
        table.insert(emojiButtons, emojiButton)

        emojiButton.MouseButton1Click:Connect(function()
            selectedEmoji = emoji
            for _, btn in ipairs(emojiButtons) do
                btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            end
            emojiButton.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
        end)
    end

    -- Preset section
	local presetFrameHeight = 125 * mainFrameScale
    local presetFrameOffsetY = 340 * mainFrameScale
    local presetFrame = Instance.new("Frame")
    presetFrame.Size = UDim2.new(0.95, 0, 0, presetFrameHeight)
    presetFrame.Position = UDim2.new(0.025, 0, 0, presetFrameOffsetY)
    presetFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    presetFrame.BorderSizePixel = 0
    presetFrame.Parent = mainFrame

    local presetFrameCorner = Instance.new("UICorner")
    presetFrameCorner.CornerRadius = UDim.new(0, 6 * mainFrameScale)
    presetFrameCorner.Parent = presetFrame

    -- Preset input
	local presetInputHeight = 30 * mainFrameScale
	local presetInputOffsetY = 10 * mainFrameScale
	
    local presetInput = Instance.new("TextBox")
    presetInput.Size = UDim2.new(0.7, 0, 0, presetInputHeight)
    presetInput.Position = UDim2.new(0.025, 0, 0, presetInputOffsetY)
    presetInput.PlaceholderText = "Enter preset name..."
    presetInput.Text = ""
    presetInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    presetInput.BorderSizePixel = 0
    presetInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    presetInput.Font = Enum.Font.Gotham
    presetInput.TextSize = 14 * mainFrameScale
    presetInput.Parent = presetFrame

    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 4 * mainFrameScale)
    inputCorner.Parent = presetInput

    local savePresetButtonSize = 30 * mainFrameScale
    local savePresetButtonOffsetY = 10 * mainFrameScale
    local savePresetButton = createButton("Save", presetFrame, UDim2.new(0.225, 0, 0, savePresetButtonSize), UDim2.new(0.75, 0, 0, savePresetButtonOffsetY), Color3.fromRGB(70, 170, 70))
	
	-- Preset list
	local presetListHeight = 80 * mainFrameScale
	local presetListOffsetY = 45 * mainFrameScale
    local presetList = Instance.new("ScrollingFrame")
    presetList.Size = UDim2.new(0.95, 0, 0, presetListHeight)
    presetList.Position = UDim2.new(0.025, 0, 0, presetListOffsetY)
    presetList.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    presetList.BorderSizePixel = 0
    presetList.ScrollBarThickness = 4 * mainFrameScale
    presetList.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    presetList.ScrollBarImageTransparency = 0.5
    presetList.Parent = presetFrame

    local listCorner = Instance.new("UICorner")
    listCorner.CornerRadius = UDim.new(0, 4 * mainFrameScale)
    listCorner.Parent = presetList

    local function updatePresetList()
        for _, child in ipairs(presetList:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end

        local yOffset = 5 * mainFrameScale
        for i, presetData in ipairs(presets) do
            local name = presetData.name
            local preset = presetData.grid
            local presetButtonHeight = 25 * mainFrameScale
            local presetButton = createButton(name, presetList, UDim2.new(0.9, 0, 0, presetButtonHeight), UDim2.new(0.05, 0, 0, yOffset))

            -- Load preset
            presetButton.MouseButton1Click:Connect(function()
                for x = 1, GRID_SIZE do
                    for y = 1, GRID_SIZE do
                        grid[x][y] = preset[x][y]
                         gridFrame:GetChildren()[(x - 1) * GRID_SIZE + y].Text = preset[x][y]
                    end
                end
            end)
			
            -- Delete button
            local deleteButtonSize = 20 * mainFrameScale
            local deleteButtonOffsetX = -25 * mainFrameScale
            local deleteButtonOffsetY = 2 * mainFrameScale
            local deleteButton = createButton("X", presetButton, UDim2.new(0, deleteButtonSize, 0, deleteButtonSize), UDim2.new(1, deleteButtonOffsetX, 0, deleteButtonOffsetY), Color3.fromRGB(200, 50, 50))
            deleteButton.TextSize = 12 * mainFrameScale
            deleteButton.MouseButton1Click:Connect(function()
                table.remove(presets, i)
                updatePresetList()
                savePresetsToFile()
            end)

            yOffset = yOffset + 30 * mainFrameScale
        end

        presetList.CanvasSize = UDim2.new(0, 0, 0, yOffset)
    end
		
    savePresetButton.MouseButton1Click:Connect(function()
        local name = presetInput.Text
        if name ~= "" then
            local currentGrid = {}
            for x = 1, GRID_SIZE do
                currentGrid[x] = {}
                for y = 1, GRID_SIZE do
                    currentGrid[x][y] = grid[x][y]
                end
            end

            table.insert(presets, {name = name, grid = currentGrid})
            savePresetsToFile()
            presetInput.Text = ""
            updatePresetList()
        end
    end)

    -- Action buttons at bottom
	local actionButtonsHeight = 35 * mainFrameScale
	local actionButtonsOffsetY = 455 * mainFrameScale
	
    local actionButtons = Instance.new("Frame")
    actionButtons.Size = UDim2.new(0.95, 0, 0, actionButtonsHeight)
    actionButtons.Position = UDim2.new(0.025, 0, 0, actionButtonsOffsetY) -- Lowered action buttons
    actionButtons.BackgroundTransparency = 1
    actionButtons.Parent = mainFrame

    local sendButton = createButton("Send", actionButtons, UDim2.new(0.48, 0, 1, 0), UDim2.new(0, 0, 0, 0), Color3.fromRGB(70, 170, 70))
    sendButton.MouseButton1Click:Connect(function()
        local art = ""
        for x = 1, GRID_SIZE do
            for y = 1, GRID_SIZE do
                art = art .. (grid[x][y] ~= "" and grid[x][y] or "⬜")
            end
            if x < GRID_SIZE then
                art = art .. NEWLINE
            end
        end
        chatMessage(INVISIBLE_CHAR .. string.rep(NEWLINE, 8) .. art)
    end)

    local clearButton = createButton("Clear", actionButtons, UDim2.new(0.48, 0, 1, 0), UDim2.new(0.52, 0, 0, 0), Color3.fromRGB(170, 70, 70))
    clearButton.MouseButton1Click:Connect(function()
        for x = 1, GRID_SIZE do
            for y = 1, GRID_SIZE do
                grid[x][y] = ""
                gridFrame:GetChildren()[(x - 1) * GRID_SIZE + y].Text = ""
            end
        end
    end)

    -- Make the interface draggable
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        local position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)

        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        TweenService:Create(mainFrame, tweenInfo, {Position = position}):Play()
    end

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
	
	-- Save grid before the interface is disabled or reset
	gui.DescendantRemoving:Connect(function(descendant)
		if descendant == gui then
			savedGrid = {}
			for x = 1, GRID_SIZE do
				savedGrid[x] = {}
				for y = 1, GRID_SIZE do
					savedGrid[x][y] = grid[x][y]
				end
			end
		end
	end)


    -- Call updatePresetList here after the presetList has been created so it will render the list
    updatePresetList()

    return gui
end

-- Load the presets at the beginning
loadPresetsFromFile()

-- Initialize the GUI immediately when the script runs
drawingGui = createDrawingInterface()
drawingGui.Enabled = true
interfaceEnabled = true


-- Function to toggle the UI
local function toggleInterface()
    interfaceEnabled = not interfaceEnabled
    drawingGui.Enabled = interfaceEnabled
end


-- Bind the toggle action to a keypress (e.g., 'E' key)
local function actionToggle(actionName, inputState, inputObject)
    if inputState == Enum.UserInputState.Begin then
        toggleInterface()
    end
end

if not actionBound then
    ContextActionService:BindAction("ToggleDrawingUI", actionToggle, true, Enum.KeyCode.E)
    actionBound = true
end


--[[ annoyserver ]]
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- GUI Erstellung
local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local UICorner_MainFrame = Instance.new("UICorner") -- For rounded corners on the main frame
local CloseButton = Instance.new("TextButton")
local ToggleButton = Instance.new("TextButton")
local DragBar = Instance.new("Frame")
local Title = Instance.new("TextLabel")

-- GUI zum CoreGui hinzufügen
ScreenGui.Parent = game.CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Hauptframe (smaller & rounded)
MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
MainFrame.Position = UDim2.new(0.5, -75, 0.5, -50) -- shifted to center smaller frame
MainFrame.Size = UDim2.new(0, 150, 0, 100) -- reduced size (150x100 instead of 200x150)
MainFrame.BorderSizePixel = 0

UICorner_MainFrame.CornerRadius = UDim.new(0, 10)
UICorner_MainFrame.Parent = MainFrame

-- DragBar
DragBar.Name = "DragBar"
DragBar.Parent = MainFrame
DragBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
DragBar.Size = UDim2.new(1, 0, 0, 20) -- slightly smaller than original
DragBar.BorderSizePixel = 0

-- Titel
Title.Parent = DragBar
Title.BackgroundTransparency = 1
Title.Size = UDim2.new(1, -20, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.Font = Enum.Font.GothamBold
Title.Text = "Annoy Server"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 12 -- reduced text size
Title.TextXAlignment = Enum.TextXAlignment.Left

-- Close Button (smaller & rounded)
CloseButton.Parent = DragBar
CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
CloseButton.Position = UDim2.new(1, -18, 0, 2)
CloseButton.Size = UDim2.new(0, 15, 0, 15)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 10

local function ApplyRoundedCorners(button)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button
end
ApplyRoundedCorners(CloseButton)

-- Toggle Button (smaller & rounded)
ToggleButton.Parent = MainFrame
ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
ToggleButton.Position = UDim2.new(0.1, 0, 0.4, 0)
ToggleButton.Size = UDim2.new(0.8, 0, 0.3, 0)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = "ACTIVATE"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 14

ApplyRoundedCorners(ToggleButton)

-- Drag-Funktionalität (supports both mouse and touch)
local Dragging = false
local DragStart, StartPos

local function StartDrag(input)
    Dragging = true
    DragStart = input.Position
    StartPos = MainFrame.Position
end

local function UpdateDrag(input)
    if Dragging then
        local delta = input.Position - DragStart
        MainFrame.Position = UDim2.new(
            StartPos.X.Scale,
            StartPos.X.Offset + delta.X,
            StartPos.Y.Scale,
            StartPos.Y.Offset + delta.Y
        )
    end
end

local function StopDrag()
    Dragging = false
end

DragBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        UpdateDrag(input)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StopDrag()
    end
end)

--------------------------------------------------------------------------------
-- Variablen und Keyframe-System (unverändert)
local BodyLifted = false
local UpdateConnection = nil
local originalPositions = {}      -- Speichert die ursprünglichen CFrames der Körperteile (inkl. Y-Rotation)
local currentKeyframe = 1
local animationTime = 0
local lastKeyframeTime = 0
local nearestTargetPlayers = {}
local farthestTargetPlayers = {}
local randomTargetPlayers = {}
local initialHumanoidRootPartCFrame = nil -- Ursprünglicher CFrame des HumanoidRootPart (mit Y-Achse)

-- Keyframe System
local keyframes = {
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "ad0",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(101, 3, -2152),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(101, 15, -2150002),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(101, -3.2, -2150002),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(999999, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(-10000000, 15, 25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(-10000000, 15, -25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(10000000, 15, 25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(10000000, 15, -25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            }
        }
    },
    {
        duration = 0.1,
        config = {
            Humanoid = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "ad0",
                matchTargetPart = false
            },
            Head = {
                position = Vector3.new(101, 3, -2152),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            UpperTorso = {
                position = Vector3.new(101, -3.2, -2150002),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LowerTorso = {
                position = Vector3.new(101, 7, -2150002),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftUpperArm = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftLowerArm = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftHand = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightUpperArm = {
                position = Vector3.new(999999, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightLowerArm = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightHand = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftUpperLeg = {
                position = Vector3.new(-10000000, 15, 25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftLowerLeg = {
                position = Vector3.new(-10000000, 15, -25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            LeftFoot = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightUpperLeg = {
                position = Vector3.new(10000000, 15, 25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightLowerLeg = {
                position = Vector3.new(10000000, 15, -25000000),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            },
            RightFoot = {
                position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                targetPlayer = "",
                matchTargetPart = true
            }
        }
    },
}

local bodyParts = {}
for partName, _ in pairs(keyframes[1].config) do
    table.insert(bodyParts, partName)
end

local function LerpVector3(start, target, alpha)
    return start:Lerp(target, alpha)
end

local function FindPlayerByPartialName(partialName, partName)
    if partialName == "nearest" then
        if nearestTargetPlayers[partName] then
            return nearestTargetPlayers[partName]
        else
            local localPlayer = Players.LocalPlayer
            local localCharacter = localPlayer.Character
            if not localCharacter then return nil end
            local localHumanoidRootPart = localCharacter:FindFirstChild("HumanoidRootPart")
            if not localHumanoidRootPart then return nil end

            local nearestPlayer = nil
            local nearestDistance = math.huge
            
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    local character = player.Character
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local distance = (localHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if distance < nearestDistance then
                                nearestDistance = distance
                                nearestPlayer = player
                            end
                        end
                    end
                end
            end
            nearestTargetPlayers[partName] = nearestPlayer
            return nearestPlayer
        end
    elseif partialName == "farthest" then
        if farthestTargetPlayers[partName] then
            return farthestTargetPlayers[partName]
        else
            local localPlayer = Players.LocalPlayer
            local localCharacter = localPlayer.Character
            if not localCharacter then return nil end
            local localHumanoidRootPart = localCharacter:FindFirstChild("HumanoidRootPart")
            if not localHumanoidRootPart then return nil end

            local farthestPlayer = nil
            local farthestDistance = -math.huge
            
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    local character = player.Character
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local distance = (localHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if distance > farthestDistance then
                                farthestDistance = distance
                                farthestPlayer = player
                            end
                        end
                    end
                end
            end
            farthestTargetPlayers[partName] = farthestPlayer
            return farthestPlayer
        end
    elseif partialName == "random" then
        if randomTargetPlayers[partName] then
            return randomTargetPlayers[partName]
        else
            local allPlayers = Players:GetPlayers()
            local validPlayers = {}
            for _, player in ipairs(allPlayers) do
                if player ~= Players.LocalPlayer then
                    table.insert(validPlayers, player)
                end
            end
            if #validPlayers > 0 then
                local randomIndex = math.random(1, #validPlayers)
                local randomPlayer = validPlayers[randomIndex]
                randomTargetPlayers[partName] = randomPlayer
                return randomPlayer
            end
            return nil
        end
    end
    
    partialName = partialName:lower()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Name:lower():find(partialName) or (player.DisplayName and player.DisplayName:lower():find(partialName)) then
            return player
        end
    end
    return nil
end

-- Drag-Funktionalität der GUI
DragBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        Dragging = true
        DragStart = input.Position
        StartPos = MainFrame.Position
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if Dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - DragStart
        MainFrame.Position = UDim2.new(
            StartPos.X.Scale,
            StartPos.X.Offset + delta.X,
            StartPos.Y.Scale,
            StartPos.Y.Offset + delta.Y
        )
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        Dragging = false
    end
end)

--------------------------------------------------------------------------------
-- SPEICHERN DER URSPRÜNGLICHEN POSITIONEN UND ROTATIONEN
local function SaveOriginalPositions()
    local character = Players.LocalPlayer.Character
    if character then
        for partName, _ in pairs(keyframes[1].config) do
            if partName ~= "Humanoid" then
                local part = character:FindFirstChild(partName)
                if part then
                    originalPositions[partName] = part.CFrame
                end
            end
        end
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            initialHumanoidRootPartCFrame = humanoidRootPart.CFrame
        end
    end
end

--------------------------------------------------------------------------------
-- AKTUALISIEREN EINER EINZELNEN KÖRPERTEIL-POSITION
local function UpdateBodyPart(character, partName, currentConfig, nextConfig, alpha)
    local part = character:FindFirstChild(partName)
    if part and BodyLifted and partName ~= "Humanoid" then
        local baseCFrame = originalPositions[partName]
        if baseCFrame then
            local currentTargetCFrame = baseCFrame
            local nextTargetCFrame = baseCFrame
            
            if currentConfig.targetPlayer and currentConfig.targetPlayer ~= "" then
                local currentPlayer = FindPlayerByPartialName(currentConfig.targetPlayer, partName)
                if currentPlayer and currentPlayer.Character then
                    if currentConfig.matchTargetPart then
                        local targetPart = currentPlayer.Character:FindFirstChild(partName)
                        if targetPart then
                            currentTargetCFrame = CFrame.new(targetPart.Position)
                        end
                    else
                        local targetHumanoidRootPart = currentPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if targetHumanoidRootPart then
                            currentTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                        end
                    end
                end
            else
                currentTargetCFrame = CFrame.new(baseCFrame.Position)
            end
            
            if nextConfig.targetPlayer and nextConfig.targetPlayer ~= "" then
                local nextPlayer = FindPlayerByPartialName(nextConfig.targetPlayer, partName)
                if nextPlayer and nextPlayer.Character then
                    if nextConfig.matchTargetPart then
                        local targetPart = nextPlayer.Character:FindFirstChild(partName)
                        if targetPart then
                            nextTargetCFrame = CFrame.new(targetPart.Position)
                        end
                    else
                        local targetHumanoidRootPart = nextPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if targetHumanoidRootPart then
                            nextTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                        end
                    end
                end
            else
                nextTargetCFrame = CFrame.new(baseCFrame.Position)
            end
            
            local currentOffset = CFrame.new(currentConfig.position) *
                CFrame.Angles(
                    math.rad(currentConfig.rotation.X),
                    math.rad(currentConfig.rotation.Y),
                    math.rad(currentConfig.rotation.Z)
                )
            local nextOffset = CFrame.new(nextConfig.position) *
                CFrame.Angles(
                    math.rad(nextConfig.rotation.X),
                    math.rad(nextConfig.rotation.Y),
                    math.rad(nextConfig.rotation.Z)
                )
            
            local finalCurrentCFrame = currentTargetCFrame * currentOffset
            local finalNextCFrame = nextTargetCFrame * nextOffset
            local finalCFrame = finalCurrentCFrame:Lerp(finalNextCFrame, alpha)
            
            local _, origYaw, _ = baseCFrame:ToOrientation()
            finalCFrame = CFrame.new(finalCFrame.Position) * CFrame.Angles(0, origYaw, 0)
            
            part.CFrame = finalCFrame
            part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        end
    end
end

--------------------------------------------------------------------------------
-- AKTUALISIEREN DES HUMANOID (bzw. des HumanoidRootPart)
local function UpdateHumanoid(character, currentConfig, nextConfig, alpha)
    local humanoid = character:FindFirstChild("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoid and humanoidRootPart and initialHumanoidRootPartCFrame then
        local currentTargetCFrame = initialHumanoidRootPartCFrame
        local nextTargetCFrame = initialHumanoidRootPartCFrame
        
        if currentConfig.targetPlayer and currentConfig.targetPlayer ~= "" then
            local currentPlayer = FindPlayerByPartialName(currentConfig.targetPlayer, "Humanoid")
            if currentPlayer and currentPlayer.Character then
                local targetHumanoidRootPart = currentPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    currentTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                end
            end
        else
            currentTargetCFrame = CFrame.new(initialHumanoidRootPartCFrame.Position)
        end
        
        if nextConfig.targetPlayer and nextConfig.targetPlayer ~= "" then
            local nextPlayer = FindPlayerByPartialName(nextConfig.targetPlayer, "Humanoid")
            if nextPlayer and nextPlayer.Character then
                local targetHumanoidRootPart = nextPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    nextTargetCFrame = CFrame.new(targetHumanoidRootPart.Position)
                end
            end
        else
            nextTargetCFrame = CFrame.new(initialHumanoidRootPartCFrame.Position)
        end
        
        local currentOffset = CFrame.new(currentConfig.position) *
            CFrame.Angles(
                math.rad(currentConfig.rotation.X),
                math.rad(currentConfig.rotation.Y),
                math.rad(currentConfig.rotation.Z)
            )
        local nextOffset = CFrame.new(nextConfig.position) *
            CFrame.Angles(
                math.rad(nextConfig.rotation.X),
                math.rad(nextConfig.rotation.Y),
                math.rad(nextConfig.rotation.Z)
            )
        
        local finalCurrentCFrame = currentTargetCFrame * currentOffset
        local finalNextCFrame = nextTargetCFrame * nextOffset
        local finalCFrame = finalCurrentCFrame:Lerp(finalNextCFrame, alpha)
        
        local _, origYaw, _ = initialHumanoidRootPartCFrame:ToOrientation()
        finalCFrame = CFrame.new(finalCFrame.Position) * CFrame.Angles(0, origYaw, 0)
        
        humanoidRootPart.CFrame = finalCFrame
        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        humanoid.WalkSpeed = 16
    end
end

--------------------------------------------------------------------------------
-- BODY UPDATE FUNKTION (wird jeden Heartbeat aufgerufen)
local function UpdateBody()
    local character = Players.LocalPlayer.Character
    if character and BodyLifted then
        local humanoid = character:FindFirstChild("Humanoid")
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoid and humanoidRootPart and initialHumanoidRootPartCFrame then
            local deltaTime = tick() - lastKeyframeTime
            animationTime = animationTime + deltaTime
            lastKeyframeTime = tick()
            
            local currentFrame = keyframes[currentKeyframe]
            local nextFrame = keyframes[currentKeyframe + 1]
            if not nextFrame then
                nextFrame = keyframes[1]
            end
            
            local alpha = math.min(animationTime / currentFrame.duration, 1)
            
            for partName, _ in pairs(currentFrame.config) do
                UpdateBodyPart(character, partName, currentFrame.config[partName], nextFrame.config[partName], alpha)
            end
            if currentFrame.config.Humanoid then
                UpdateHumanoid(character, currentFrame.config.Humanoid, nextFrame.config.Humanoid, alpha)
            end
            if alpha >= 1 then
                currentKeyframe = currentKeyframe + 1
                if currentKeyframe > #keyframes then
                    currentKeyframe = 1
                end
                animationTime = 0
            end
        end
    end
end

--------------------------------------------------------------------------------
-- FUNKTION ZUM SICHEREN DEAKTIVIERENS DES RAGDOLLS
local function SafeDeactivateRagdoll()
    for i = 1, 3 do
        ReplicatedStorage.UnragdollEvent:FireServer()
        task.wait(0.1)
    end
    
    local character = Players.LocalPlayer.Character
    if character then
        for partName, _ in pairs(keyframes[1].config) do
            if partName ~= "Humanoid" then
                local part = character:FindFirstChild(partName)
                if part and originalPositions[partName] then
                    part.CFrame = originalPositions[partName]
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end
        end
    end
    
    nearestTargetPlayers = {}
    farthestTargetPlayers = {}
    randomTargetPlayers = {}
    initialHumanoidRootPartCFrame = nil
end

--------------------------------------------------------------------------------
-- TOGGLE BUTTON FUNKTIONALITÄT
ToggleButton.MouseButton1Click:Connect(function()
    BodyLifted = not BodyLifted
    
    if BodyLifted then
        ToggleButton.Text = "DEACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
        
        SaveOriginalPositions()
        currentKeyframe = 1
        animationTime = 0
        lastKeyframeTime = tick()
        
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        UpdateConnection = RunService.Heartbeat:Connect(UpdateBody)
        
        ReplicatedStorage.RagdollEvent:FireServer()
    else
        ToggleButton.Text = "ACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
        
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        
        SafeDeactivateRagdoll()
    end
end)

--------------------------------------------------------------------------------
-- CLOSE BUTTON (beendet das Script)
CloseButton.MouseButton1Click:Connect(function()
    if BodyLifted then
        BodyLifted = false
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        SafeDeactivateRagdoll()
    end
    ScreenGui:Destroy()
end)

--------------------------------------------------------------------------------
-- RESET beim Respawn
Players.LocalPlayer.CharacterAdded:Connect(function()
    if BodyLifted then
        BodyLifted = false
        if UpdateConnection then
            UpdateConnection:Disconnect()
        end
        ToggleButton.Text = "ACTIVATE"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(45, 180, 45)
        
        SafeDeactivateRagdoll()
    end
end)


--[[ fling all ]]
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Blacklist and Settings
local Blacklist, kroneUserids = {}, {4710732523, 354902977}
local Settings = {Distance = 18, Globals = {"Executions", "List"}}
local WhitelistedPlayers = {}

-- Script State Variables
local scriptEnabled = false
local targetPlayers = {} -- Table to store multiple targets
local viewingPlayers = {} -- Track players being viewed
local SavedPosition = nil
local SavedCamera = nil
local CF = nil

-- Enhanced UI Colors
local Colors = {
    Background = Color3.fromRGB(25, 25, 35),
    Primary = Color3.fromRGB(40, 40, 60),
    Accent = Color3.fromRGB(0, 120, 215),
    Text = Color3.fromRGB(230, 230, 240),
    Highlight = Color3.fromRGB(0, 180, 240)
}

-- GUI Creation
local function createEnhancedUI()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    if game:GetService("RunService"):IsStudio() then
        ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    else
        ScreenGui.Parent = game:GetService("CoreGui")
    end

    -- Main Frame (Draggable)
    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 150, 0, 50) -- Smaller size
    MainFrame.Position = UDim2.new(0.5, -75, 0.05, 0) -- Adjusted position
    MainFrame.BackgroundColor3 = Colors.Background
    MainFrame.Active = true
    MainFrame.Draggable = true
    MainFrame.Parent = ScreenGui

    local MainFrameCorner = Instance.new("UICorner")
    MainFrameCorner.CornerRadius = UDim.new(0, 10)
    MainFrameCorner.Parent = MainFrame

    local MainFrameStroke = Instance.new("UIStroke")
    MainFrameStroke.Color = Colors.Accent
    MainFrameStroke.Thickness = 2
    MainFrameStroke.Parent = MainFrame

    -- Toggle and Target Buttons Frame
    local ToggleTargetFrame = Instance.new("Frame")
    ToggleTargetFrame.Size = UDim2.new(1, 0, 1, 0)
    ToggleTargetFrame.BackgroundColor3 = Colors.Primary
    ToggleTargetFrame.Parent = MainFrame

    local ToggleTargetFrameCorner = Instance.new("UICorner")
    ToggleTargetFrameCorner.CornerRadius = UDim.new(0, 8)
    ToggleTargetFrameCorner.Parent = ToggleTargetFrame

    -- Toggle Button
    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Size = UDim2.new(0.7, 0, 1, 0)
    ToggleButton.BackgroundColor3 = Colors.Primary
    ToggleButton.Text = "Fling: OFF"
    ToggleButton.TextColor3 = Colors.Text
    ToggleButton.Font = Enum.Font.GothamBold
    ToggleButton.TextSize = 12
    ToggleButton.Parent = ToggleTargetFrame
    
    local ToggleButtonCorner = Instance.new("UICorner")
    ToggleButtonCorner.CornerRadius = UDim.new(0, 8)
    ToggleButtonCorner.Parent = ToggleButton
    
    
     -- Target Button
    local TargetButton = Instance.new("TextButton")
    TargetButton.Size = UDim2.new(0.3, 0, 1, 0)
    TargetButton.Position = UDim2.new(0.7, 0, 0, 0)
    TargetButton.BackgroundColor3 = Colors.Primary
    TargetButton.Text = "🎯"
    TargetButton.TextColor3 = Colors.Text
    TargetButton.Font = Enum.Font.GothamBold
    TargetButton.TextSize = 12
    TargetButton.Parent = ToggleTargetFrame
    
    local TargetButtonCorner = Instance.new("UICorner")
    TargetButtonCorner.CornerRadius = UDim.new(0, 8)
    TargetButtonCorner.Parent = TargetButton
    
    -- Player List Frame
    local PlayerListFrame = Instance.new("Frame")
    PlayerListFrame.Size = UDim2.new(0, 200, 0, 300) -- Smaller size
    PlayerListFrame.Position = UDim2.new(0.5, -100, 0.5, -150) -- Adjusted position
    PlayerListFrame.BackgroundColor3 = Colors.Background
    PlayerListFrame.Visible = false
    PlayerListFrame.Active = true
    PlayerListFrame.Draggable = true
    PlayerListFrame.Parent = ScreenGui

    local PlayerListCorner = Instance.new("UICorner")
    PlayerListCorner.CornerRadius = UDim.new(0, 10)
    PlayerListCorner.Parent = PlayerListFrame

    local PlayerListStroke = Instance.new("UIStroke")
    PlayerListStroke.Color = Colors.Accent
    PlayerListStroke.Thickness = 2
    PlayerListStroke.Parent = PlayerListFrame

    -- Player List Title
    local PlayerListTitle = Instance.new("TextLabel")
    PlayerListTitle.Size = UDim2.new(1, 0, 0, 30) -- Smaller size
    PlayerListTitle.BackgroundColor3 = Colors.Primary
    PlayerListTitle.Text = "Select Target Player"
    PlayerListTitle.TextColor3 = Colors.Text
    PlayerListTitle.Font = Enum.Font.GothamBold
    PlayerListTitle.TextSize = 14
    PlayerListTitle.Parent = PlayerListFrame

    local PlayerListTitleCorner = Instance.new("UICorner")
    PlayerListTitleCorner.CornerRadius = UDim.new(0, 10)
    PlayerListTitleCorner.Parent = PlayerListTitle

    -- Scrolling Frame
    local PlayerScrollFrame = Instance.new("ScrollingFrame")
    PlayerScrollFrame.Size = UDim2.new(1, -10, 1, -40) -- Adjusted size
    PlayerScrollFrame.Position = UDim2.new(0, 5, 0, 35) -- Adjusted position
    PlayerScrollFrame.BackgroundTransparency = 1
    PlayerScrollFrame.ScrollBarThickness = 5
    PlayerScrollFrame.Parent = PlayerListFrame
    PlayerScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- initialize canvas size to 0,0

    local PlayerListLayout = Instance.new("UIListLayout")
    PlayerListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    PlayerListLayout.Padding = UDim.new(0, 5)
    PlayerListLayout.Parent = PlayerScrollFrame

    return {
        ScreenGui = ScreenGui,
        MainFrame = MainFrame,
        ToggleButton = ToggleButton,
		TargetButton = TargetButton,
        PlayerListFrame = PlayerListFrame,
        PlayerScrollFrame = PlayerScrollFrame,
		PlayerListLayout = PlayerListLayout,
        ToggleTargetFrame = ToggleTargetFrame
    }
end

local UI = createEnhancedUI()

-- Player Entry Creation Function
local function createPlayerEntry(player)
    local PlayerFrame = Instance.new("Frame")
    PlayerFrame.Size = UDim2.new(1, 0, 0, 30)
    PlayerFrame.BackgroundColor3 = Colors.Primary
    PlayerFrame.Parent = UI.PlayerScrollFrame

    local PlayerFrameCorner = Instance.new("UICorner")
    PlayerFrameCorner.CornerRadius = UDim.new(0, 6)
    PlayerFrameCorner.Parent = PlayerFrame

    local PlayerButton = Instance.new("TextButton")
    PlayerButton.Size = UDim2.new(0.7, 0, 1, 0)
    PlayerButton.Position = UDim2.new(0.05,0,0,0)
    PlayerButton.BackgroundColor3 = Colors.Primary
    PlayerButton.Text = ""
    PlayerButton.TextColor3 = Colors.Text
    PlayerButton.Font = Enum.Font.GothamMedium
    PlayerButton.TextSize = 10
    PlayerButton.TextXAlignment = Enum.TextXAlignment.Left
    PlayerButton.Parent = PlayerFrame

    local PlayerButtonCorner = Instance.new("UICorner")
    PlayerButtonCorner.CornerRadius = UDim.new(0, 6)
    PlayerButtonCorner.Parent = PlayerButton

    local PlayerThumbnail = Instance.new("ImageLabel")
    PlayerThumbnail.Size = UDim2.new(0, 20, 0, 20)
    PlayerThumbnail.Position = UDim2.new(0, 5, 0.5, -10)
    PlayerThumbnail.BackgroundTransparency = 1
    PlayerThumbnail.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48)
    PlayerThumbnail.Parent = PlayerButton

    local PlayerNameLabel = Instance.new("TextLabel")
    PlayerNameLabel.Size = UDim2.new(1, -40, 1, 0)
    PlayerNameLabel.Position = UDim2.new(0, 30, 0, 0)
    PlayerNameLabel.BackgroundTransparency = 1
    PlayerNameLabel.TextColor3 = Colors.Text
    PlayerNameLabel.Font = Enum.Font.GothamMedium
    PlayerNameLabel.TextSize = 10
    PlayerNameLabel.TextXAlignment = Enum.TextXAlignment.Left
    PlayerNameLabel.Text = player.Name
    PlayerNameLabel.Parent = PlayerButton

    local ViewButton = Instance.new("TextButton")
    ViewButton.Size = UDim2.new(0.3, 0, 1, 0)
    ViewButton.Position = UDim2.new(0.7, 0, 0, 0)
    ViewButton.BackgroundColor3 = Colors.Primary
    ViewButton.Text = "👁️"
    ViewButton.TextColor3 = Colors.Text
    ViewButton.Font = Enum.Font.GothamBold
    ViewButton.TextSize = 10
    ViewButton.Parent = PlayerFrame

    local ViewButtonCorner = Instance.new("UICorner")
    ViewButtonCorner.CornerRadius = UDim.new(0, 6)
    ViewButtonCorner.Parent = ViewButton

     PlayerButton.MouseButton1Click:Connect(function()
        if table.find(targetPlayers, player) then
            table.remove(targetPlayers, table.find(targetPlayers, player))
            PlayerButton.BackgroundColor3 = Colors.Primary
        else
            table.insert(targetPlayers, player)
            PlayerButton.BackgroundColor3 = Colors.Highlight
        end
    end)

    ViewButton.MouseButton1Click:Connect(function()
        if table.find(viewingPlayers, player) then
           table.remove(viewingPlayers, table.find(viewingPlayers, player))
           ViewButton.BackgroundColor3 = Colors.Primary
           if workspace.CurrentCamera.CameraSubject == player.Character:FindFirstChild("Head") then
              workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
           end
       else
           table.insert(viewingPlayers, player)
           ViewButton.BackgroundColor3 = Colors.Highlight
       end
   end)

    return PlayerFrame
end

-- Player List Management
local playerEntries = {}
local function updatePlayerList()
    local players = Players:GetPlayers()
    local totalHeight = 0

    -- Add new players
    for _, player in ipairs(players) do
        if player ~= LocalPlayer and not playerEntries[player] then
            local playerEntry = createPlayerEntry(player)
            playerEntries[player] = playerEntry
        end
    end

     -- Remove old players
    for player, entry in pairs(playerEntries) do
        local found = false
        for _, p in ipairs(players) do
            if p == player then
                found = true
                break
            end
        end
        if not found then
           entry:Destroy()
           playerEntries[player] = nil
        end
    end
    
     for _, entry in pairs(UI.PlayerScrollFrame:GetChildren()) do
        if entry:IsA("Frame") then
             totalHeight = totalHeight + entry.AbsoluteSize.Y + UI.PlayerListLayout.Padding.Offset
         end
     end

  local frameHeight = UI.PlayerScrollFrame.AbsoluteSize.Y
  if totalHeight > frameHeight then
        UI.PlayerScrollFrame.CanvasSize = UDim2.new(0,0,0, totalHeight) -- makes it scrollable
    else
        UI.PlayerScrollFrame.CanvasSize = UDim2.new(0,0,0,0) -- if not many players make not scrollable
    end
end

-- Fling Function
local function shhhlol(TargetPlayer)
    local Character = LocalPlayer.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid.RootPart

    local im = TargetPlayer.Character
    local so = im:FindFirstChildOfClass("Humanoid")
    local sorry = so and so.RootPart
    local please = im:FindFirstChild("Head")

    if Character and Humanoid and RootPart then
       
        if not im:FindFirstChildWhichIsA("BasePart") then return end

        local function mmmm(comkid, Pos, Ang)
            RootPart.CFrame = CFrame.new(comkid.Position) * Pos * Ang
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end

        local function wtf(comkid)
            local TimeToWait = 0.134
            local Time = tick()
            
            local Att1 = Instance.new("Attachment", RootPart)
            local Att2 = Instance.new("Attachment", sorry)

            repeat
                if RootPart and so then
                    if comkid.Velocity.Magnitude < 30 then
                        mmmm(
                            comkid,
                            CFrame.new(0, 1.5, 0) + so.MoveDirection * comkid.Velocity.Magnitude / 5,
                            CFrame.Angles(
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180),
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180),
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180)
                            )
                        )
                        RunService.Heartbeat:wait()

                        mmmm(
                            comkid,
                            CFrame.new(0, 1.5, 0) + so.MoveDirection * comkid.Velocity.Magnitude / 1.25,
                            CFrame.Angles(
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180),
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180),
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180)
                            )
                        )
                        RunService.Heartbeat:wait()

                        mmmm(
                            comkid,
                            CFrame.new(0, -1.5, 0) + so.MoveDirection * comkid.Velocity.Magnitude / 1.25,
                            CFrame.Angles(
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180),
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180),
                                math.random(1, 2) == 1 and math.rad(0) or math.rad(180)
                            )
                        )
                        RunService.Heartbeat:wait()
                    else
                        mmmm(comkid, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(0), 0, 0))
                        RunService.Heartbeat:wait()
                    end
                else
                    break
                end
            until comkid.Velocity.Magnitude > 1000 or 
                  comkid.Parent ~= TargetPlayer.Character or
                  TargetPlayer.Parent ~= Players or
                  not TargetPlayer.Character == im or
                  Humanoid.Health <= 0 or
                  tick() > Time + TimeToWait or
                  not scriptEnabled

            Att1:Destroy()
            Att2:Destroy()
            
            if game.PlaceId == 417267366 then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(5524, 36, -17126.50)
            else
                LocalPlayer.Character.HumanoidRootPart.CFrame = SavedPosition or CF
            end
        end

        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(-9e99, 9e99, -9e99)
        BV.MaxForce = Vector3.new(-9e9, 9e9, -9e9)

        local BodyGyro = Instance.new("BodyGyro")
        BodyGyro.CFrame = CFrame.new(LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position)
        BodyGyro.D = 9e8
        BodyGyro.MaxTorque = Vector3.new(-9e9, 9e9, -9e9)
        BodyGyro.P = -9e9

        local BodyPosition = Instance.new("BodyPosition")
        BodyPosition.Position = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
        BodyPosition.D = 9e8
        BodyPosition.MaxForce = Vector3.new(-9e9, 9e9, -9e9)
        BodyPosition.P = -9e9

        if sorry and please then
            if (sorry.CFrame.p - please.CFrame.p).Magnitude > 5 then
                wtf(please)
            else
                wtf(sorry)
            end
        elseif sorry and not please then
            wtf(sorry)
        elseif not sorry and please then
            wtf(please)
        end

        BV:Destroy()
        BodyGyro:Destroy()
        BodyPosition:Destroy()
        
        for _, x in next, Character:GetDescendants() do
            if x:IsA("BasePart") then
                x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
            end
        end
        
        Humanoid:ChangeState("GettingUp")
     end
end

-- Enable Script Function
local function enableScript()
    coroutine.wrap(function()
        while scriptEnabled do
            pcall(function()
                if #targetPlayers > 0 then
                    for _, player in ipairs(targetPlayers) do
                        if LocalPlayer.Character and 
                           LocalPlayer.Character:FindFirstChildOfClass("Humanoid") and 
                           player and player.Character and
                            player.Character:FindFirstChildOfClass("Humanoid") then
                            local Humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                            local RootPart = Humanoid.RootPart
                             if RootPart and Humanoid.Sit == false and RootPart.Velocity.Magnitude < 30 then
                                shhhlol(player)
                            end
                         end
                    end
                else
                    for _, z in pairs(Players:GetPlayers()) do
                        if z ~= LocalPlayer and not table.find(WhitelistedPlayers, tostring(z.UserId)) then
                             if LocalPlayer.Character and 
                               LocalPlayer.Character:FindFirstChildOfClass("Humanoid") and 
                               z and z.Character and
                               z.Character:FindFirstChildOfClass("Humanoid") then
                                local Humanoid = z.Character:FindFirstChildOfClass("Humanoid")
                                local RootPart = Humanoid.RootPart
                                 if RootPart and Humanoid.Sit == false and RootPart.Velocity.Magnitude < 30 then
                                    shhhlol(z)
                                end
                             end
                        end
                    end
                end
                if scriptEnabled then
                    for _, player in ipairs(viewingPlayers) do
                        if player and player.Character and player.Character:FindFirstChild("Head") then
                           workspace.CurrentCamera.CameraSubject = player.Character:FindFirstChild("Head")
                        end
                    end
                else
                  workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                 end
            end)
            wait()
        end
    end)()
end

-- Event Connections
UI.ToggleButton.MouseButton1Click:Connect(function()
    scriptEnabled = not scriptEnabled

    if scriptEnabled then
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            SavedPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
            SavedCamera = workspace.CurrentCamera.CFrame
        end
        
        UI.ToggleButton.Text = "Fling: ON"
        UI.ToggleButton.BackgroundColor3 = Colors.Highlight
        enableScript()
    else
        wait(0.1)
        if SavedPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = SavedPosition
        end
        
        -- Restore camera position
        if SavedCamera then
            workspace.CurrentCamera.CFrame = SavedCamera
        end
         for _, player in ipairs(viewingPlayers) do
             if player and player.Character and player.Character:FindFirstChild("Head") then
                 workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                 table.remove(viewingPlayers, table.find(viewingPlayers, player))
            end
         end
        UI.ToggleButton.Text = "Fling: OFF"
        UI.ToggleButton.BackgroundColor3 = Colors.Primary
    end
end)

UI.TargetButton.MouseButton1Click:Connect(function()
    UI.PlayerListFrame.Visible = not UI.PlayerListFrame.Visible
    updatePlayerList()
end)

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
      local playerEntry = createPlayerEntry(player)
      playerEntries[player] = playerEntry
        updatePlayerList()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if playerEntries[player] then
        playerEntries[player]:Destroy()
        playerEntries[player] = nil
    end
     updatePlayerList()
end)

-- Initialize
updatePlayerList()


--[[ shlow ]]
-- Auto Teleport to Lowest Population Server Script (With Minimum Players)
-- This script automatically teleports the player to the server with the lowest player count
-- while ensuring there's a minimum number of players and avoiding servers they've previously visited
-- If teleport fails, it automatically tries the next best server

local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- File to store visited server IDs (saved to player's machine)
local visitedServersFileName = "VisitedServers_" .. game.PlaceId .. ".json"
local minimumPlayers = 2 -- Minimum players needed in the server (set to 0 for completely empty)
local maxRetries = 5 -- Maximum number of servers to try if teleports fail
local keepSearching = true -- Will continue searching until a suitable server is found

-- Create a small status GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "TeleportStatusGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = game:GetService("CoreGui")

-- Status Frame
local StatusFrame = Instance.new("Frame")
StatusFrame.Name = "StatusFrame"
StatusFrame.Size = UDim2.new(0, 250, 0, 80)
StatusFrame.Position = UDim2.new(0.5, -125, 0.15, 0)
StatusFrame.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
StatusFrame.BorderSizePixel = 0
StatusFrame.Parent = ScreenGui

local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(0, 8)
StatusCorner.Parent = StatusFrame

-- Status Text
local StatusText = Instance.new("TextLabel")
StatusText.Name = "StatusText"
StatusText.Size = UDim2.new(1, -20, 1, -10)
StatusText.Position = UDim2.new(0, 10, 0, 5)
StatusText.BackgroundTransparency = 1
StatusText.Text = "Finding emptiest server..."
StatusText.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusText.TextSize = 14
StatusText.Font = Enum.Font.SourceSans
StatusText.TextWrapped = true
StatusText.TextYAlignment = Enum.TextYAlignment.Top
StatusText.Parent = StatusFrame

-- Progress Bar
local ProgressBarFrame = Instance.new("Frame")
ProgressBarFrame.Name = "ProgressBarFrame"
ProgressBarFrame.Size = UDim2.new(1, -20, 0, 8)
ProgressBarFrame.Position = UDim2.new(0, 10, 1, -15)
ProgressBarFrame.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
ProgressBarFrame.BorderSizePixel = 0
ProgressBarFrame.Parent = StatusFrame

local ProgressBarCorner = Instance.new("UICorner")
ProgressBarCorner.CornerRadius = UDim.new(1, 0)
ProgressBarCorner.Parent = ProgressBarFrame

local ProgressBar = Instance.new("Frame")
ProgressBar.Name = "ProgressBar"
ProgressBar.Size = UDim2.new(0, 0, 1, 0)
ProgressBar.BackgroundColor3 = Color3.fromRGB(0, 255, 132) -- Green color for low population
ProgressBar.BorderSizePixel = 0
ProgressBar.Parent = ProgressBarFrame

local ProgressBarInnerCorner = Instance.new("UICorner")
ProgressBarInnerCorner.CornerRadius = UDim.new(1, 0)
ProgressBarInnerCorner.Parent = ProgressBar

-- Function to update the status
local function UpdateStatus(message, progress)
    StatusText.Text = message
    ProgressBar.Size = UDim2.new(progress, 0, 1, 0)
end

-- Function to load visited servers
local function LoadVisitedServers()
    local success, result = pcall(function()
        if not isfolder("ServerHistory") then
            makefolder("ServerHistory")
        end
        
        local filePath = "ServerHistory/" .. visitedServersFileName
        if isfile(filePath) then
            return HttpService:JSONDecode(readfile(filePath))
        else
            return {}
        end
    end)
    
    if success then
        return result
    else
        warn("Failed to load visited servers: " .. tostring(result))
        return {}
    end
end

-- Function to save visited servers
local function SaveVisitedServers(visitedServers)
    local success, result = pcall(function()
        if not isfolder("ServerHistory") then
            makefolder("ServerHistory")
        end
        
        local filePath = "ServerHistory/" .. visitedServersFileName
        writefile(filePath, HttpService:JSONEncode(visitedServers))
    end)
    
    if not success then
        warn("Failed to save visited servers: " .. tostring(result))
    end
end

-- Function to add current server to visited servers
local function AddCurrentServerToVisited(visitedServers)
    local currentServerGuid = game.JobId
    if currentServerGuid ~= "" then
        visitedServers[currentServerGuid] = os.time() -- Store timestamp
        SaveVisitedServers(visitedServers)
    end
end

-- Function to mark a server as visited (used when teleport fails)
local function MarkServerAsVisited(serverId)
    local visitedServers = LoadVisitedServers()
    visitedServers[serverId] = os.time()
    SaveVisitedServers(visitedServers)
end

-- Function to get server list (using cursor to potentially load more servers)
local function GetServerList(cursor)
    local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
    if cursor then
        url = url .. "&cursor=" .. cursor
    end
    
    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)
    
    if success then
        return result
    else
        warn("Failed to get server list: " .. tostring(result))
        return {data = {}}
    end
end

-- Function to find target server
local function FindTargetServer(visitedServers, excludeServerIds)
    excludeServerIds = excludeServerIds or {}
    local targetServer = nil
    local lowestPlayers = math.huge
    local candidates = {}
    local nextCursor = nil
    local searchAttempts = 0
    local maxSearchAttempts = 5 -- Limit how many pagination requests we make
    
    while (not targetServer or keepSearching) and searchAttempts < maxSearchAttempts do
        -- Get a batch of servers
        local serverList = GetServerList(nextCursor)
        searchAttempts = searchAttempts + 1
        
        if #serverList.data == 0 then
            break -- No more servers available
        end
        
        -- Sort servers by player count (lowest first - this is the key difference)
        table.sort(serverList.data, function(a, b)
            return a.playing < b.playing
        end)
        
        -- Try to find unvisited server with minimum players
        for _, server in pairs(serverList.data) do
            -- Skip if this server is in our exclude list (failed teleport)
            if excludeServerIds[server.id] then
                continue
            end
            
            -- Check if server hasn't been visited and meets minimum player count
            if not visitedServers[server.id] and 
               server.playing >= minimumPlayers and
               server.playing < lowestPlayers then
                lowestPlayers = server.playing
                targetServer = server
                table.insert(candidates, server)
                
                -- If not keeping searching, break after finding the first valid server
                if not keepSearching then
                    break
                end
            end
        end
        
        -- If we found a target and aren't continuing to search, break out
        if targetServer and not keepSearching then
            break
        end
        
        -- If there's a next page of results and we should keep looking
        nextCursor = serverList.nextPageCursor
        if not nextCursor then
            break -- No more pages
        end
    end
    
    -- If no server found with our criteria, take any server with minimum players
    if not targetServer then
        local serverList = GetServerList() -- Get fresh list
        
        for _, server in pairs(serverList.data) do
            -- Skip if this server is in our exclude list
            if excludeServerIds[server.id] then
                continue
            end
            
            if server.playing >= minimumPlayers and server.playing < lowestPlayers then
                lowestPlayers = server.playing
                targetServer = server
                table.insert(candidates, server)
            end
        end
    end
    
    return targetServer, candidates
end

-- TeleportService.TeleportInitFailed event handler
local failedTeleports = {}
local retryCount = 0

-- Listen for teleport failures
TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
    if player == LocalPlayer then
        local failReason = teleportResult.Name
        
        -- Handle specific teleport failures
        if failReason == "GameEnded" or failReason == "GameFull" or failReason == "Unauthorized" then
            if retryCount < maxRetries then
                retryCount = retryCount + 1
                UpdateStatus("Server was unavailable. Finding next emptiest server... (Attempt " .. retryCount .. "/" .. maxRetries .. ")", 0.4)
                
                -- If we have an active target server, mark it as visited
                if teleportTarget and teleportTarget.id then
                    failedTeleports[teleportTarget.id] = true
                    MarkServerAsVisited(teleportTarget.id)
                end
                
                -- Re-run teleport process
                spawn(function()
                    TeleportToLowestPopulationServer()
                end)
            else
                UpdateStatus("Failed to find an available server after " .. maxRetries .. " attempts. Please try again later.", 1)
                wait(5)
                ScreenGui:Destroy()
            end
        else
            UpdateStatus("Teleport failed: " .. failReason .. ". " .. (errorMessage or ""), 1)
            wait(5)
            ScreenGui:Destroy()
        end
    end
end)

-- Global var to track current teleport target
local teleportTarget = nil

-- Function to teleport to the server with the lowest player count
function TeleportToLowestPopulationServer()
    UpdateStatus("Initializing teleport process...", 0.05)
    
    -- Load visited servers
    local visitedServers = LoadVisitedServers()
    
    -- Add current server to visited servers
    AddCurrentServerToVisited(visitedServers)
    
    UpdateStatus("Searching for emptiest servers...", 0.2)
    
    -- Find the server with the lowest player count
    local targetServer, candidates = FindTargetServer(visitedServers, failedTeleports)
    
    UpdateStatus("Finalizing server selection...", 0.9)
    
    -- Teleport to the target server
    if targetServer then
        UpdateStatus("Teleporting to server with only " .. targetServer.playing .. " players", 1)
        
        teleportTarget = targetServer -- Store current target
        
        wait(0.5) -- Brief pause
        
        local teleportSuccess, teleportError = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, targetServer.id, LocalPlayer)
        end)
        
        if not teleportSuccess then
            -- If immediate error, try next server
            UpdateStatus("Teleport error: " .. tostring(teleportError) .. ". Trying next server...", 0.5)
            failedTeleports[targetServer.id] = true
            
            if retryCount < maxRetries then
                retryCount = retryCount + 1
                
                -- Try to find another server
                targetServer, _ = FindTargetServer(visitedServers, failedTeleports)
                
                if targetServer then
                    teleportTarget = targetServer
                    
                    UpdateStatus("Teleporting to alternate server with " .. targetServer.playing .. " players", 1)
                    
                    wait(0.5)
                    
                    pcall(function()
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, targetServer.id, LocalPlayer)
                    end)
                else
                    UpdateStatus("No other suitable servers found. Try again later.", 1)
                    wait(5)
                    ScreenGui:Destroy()
                end
            else
                UpdateStatus("Failed after " .. maxRetries .. " attempts. Try again later.", 1)
                wait(5)
                ScreenGui:Destroy()
            end
        end
    else
        UpdateStatus("No suitable servers found. Try again later.", 1)
        wait(5)
        ScreenGui:Destroy()
    end
end

-- Execute teleport immediately
spawn(TeleportToLowestPopulationServer)


--[[ sneak ]]
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Create a large second baseplate
local secondBaseplatePosition = Vector3.new(108.033035, -6, -24.9428463)
local secondBaseplate = Instance.new("Part")
secondBaseplate.Size = Vector3.new(1024, 1, 1024)
secondBaseplate.Position = secondBaseplatePosition
secondBaseplate.Anchored = true
secondBaseplate.Name = "SecondBaseplate"
secondBaseplate.BrickColor = BrickColor.new("Medium green")
secondBaseplate.Material = Enum.Material.Grass
secondBaseplate.CanCollide = true
secondBaseplate.Transparency = 1
secondBaseplate.Parent = game.Workspace

-- Smooth surface for the baseplate
secondBaseplate.TopSurface = Enum.SurfaceType.Smooth
secondBaseplate.BottomSurface = Enum.SurfaceType.Smooth

-- Create GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BaseplateControlGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- Create a minimal frame for GUI elements
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 100, 0, 100)
frame.Position = UDim2.new(0.9, -50, 0.1, 0)
frame.BackgroundTransparency = 0.2
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
frame.BorderSizePixel = 0
frame.Parent = screenGui

-- Add a UI corner for rounded edges
local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 12)
frameCorner.Parent = frame

-- Add drop shadow effect
local dropShadow = Instance.new("Frame")
dropShadow.Size = UDim2.new(1, 10, 1, 10)
dropShadow.Position = UDim2.new(0, -5, 0, -5)
dropShadow.BackgroundTransparency = 0.6
dropShadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
dropShadow.BorderSizePixel = 0
dropShadow.ZIndex = -1
dropShadow.Parent = frame

local dropShadowCorner = Instance.new("UICorner")
dropShadowCorner.CornerRadius = UDim.new(0, 14)
dropShadowCorner.Parent = dropShadow

-- Enable frame drag functionality
local UserInputService = game:GetService("UserInputService")
local dragging, dragInput, mousePos, framePos

local function updateInput(input)
    local delta = input.Position - mousePos
    frame.Position = UDim2.new(framePos.X.Scale, framePos.X.Offset + delta.X, framePos.Y.Scale, framePos.Y.Offset + delta.Y)
end

frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        mousePos = input.Position
        framePos = frame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

frame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        updateInput(input)
    end
end)

-- Add a close button
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 25, 0, 25)
closeButton.Position = UDim2.new(1, -25, 0, 0)
closeButton.Text = "X"
closeButton.BackgroundColor3 = Color3.fromRGB(220, 75, 75) -- Red color
closeButton.TextSize = 14
closeButton.Font = Enum.Font.GothamBold
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Parent = frame

local closeButtonCorner = Instance.new("UICorner")
closeButtonCorner.CornerRadius = UDim.new(0, 8)
closeButtonCorner.Parent = closeButton

-- Add hover effect to close button
local closeButtonHover = Instance.new("UIStroke")
closeButtonHover.Color = Color3.fromRGB(255, 255, 255)
closeButtonHover.Transparency = 1
closeButtonHover.Thickness = 2
closeButtonHover.Parent = closeButton

closeButton.MouseEnter:Connect(function()
    closeButtonHover.Transparency = 0
    closeButton.BackgroundColor3 = Color3.fromRGB(230, 85, 85) -- Slightly lighter when hovering
end)

closeButton.MouseLeave:Connect(function()
    closeButtonHover.Transparency = 1
    closeButton.BackgroundColor3 = Color3.fromRGB(220, 75, 75) -- Back to original color
end)

closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- FIXED BUTTON LAYOUT - Top button should tween down, Bottom button should tween up
local downButton = Instance.new("TextButton")
downButton.Size = UDim2.new(0, 50, 0, 35)
downButton.Position = UDim2.new(0.5, -25, 0, 10) -- Top position
downButton.Text = "↑"
downButton.BackgroundColor3 = Color3.fromRGB(220, 75, 75) -- Red color
downButton.TextSize = 20
downButton.Font = Enum.Font.GothamBold
downButton.TextColor3 = Color3.fromRGB(255, 255, 255)
downButton.Parent = frame

local downButtonCorner = Instance.new("UICorner")
downButtonCorner.CornerRadius = UDim.new(0, 8)
downButtonCorner.Parent = downButton

-- Add hover effect to downButton
local downButtonHover = Instance.new("UIStroke")
downButtonHover.Color = Color3.fromRGB(255, 255, 255)
downButtonHover.Transparency = 1
downButtonHover.Thickness = 2
downButtonHover.Parent = downButton

downButton.MouseEnter:Connect(function()
    downButtonHover.Transparency = 0
    downButton.BackgroundColor3 = Color3.fromRGB(230, 85, 85) -- Slightly lighter when hovering
end)

downButton.MouseLeave:Connect(function()
    downButtonHover.Transparency = 1
    downButton.BackgroundColor3 = Color3.fromRGB(220, 75, 75) -- Back to original color
end)

local upButton = Instance.new("TextButton")
upButton.Size = UDim2.new(0, 50, 0, 35)
upButton.Position = UDim2.new(0.5, -25, 0, 55) -- Bottom position
upButton.Text = "↓"
upButton.BackgroundColor3 = Color3.fromRGB(65, 125, 225) -- Blue color
upButton.TextSize = 20
upButton.Font = Enum.Font.GothamBold
upButton.TextColor3 = Color3.fromRGB(255, 255, 255)
upButton.Parent = frame

local upButtonCorner = Instance.new("UICorner")
upButtonCorner.CornerRadius = UDim.new(0, 8)
upButtonCorner.Parent = upButton

-- Add hover effect to upButton
local upButtonHover = Instance.new("UIStroke")
upButtonHover.Color = Color3.fromRGB(255, 255, 255)
upButtonHover.Transparency = 1
upButtonHover.Thickness = 2
upButtonHover.Parent = upButton

upButton.MouseEnter:Connect(function()
    upButtonHover.Transparency = 0
    upButton.BackgroundColor3 = Color3.fromRGB(75, 135, 235) -- Slightly lighter when hovering
end)

upButton.MouseLeave:Connect(function()
    upButtonHover.Transparency = 1
    upButton.BackgroundColor3 = Color3.fromRGB(65, 125, 225) -- Back to original color
end)

-- Variables to control tweening
local isTweening = false
local tweenDuration = 1 -- 1 second for the tween
local noclipConnection = nil

-- Function to calculate the height needed to reach the baseplate
local function getHeightToBaseplate()
    -- Get the Y position of the top of the baseplate
    local baseplateSurfaceY = secondBaseplate.Position.Y + (secondBaseplate.Size.Y / 2)
    
    -- Calculate how far the player's feet should be above the baseplate (slightly above to avoid clipping)
    local feetOffset = 3 -- Offset from the player's HumanoidRootPart to the feet + a small gap
    
    -- Return the target Y position for the player's HumanoidRootPart
    return baseplateSurfaceY + feetOffset
end

-- Enable permanent noclip
local function enablePermanentNoclip()
    if noclipConnection then noclipConnection:Disconnect() end
    
    noclipConnection = RunService.Stepped:Connect(function()
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

-- Enable noclip immediately when script runs
enablePermanentNoclip()

-- Function to tween the player up to the baseplate
local function tweenPlayerToBaseplate()
    if isTweening then return end
    
    isTweening = true
    
    -- Save original orientation
    local originalCFrame = humanoidRootPart.CFrame
    local originalLookVector = originalCFrame.LookVector
    
    -- Set PlatformStand to true to prevent jumping during tween
    humanoid.PlatformStand = true
    
    -- Keep X and Z positions the same, but change Y to the calculated baseplate height
    local targetPosition = Vector3.new(
        humanoidRootPart.Position.X,
        getHeightToBaseplate(),
        humanoidRootPart.Position.Z
    )
    
    -- Create a CFrame that preserves the original facing direction
    local targetCFrame = CFrame.new(targetPosition) * CFrame.lookAt(targetPosition, targetPosition + originalLookVector)
    
    -- Create a BodyPosition to handle the movement
    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.MaxForce = Vector3.new(100000, 100000, 100000) -- Strong enough to move the player
    bodyPosition.Position = targetPosition
    bodyPosition.P = 10000 -- Makes movement more immediate
    bodyPosition.D = 1000 -- Dampening
    bodyPosition.Parent = humanoidRootPart
    
    -- Create a BodyGyro to maintain orientation
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    bodyGyro.CFrame = targetCFrame
    bodyGyro.P = 10000
    bodyGyro.D = 1000
    bodyGyro.Parent = humanoidRootPart
    
    -- Remove the BodyPosition and BodyGyro after tweening is complete
    game:GetService("Debris"):AddItem(bodyPosition, tweenDuration + 0.1)
    game:GetService("Debris"):AddItem(bodyGyro, tweenDuration + 0.1)
    
    -- Set a timer to mark tweening as complete
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if (humanoidRootPart.Position - targetPosition).Magnitude < 1 then
            -- Reset state
            isTweening = false
            humanoid.PlatformStand = false
            
            -- Clean up
            if bodyPosition and bodyPosition.Parent then
                bodyPosition:Destroy()
            end
            
            if bodyGyro and bodyGyro.Parent then
                bodyGyro:Destroy()
            end
            
            -- Disconnect this event
            if connection then
                connection:Disconnect()
            end
        end
    end)
end

-- Function to tween the player down to the original ground
local function tweenPlayerToOriginalGround()
    if isTweening then return end
    
    isTweening = true
    
    -- Save original orientation
    local originalCFrame = humanoidRootPart.CFrame
    local originalLookVector = originalCFrame.LookVector
    
    -- Set PlatformStand to true to prevent jumping during tween
    humanoid.PlatformStand = true
    
    -- Calculate the ground level (assuming 0 is the ground, adjust if needed)
    local groundLevel = 0
    local humanoidHeight = 3 -- Approximate height of the humanoid from feet to HumanoidRootPart
    
    -- Target position - same X and Z, but Y at ground level plus humanoid height
    local targetPosition = Vector3.new(
        humanoidRootPart.Position.X,
        groundLevel + humanoidHeight,
        humanoidRootPart.Position.Z
    )
    
    -- Create a CFrame that preserves the original facing direction
    local targetCFrame = CFrame.new(targetPosition) * CFrame.lookAt(targetPosition, targetPosition + originalLookVector)
    
    -- Create a BodyPosition to handle the movement
    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.MaxForce = Vector3.new(100000, 100000, 100000)
    bodyPosition.Position = targetPosition
    bodyPosition.P = 10000
    bodyPosition.D = 1000
    bodyPosition.Parent = humanoidRootPart
    
    -- Create a BodyGyro to maintain orientation
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    bodyGyro.CFrame = targetCFrame
    bodyGyro.P = 10000
    bodyGyro.D = 1000
    bodyGyro.Parent = humanoidRootPart
    
    -- Remove the BodyPosition and BodyGyro after tweening is complete
    game:GetService("Debris"):AddItem(bodyPosition, tweenDuration + 0.1)
    game:GetService("Debris"):AddItem(bodyGyro, tweenDuration + 0.1)
    
    -- Set a timer to mark tweening as complete
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if (humanoidRootPart.Position - targetPosition).Magnitude < 1 then
            -- Reset state
            isTweening = false
            humanoid.PlatformStand = false
            
            -- Clean up
            if bodyPosition and bodyPosition.Parent then
                bodyPosition:Destroy()
            end
            
            if bodyGyro and bodyGyro.Parent then
                bodyGyro:Destroy()
            end
            
            -- Disconnect this event
            if connection then
                connection:Disconnect()
            end
        end
    end)
end

-- IMPORTANT: Connect buttons to the CORRECT functions
-- Up arrow button (the bottom button) connects to tweenPlayerToBaseplate (move UP)
upButton.MouseButton1Click:Connect(tweenPlayerToBaseplate)

-- Down arrow button (the top button) connects to tweenPlayerToOriginalGround (move DOWN)
downButton.MouseButton1Click:Connect(tweenPlayerToOriginalGround)

-- Handle player respawn by reconnecting to the new character
player.CharacterAdded:Connect(function(newCharacter)
    -- Cancel any ongoing tween
    if isTweening then
        isTweening = false
    end
    
    -- Update character references
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    
    -- Re-enable noclip for the new character
    enablePermanentNoclip()
end)


--[[ animlogger ]]
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local THEME = {
    BACKGROUND = Color3.fromRGB(15, 15, 20),
    SECONDARY = Color3.fromRGB(25, 25, 35),
    ACCENT = Color3.fromRGB(65, 135, 245),
    ACCENT_HOVER = Color3.fromRGB(85, 155, 255),
    TEXT = Color3.fromRGB(255, 255, 255),
    TEXT_SECONDARY = Color3.fromRGB(180, 180, 190),
    SHADOW = Color3.fromRGB(0, 0, 0),
    SUCCESS = Color3.fromRGB(72, 199, 142),
    ERROR = Color3.fromRGB(245, 75, 75)
}

local CONFIG = {
    GUI_WIDTH = 300,
    GUI_HEIGHT = 400,
    ENTRY_HEIGHT = 50,
    CORNER_RADIUS = 6,
    TWEEN_SPEED = 0.2
}

local function createTween(instance, properties, duration)
    return TweenService:Create(
        instance,
        TweenInfo.new(duration or CONFIG.TWEEN_SPEED, Enum.EasingStyle.Quad),
        properties
    ):Play()
end

local function createShadow(parent)
    local shadow = Instance.new("ImageLabel")
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://7912134082"
    shadow.ImageColor3 = THEME.SHADOW
    shadow.ImageTransparency = 0.4
    shadow.Size = UDim2.new(1, 16, 1, 16)
    shadow.Position = UDim2.new(0, -8, 0, -8)
    shadow.ZIndex = parent.ZIndex - 1
    shadow.Parent = parent
end

-- GUI Creation
local gui = Instance.new("ScreenGui")
gui.Name = "PremiumAnimationLogger"
gui.ResetOnSpawn = false

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, CONFIG.GUI_WIDTH, 0, CONFIG.GUI_HEIGHT)
frame.Position = UDim2.new(1, -CONFIG.GUI_WIDTH - 20, 0.5, -CONFIG.GUI_HEIGHT/2)
frame.BackgroundColor3 = THEME.BACKGROUND
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Parent = gui

Instance.new("UICorner", frame).CornerRadius = UDim.new(0, CONFIG.CORNER_RADIUS)
createShadow(frame)

-- Title Bar
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.BackgroundColor3 = THEME.SECONDARY
titleBar.BorderSizePixel = 0
titleBar.Parent = frame

Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, CONFIG.CORNER_RADIUS)

local title = Instance.new("TextLabel")
title.Text = "Animation Logger"
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.Size = UDim2.new(1, -100, 1, 0)
title.Position = UDim2.new(0, 15, 0, 0)
title.BackgroundTransparency = 1
title.TextColor3 = THEME.TEXT
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = titleBar

-- Control Buttons
local buttonContainer = Instance.new("Frame")
buttonContainer.Size = UDim2.new(0, 80, 1, 0)
buttonContainer.Position = UDim2.new(1, -80, 0, 0)
buttonContainer.BackgroundTransparency = 1
buttonContainer.Parent = titleBar

local function createButton(properties)
    local button = Instance.new("TextButton")
    for prop, value in pairs(properties) do
        button[prop] = value
    end
    Instance.new("UICorner", button).CornerRadius = UDim.new(0, CONFIG.CORNER_RADIUS)
    return button
end

local clearButton = createButton({
    Text = "Clear",
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Size = UDim2.new(0, 45, 0, 24),
    Position = UDim2.new(0, 0, 0.5, -12),
    BackgroundColor3 = THEME.ACCENT,
    TextColor3 = THEME.TEXT,
    AutoButtonColor = false,
    Parent = buttonContainer
})

local closeButton = createButton({
    Text = "×",
    Font = Enum.Font.GothamMedium,
    TextSize = 20,
    Size = UDim2.new(0, 24, 0, 24),
    Position = UDim2.new(1, -29, 0.5, -12),
    BackgroundColor3 = THEME.ERROR,
    TextColor3 = THEME.TEXT,
    AutoButtonColor = false,
    Parent = buttonContainer
})

-- Scrolling Container
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Position = UDim2.new(0, 8, 0, 48)
scrollFrame.Size = UDim2.new(1, -16, 1, -56)
scrollFrame.BackgroundTransparency = 1
scrollFrame.ScrollBarThickness = 3
scrollFrame.ScrollBarImageColor3 = THEME.ACCENT
scrollFrame.Parent = frame

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 6)
listLayout.Parent = scrollFrame

-- Animation Tracking
local loggedAnimations = {}

local function createLogEntry(track)
    local animId = track.Animation.AnimationId
    if loggedAnimations[animId] then return end
    loggedAnimations[animId] = true
    
    local entry = Instance.new("Frame")
    entry.Size = UDim2.new(1, 0, 0, CONFIG.ENTRY_HEIGHT)
    entry.BackgroundColor3 = THEME.SECONDARY
    entry.BackgroundTransparency = 1
    entry.Parent = scrollFrame
    
    Instance.new("UICorner", entry).CornerRadius = UDim.new(0, CONFIG.CORNER_RADIUS)
    
    local animName = Instance.new("TextLabel")
    animName.Text = track.Animation.Name or "Unnamed Animation"
    animName.Font = Enum.Font.GothamBold
    animName.TextSize = 14
    animName.Size = UDim2.new(1, -65, 0, 20)
    animName.Position = UDim2.new(0, 12, 0, 8)
    animName.BackgroundTransparency = 1
    animName.TextColor3 = THEME.TEXT
    animName.TextXAlignment = Enum.TextXAlignment.Left
    animName.Parent = entry
    
    local idLabel = Instance.new("TextLabel")
    idLabel.Text = animId:match("rbxassetid://(.+)") or animId
    idLabel.Font = Enum.Font.Gotham
    idLabel.TextSize = 12
    idLabel.Size = UDim2.new(1, -65, 0, 16)
    idLabel.Position = UDim2.new(0, 12, 1, -24)
    idLabel.BackgroundTransparency = 1
    idLabel.TextColor3 = THEME.TEXT_SECONDARY
    idLabel.TextXAlignment = Enum.TextXAlignment.Left
    idLabel.Parent = entry
    
    local copyButton = createButton({
        Text = "Copy",
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        Size = UDim2.new(0, 45, 0, 24),
        Position = UDim2.new(1, -55, 0.5, -12),
        BackgroundColor3 = THEME.ACCENT,
        TextColor3 = THEME.TEXT,
        BackgroundTransparency = 1,
        Parent = entry
    })
    
    -- Animations
    createTween(entry, {BackgroundTransparency = 0})
    createTween(copyButton, {BackgroundTransparency = 0.2})
    
    -- Button Events
    copyButton.MouseEnter:Connect(function()
        createTween(copyButton, {BackgroundColor3 = THEME.ACCENT_HOVER})
    end)
    
    copyButton.MouseLeave:Connect(function()
        createTween(copyButton, {BackgroundColor3 = THEME.ACCENT})
    end)
    
    copyButton.MouseButton1Click:Connect(function()
        setclipboard(animId:match("%d+"))
        createTween(copyButton, {BackgroundColor3 = THEME.SUCCESS})
        task.wait(0.5)
        createTween(copyButton, {BackgroundColor3 = THEME.ACCENT})
    end)
    
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y)
end

-- Character Hook
local function hookCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")
    animator.AnimationPlayed:Connect(createLogEntry)
end

-- Initialize
local player = Players.LocalPlayer
if player.Character then hookCharacter(player.Character) end
player.CharacterAdded:Connect(hookCharacter)

-- Dragging System
local dragging, dragStart, startPos, dragInput

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or
       input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or
       input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging and dragInput then
        local delta = dragInput.Position - dragStart
        createTween(frame, {
            Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        }, 0.1)
    end
end)

-- Button Events
clearButton.MouseButton1Click:Connect(function()
    for _, child in ipairs(scrollFrame:GetChildren()) do
        if child:IsA("Frame") then
            createTween(child, {BackgroundTransparency = 1})
            task.delay(0.2, function() child:Destroy() end)
        end
    end
    loggedAnimations = {}
end)

closeButton.MouseButton1Click:Connect(function()
    createTween(frame, {Size = UDim2.new(0, CONFIG.GUI_WIDTH, 0, 0)}, 0.3)
    task.wait(0.3)
    gui:Destroy()
end)

-- Initialize GUI
gui.Parent = player:WaitForChild("PlayerGui")
frame.Size = UDim2.new(0, CONFIG.GUI_WIDTH, 0, 0)
createTween(frame, {Size = UDim2.new(0, CONFIG.GUI_WIDTH, 0, CONFIG.GUI_HEIGHT)}, 0.3)



--[[ walkonvoid ]]
local Void = Instance.new("Part")
Void.Parent = workspace.Terrain
Void.Name = "Void"
Void.Transparency = 1
Void.Anchored = true
Void.Size = Vector3.new(2048, 1, 2048)
Void.Position = Vector3.new(0, workspace.FallenPartsDestroyHeight, 0)
Void.Locked = true
while true do
    pcall(function()
        Void.Position = Vector3.new(game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position.X, workspace.FallenPartsDestroyHeight, game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position.Z)
    end)
    task.wait(0)
end


--[[ droptools ]]
for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
    game.Players.LocalPlayer.Character.Humanoid:EquipTool(v)
    v.Parent = workspace
end


--[[ antikick ]]
--// Cache

local getgenv, getnamecallmethod, hookmetamethod, hookfunction, newcclosure, checkcaller, lower, gsub, match = getgenv, getnamecallmethod, hookmetamethod, hookfunction, newcclosure, checkcaller, string.lower, string.gsub, string.match

--// Loaded check

if getgenv().ED_AntiKick then
	return
end

--// Variables

local cloneref = cloneref or function(...) 
	return ...
end

local clonefunction = clonefunction or function(...)
	return ...
end

local Players, LocalPlayer, StarterGui = cloneref(game:GetService("Players")), cloneref(game:GetService("Players").LocalPlayer), cloneref(game:GetService("StarterGui"))

local SetCore = clonefunction(StarterGui.SetCore)
--local GetDebugId = clonefunction(game.GetDebugId)
local FindFirstChild = clonefunction(game.FindFirstChild)

local CompareInstances = (CompareInstances and function(Instance1, Instance2)
		if typeof(Instance1) == "Instance" and typeof(Instance2) == "Instance" then
			return CompareInstances(Instance1, Instance2)
		end
	end)
or
function(Instance1, Instance2)
	return (typeof(Instance1) == "Instance" and typeof(Instance2) == "Instance")-- and GetDebugId(Instance1) == GetDebugId(Instance2)
end

local CanCastToSTDString = function(...)
	return pcall(FindFirstChild, game, ...)
end

--// Global Variables

getgenv().ED_AntiKick = {
	Enabled = true, -- Set to false if you want to disable the Anti-Kick.
	SendNotifications = true, -- Set to true if you want to get notified for every event.
	CheckCaller = true -- Set to true if you want to disable kicking by other user executed scripts.
}

--// Main

local OldNamecall; OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
	local self, message = ...
	local method = getnamecallmethod()
	
	if ((getgenv().ED_AntiKick.CheckCaller and not checkcaller()) or true) and CompareInstances(self, LocalPlayer) and gsub(method, "^%l", string.upper) == "Kick" and ED_AntiKick.Enabled then
		if CanCastToSTDString(message) then
			if getgenv().ED_AntiKick.SendNotifications then
				SetCore(StarterGui, "SendNotification", {
					Title = "Exunys Developer - Anti-Kick",
					Text = "Successfully intercepted an attempted kick.",
					Icon = "rbxassetid://6238540373",
					Duration = 2
				})
			end

			return
		end
	end

	return OldNamecall(...)
end))

local OldFunction; OldFunction = hookfunction(LocalPlayer.Kick, function(...)
	local self, Message = ...

	if ((ED_AntiKick.CheckCaller and not checkcaller()) or true) and CompareInstances(self, LocalPlayer) and ED_AntiKick.Enabled then
		if CanCastToSTDString(Message) then
			if ED_AntiKick.SendNotifications then
				SetCore(StarterGui, "SendNotification", {
					Title = "Exunys Developer - Anti-Kick",
					Text = "Successfully intercepted an attempted kick.",
					Icon = "rbxassetid://6238540373",
					Duration = 2
				})
			end

			return
		end
	end
end)

if getgenv().ED_AntiKick.SendNotifications then
	StarterGui:SetCore("SendNotification", {
		Title = "Exunys Developer - Anti-Kick",
		Text = "Anti-Kick script loaded!",
		Icon = "rbxassetid://6238537240",
		Duration = 3
	})
end


--[[ priorityspeaker ]]
local player = game:GetService("Players").LocalPlayer
local tweenService = game:GetService("TweenService")

-- Function to enable Priority Speaker
local function enablePrioritySpeaker()
    local AudioFocusService = game:GetService("AudioFocusService")
    AudioFocusService:RegisterContextIdFromLua(100)
    task.wait()
    AudioFocusService:RequestFocus(100, 9999999)
end

-- Function to create and display a notification
local function createNotification()
    -- Create GUI objects
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AKAdminNotification"
    screenGui.ResetOnSpawn = false
    screenGui.DisplayOrder = 10
    screenGui.Parent = player.PlayerGui
    
    -- Main notification frame
    local notificationFrame = Instance.new("Frame")
    notificationFrame.Name = "NotificationFrame"
    notificationFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 40) -- Dark background
    notificationFrame.BorderSizePixel = 0
    notificationFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    notificationFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    notificationFrame.Size = UDim2.new(0, 300, 0, 130)
    notificationFrame.Parent = screenGui
    
    -- Apply corner radius to make it look modern
    local cornerRadius = Instance.new("UICorner")
    cornerRadius.CornerRadius = UDim.new(0, 8)
    cornerRadius.Parent = notificationFrame
    
    -- Size constraint to prevent the notification from being too large on big screens
    local sizeConstraint = Instance.new("UISizeConstraint")
    sizeConstraint.MaxSize = Vector2.new(350, 160)
    sizeConstraint.MinSize = Vector2.new(250, 110)
    sizeConstraint.Parent = notificationFrame
    
    -- Apply padding for internal content
    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0, 15)
    padding.PaddingBottom = UDim.new(0, 15)
    padding.PaddingLeft = UDim.new(0, 15)
    padding.PaddingRight = UDim.new(0, 15)
    padding.Parent = notificationFrame
    
    -- Header text
    local headerText = Instance.new("TextLabel")
    headerText.Name = "HeaderText"
    headerText.BackgroundTransparency = 1
    headerText.Font = Enum.Font.GothamBold
    headerText.TextColor3 = Color3.fromRGB(240, 240, 240) -- Light text
    headerText.TextSize = 24
    headerText.Text = "AK Admin"
    headerText.TextXAlignment = Enum.TextXAlignment.Left
    headerText.Position = UDim2.new(0, 0, 0, 0)
    headerText.Size = UDim2.new(1, 0, 0, 28)
    headerText.Parent = notificationFrame
    
    -- Colorful accent line under the header
    local accentLine = Instance.new("Frame")
    accentLine.Name = "AccentLine"
    accentLine.BackgroundColor3 = Color3.fromRGB(85, 170, 255) -- Light blue accent
    accentLine.BorderSizePixel = 0
    accentLine.Position = UDim2.new(0, 0, 0, 32)
    accentLine.Size = UDim2.new(0.4, 0, 0, 2)
    accentLine.Parent = notificationFrame
    
    -- Message text
    local messageText = Instance.new("TextLabel")
    messageText.Name = "MessageText"
    messageText.BackgroundTransparency = 1
    messageText.Font = Enum.Font.Gotham
    messageText.TextColor3 = Color3.fromRGB(200, 200, 200) -- Slightly darker than header for hierarchy
    messageText.TextSize = 16
    messageText.TextWrapped = true
    messageText.Text = "Priority Speaker enabled!"
    messageText.TextXAlignment = Enum.TextXAlignment.Left
    messageText.Position = UDim2.new(0, 0, 0, 45)
    messageText.Size = UDim2.new(1, 0, 0, 60)
    messageText.Parent = notificationFrame
    
    -- Close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.BackgroundTransparency = 1
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    closeButton.TextSize = 14
    closeButton.Text = "X"
    closeButton.Position = UDim2.new(1, -20, 0, 0)
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Parent = notificationFrame
    
    -- Animation: make the notification appear with a subtle animation
    notificationFrame.Position = UDim2.new(0.5, 0, 0.4, 0) -- Start position slightly higher
    notificationFrame.BackgroundTransparency = 1
    headerText.TextTransparency = 1
    accentLine.BackgroundTransparency = 1
    messageText.TextTransparency = 1
    closeButton.TextTransparency = 1
    
    -- Create a table of properties to tween
    local tweenInfo = TweenInfo.new(
        0.5, -- Duration
        Enum.EasingStyle.Quad, -- Easing style
        Enum.EasingDirection.Out -- Easing direction
    )
    
    -- Create tweens for each element
    local frameTween = tweenService:Create(notificationFrame, tweenInfo, {
        Position = UDim2.new(0.5, 0, 0.5, 0), -- Move to center
        BackgroundTransparency = 0
    })
    
    local headerTween = tweenService:Create(headerText, tweenInfo, {
        TextTransparency = 0
    })
    
    local accentTween = tweenService:Create(accentLine, tweenInfo, {
        BackgroundTransparency = 0
    })
    
    local messageTween = tweenService:Create(messageText, tweenInfo, {
        TextTransparency = 0
    })
    
    local closeTween = tweenService:Create(closeButton, tweenInfo, {
        TextTransparency = 0
    })
    
    -- Play the tweens in sequence
    frameTween:Play()
    wait(0.1)
    headerTween:Play()
    wait(0.1)
    accentTween:Play()
    wait(0.1)
    messageTween:Play()
    wait(0.1)
    closeTween:Play()
    
    -- Function to close/dismiss the notification
    local function closeNotification()
        -- Fade out animation
        local closeTweenInfo = TweenInfo.new(
            0.4, -- Duration
            Enum.EasingStyle.Quad, -- Easing style
            Enum.EasingDirection.In -- Easing direction
        )
        
        local frameCloseTween = tweenService:Create(notificationFrame, closeTweenInfo, {
            Position = UDim2.new(0.5, 0, 0.4, 0), -- Move up slightly
            BackgroundTransparency = 1
        })
        
        local headerCloseTween = tweenService:Create(headerText, closeTweenInfo, {
            TextTransparency = 1
        })
        
        local accentCloseTween = tweenService:Create(accentLine, closeTweenInfo, {
            BackgroundTransparency = 1
        })
        
        local messageCloseTween = tweenService:Create(messageText, closeTweenInfo, {
            TextTransparency = 1
        })
        
        local closeButtonTween = tweenService:Create(closeButton, closeTweenInfo, {
            TextTransparency = 1
        })
        
        -- Play close animations
        frameCloseTween:Play()
        headerCloseTween:Play()
        accentCloseTween:Play()
        messageCloseTween:Play()
        closeButtonTween:Play()
        
        -- Wait for animation to complete then remove
        wait(0.4)
        screenGui:Destroy()
    end
    
    -- Connect close button click event
    closeButton.MouseButton1Click:Connect(function()
        closeNotification()
    end)
    
    -- Auto-close after 5 seconds
    wait(5)
    closeNotification()
end

-- Enable the Priority Speaker function
enablePrioritySpeaker()

-- Create and show the notification
createNotification()


--[[ akbypasser ]]
local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

-- Initialize services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Customizable prefix and suffix characters (Set them here!)
local prefixCharacter = ""  -- **CHANGE THIS to your desired prefix character**
local suffixCharacter = ""  -- **CHANGE THIS to your desired suffix character**

------------------------------------------------------------------
-- Replacement Table

-- Method 1 (Primary) with normal C/c. motherfบcker fบck ⴖigger I'llrареthefบckoutofyou fบckthisِsِhit
local letters = {
    ["A"] = "А", ["a"] = "ล",
    ["B"] = "B", ["b"] = "b",
    ["C"] = "C", ["c"] = "c",  -- C/c set to normal.
    ["D"] = "D", ["d"] = "d",
    ["E"] = "Е", ["e"] = "e",
    ["F"] = "ꜰ", ["f"] = "f",
    ["G"] = "G", ["g"] = "g",
    ["H"] = "H", ["h"] = "һ",
    ["I"] = "Ι", ["i"] = "i",
    ["J"] = "J", ["j"] = "ј",
    ["K"] = "K", ["k"] = "k",
    ["L"] = "L", ["l"] = "ӏ",
    ["M"] = "M", ["m"] = "m",
    ["N"] = "ⴖ", ["n"] = "ⴖ",
    ["O"] = "O", ["o"] = "o",
    ["P"] = "Р", ["p"] = "p",
    ["Q"] = "Q", ["q"] = "q",
    ["R"] = "R", ["r"] = "r",
    ["S"] = "sِ", ["s"] = "sِ",
    ["T"] = "T", ["t"] = "t",
    ["U"] = "U", ["u"] = "บ",  -- U remains normal.
    ["V"] = "V", ["v"] = "v",
    ["W"] = "W", ["w"] = "w",
    ["X"] = "X", ["x"] = "x",
    ["Y"] = "Y", ["y"] = "y",
    ["Z"] = "Z", ["z"] = "z",
    [" "] = "  "
}

------------------------------------------------------------------
-- Utility Functions

local function replace(str, find_str, replace_str)
    local escaped_find_str = find_str:gsub("[%-%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%0")
    return str:gsub(escaped_find_str, replace_str)
end

local function filter(message, tableToUse, prefix, suffix)
    local convertedMessage = message
    for letter, replacement in pairs(tableToUse) do
        convertedMessage = replace(convertedMessage, letter, replacement)
    end
    return prefix .. convertedMessage .. suffix
end

local function showNotification(title, text)
    Notification:Notify(
        {Title = title, Description = text},
        {OutlineColor = Color3.fromRGB(80, 80, 80), Time = 3, Type = "default"}
    )
end

------------------------------------------------------------------
-- Create Main GUI

local GUI = Instance.new("ScreenGui")
GUI.Name = "ProfessionalChatBypass"
GUI.ResetOnSpawn = false
GUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
GUI.Parent = game:GetService("CoreGui")

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 280, 0, 120)
MainFrame.Position = UDim2.new(1, -290, 0.5, -60)
MainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Changed to black
MainFrame.BackgroundTransparency = 0.3 -- Set transparency to 0.7 (1 - 0.7 = 0.3)
MainFrame.BorderSizePixel = 0
MainFrame.Parent = GUI

local Shadow = Instance.new("ImageLabel")
Shadow.Name = "Shadow"
Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
Shadow.BackgroundTransparency = 1
Shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
Shadow.Size = UDim2.new(1, 30, 1, 30)
Shadow.Image = "rbxassetid://6014257812"
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ImageTransparency = 0.3 -- Shadow darker
Shadow.Parent = MainFrame

local Corner = Instance.new("UICorner")
Corner.CornerRadius = UDim.new(0, 6)
Corner.Parent = MainFrame

local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 30)
TitleBar.BackgroundColor3 = Color3.fromRGB(10, 10, 10) -- Darker black for title bar
TitleBar.BackgroundTransparency = 0.3 -- Set transparency to 0.7
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 6)
TitleCorner.Parent = TitleBar

local TitleGradient = Instance.new("UIGradient")
TitleGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 20)), -- Darker gradient
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))    -- Pure black
})
TitleGradient.Parent = TitleBar

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Size = UDim2.new(1, -60, 1, 0)
Title.Position = UDim2.new(0, 28, 0, 0)
Title.BackgroundTransparency = 1
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14
Title.Font = Enum.Font.GothamBold
Title.Text = "AK CHAT BYPASSER"
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TitleBar

local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 24, 0, 24)
CloseButton.Position = UDim2.new(1, -27, 0, 3)
CloseButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0) -- Darker red
CloseButton.BackgroundTransparency = 0.3 -- Set transparency to 0.7
CloseButton.Text = "×"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 16
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Parent = TitleBar

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 4)
CloseCorner.Parent = CloseButton

local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 24, 0, 24)
MinimizeButton.Position = UDim2.new(1, -54, 0, 3)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(100, 100, 0) -- Darker yellow
MinimizeButton.BackgroundTransparency = 0.3 -- Set transparency to 0.7
MinimizeButton.Text = "-"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 16
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Parent = TitleBar

local MinimizeCorner = Instance.new("UICorner")
MinimizeCorner.CornerRadius = UDim.new(0, 4)
MinimizeCorner.Parent = MinimizeButton

local InputBox = Instance.new("TextBox")
InputBox.Name = "InputBox"
InputBox.Size = UDim2.new(1, -20, 0, 30)
InputBox.Position = UDim2.new(0, 10, 0, 40)
InputBox.BackgroundColor3 = Color3.fromRGB(15, 15, 15) -- Darker input box
InputBox.BackgroundTransparency = 0.3 -- Set transparency to 0.7
InputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
InputBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
InputBox.PlaceholderText = "Enter message..."
InputBox.TextSize = 14
InputBox.Font = Enum.Font.Gotham
InputBox.ClearTextOnFocus = true
InputBox.Parent = MainFrame

local InputCorner = Instance.new("UICorner")
InputCorner.CornerRadius = UDim.new(0, 4)
InputCorner.Parent = InputBox

local SendButton = Instance.new("TextButton")
SendButton.Name = "SendButton"
SendButton.Size = UDim2.new(0, 180, 0, 26)
SendButton.Position = UDim2.new(0.5, -90, 1, -36)
SendButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray for button
SendButton.BackgroundTransparency = 0.3 -- Set transparency to 0.7
SendButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SendButton.Text = "Send"
SendButton.TextSize = 14
SendButton.Font = Enum.Font.GothamBold
SendButton.Parent = MainFrame

local SendCorner = Instance.new("UICorner")
SendCorner.CornerRadius = UDim.new(0, 4)
SendCorner.Parent = SendButton

local StatusIndicator = Instance.new("Frame")
StatusIndicator.Name = "StatusIndicator"
StatusIndicator.Size = UDim2.new(0, 6, 0, 6)
StatusIndicator.Position = UDim2.new(0, 12, 0, 12)
StatusIndicator.BackgroundColor3 = Color3.fromRGB(0, 150, 0) -- Darker green
StatusIndicator.BackgroundTransparency = 0.3 -- Set transparency to 0.7
StatusIndicator.Parent = TitleBar

local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(1, 0)
StatusCorner.Parent = StatusIndicator

------------------------------------------------------------------
-- Utility function for button effects

local function createButtonEffect(button)
    local originalColor = button.BackgroundColor3
    local originalTransparency = button.BackgroundTransparency

    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = originalColor:Lerp(Color3.fromRGB(50, 50, 50), 0.3),
            BackgroundTransparency = originalTransparency * 0.8
        }):Play()
    end)

    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = originalColor,
            BackgroundTransparency = originalTransparency
        }):Play()
    end)

    button.MouseButton1Down:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(0, 0, 0),
            BackgroundTransparency = originalTransparency * 0.5
        }):Play()
    end)

    button.MouseButton1Up:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.1), {
            BackgroundColor3 = originalColor,
            BackgroundTransparency = originalTransparency
        }):Play()
    end)
end

------------------------------------------------------------------
-- Draggable Frame Functionality

local function enableDragging(frame, handle)
    local dragging = false
    local dragStart, startPos

    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or
                         input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            local targetPos = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
            local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
            TweenService:Create(frame, tweenInfo, {Position = targetPos}):Play()
        end
    end)
end

------------------------------------------------------------------
-- Minimize Functionality

local minimized = false
MinimizeButton.MouseButton1Click:Connect(function()
    minimized = not minimized
    local targetSize = minimized and UDim2.new(0, 280, 0, 30) or UDim2.new(0, 280, 0, 120)
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

    TweenService:Create(MainFrame, tweenInfo, {Size = targetSize}):Play()
    TweenService:Create(Shadow, tweenInfo, {Size = UDim2.new(1, 30, targetSize.Y.Scale, targetSize.Y.Offset + 30)}):Play()

    InputBox.Visible = not minimized
    SendButton.Visible = not minimized
end)

------------------------------------------------------------------
-- Chat Send Function

local function sendChat(msg)
    local converted = filter(msg, letters, prefixCharacter, suffixCharacter)
    local filteredMessage = game:GetService("Chat"):FilterStringForBroadcast(converted, LocalPlayer)
    
    if filteredMessage ~= converted then
        showNotification("Message Tagged", "Message was filtered - nothing sent")
        InputBox.Text = ""
        return  -- Exit the function without sending
    end

    if TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService then
        ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents").SayMessageRequest:FireServer(converted, "All")
    else
        TextChatService.ChatInputBarConfiguration.TargetTextChannel:SendAsync(converted)
    end
    InputBox.Text = ""
end

local function processText()
    local inputText = InputBox.Text
    if inputText ~= "" then
       sendChat(inputText)
    end
end

SendButton.MouseButton1Click:Connect(processText)
InputBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        processText()
    end
end)

CloseButton.MouseButton1Click:Connect(function()
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local fadeOut = TweenService:Create(MainFrame, tweenInfo, {
        BackgroundTransparency = 1,
        Position = UDim2.new(1, 0, MainFrame.Position.Y.Scale, MainFrame.Position.Y.Offset)
    })

    fadeOut.Completed:Connect(function()
        GUI:Destroy()
    end)
    fadeOut:Play()
end)

------------------------------------------------------------------
-- Apply Button Effects

createButtonEffect(SendButton)
createButtonEffect(CloseButton)
createButtonEffect(MinimizeButton)

------------------------------------------------------------------
-- Enable Dragging

enableDragging(MainFrame, TitleBar)

------------------------------------------------------------------
-- Input Box Focus Effects

InputBox.Focused:Connect(function()
    TweenService:Create(InputBox, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(25, 25, 25),
        BackgroundTransparency = 0.2 -- Make slightly more opaque when focused
    }):Play()
end)

InputBox.FocusLost:Connect(function()
    TweenService:Create(InputBox, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.fromRGB(15, 15, 15),
        BackgroundTransparency = 0.3 -- Back to original transparency
    }):Play()
end)

------------------------------------------------------------------
-- Startup Animation

MainFrame.BackgroundTransparency = 1
Shadow.ImageTransparency = 1
TitleBar.BackgroundTransparency = 1
Title.TextTransparency = 1
CloseButton.BackgroundTransparency = 1
MinimizeButton.BackgroundTransparency = 1
InputBox.BackgroundTransparency = 1
SendButton.BackgroundTransparency = 1
StatusIndicator.BackgroundTransparency = 1

local function fadeIn(duration)
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    TweenService:Create(MainFrame, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
    TweenService:Create(Shadow, tweenInfo, {ImageTransparency = 0.3}):Play()
    TweenService:Create(TitleBar, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
    TweenService:Create(Title, tweenInfo, {TextTransparency = 0}):Play()
    TweenService:Create(CloseButton, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
    TweenService:Create(MinimizeButton, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
    TweenService:Create(InputBox, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
    TweenService:Create(SendButton, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
    TweenService:Create(StatusIndicator, tweenInfo, {BackgroundTransparency = 0.3}):Play() -- Set to 0.7 transparency
end

local function adjustFramePosition()
    local viewportSize = workspace.CurrentCamera.ViewportSize
    local frameSize = MainFrame.AbsoluteSize

    if MainFrame.AbsolutePosition.X + frameSize.X > viewportSize.X then
        MainFrame.Position = UDim2.new(1, -frameSize.X - 10, MainFrame.Position.Y.Scale, MainFrame.Position.Y.Offset)
    end

    if MainFrame.AbsolutePosition.Y + frameSize.Y > viewportSize.Y then
        MainFrame.Position = UDim2.new(MainFrame.Position.X.Scale, MainFrame.Position.X.Offset, 1, -frameSize.Y - 10)
    end
end

workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(adjustFramePosition)
adjustFramePosition()
fadeIn(0.5)

------------------------------------------------------------------
-- Status Indicator Pulse Animation

spawn(function()
    while wait(1) do
        if not GUI:IsDescendantOf(game:GetService("CoreGui")) then break end
        TweenService:Create(StatusIndicator, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
            BackgroundColor3 = Color3.fromRGB(0, 150, 0),
            BackgroundTransparency = 0.5
        }):Play()
        wait(1)
        TweenService:Create(StatusIndicator, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
            BackgroundColor3 = Color3.fromRGB(0, 150, 0),
            BackgroundTransparency = 0.3
        }):Play()
    end
end)

showNotification("Chat Interface", "Ready to use!")

------------------------------------------------------------------
-- Keyboard Shortcut (Ctrl + M to Minimize)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.M and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        MinimizeButton.MouseButton1Click:Fire()
    end
end)


--[[ superflymobilever ]]
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ContextActionService = game:GetService("ContextActionService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local flying = false
local flySpeed = 50
local TOGGLE_KEY = Enum.KeyCode.X
local isSelectingKeybind = false
local minSpeed = 0
local maxSpeed = 500
local workspace = game:GetService("Workspace")
local defaultGravity = workspace.Gravity

-- GUI Setup
local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local Shadow = Instance.new("ImageLabel")
local Container = Instance.new("Frame")
local Title = Instance.new("TextLabel")
local ToggleButton = Instance.new("TextButton")
local SpeedSlider = Instance.new("TextButton")
local KeybindButton = Instance.new("TextButton")
local StatusIndicator = Instance.new("Frame")

ScreenGui.Parent = player.PlayerGui
ScreenGui.ResetOnSpawn = false

MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 200, 0, 190)
MainFrame.Position = UDim2.new(0.85, 0, 0.4, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 35)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 30))
})
UIGradient.Rotation = 45
UIGradient.Parent = MainFrame

Shadow.Name = "Shadow"
Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
Shadow.BackgroundTransparency = 1
Shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
Shadow.Size = UDim2.new(1, 40, 1, 40)
Shadow.Image = "rbxassetid://5554236805"
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ImageTransparency = 0.4
Shadow.Parent = MainFrame

Container.Name = "Container"
Container.Size = UDim2.new(1, -20, 1, -20)
Container.Position = UDim2.new(0, 10, 0, 10)
Container.BackgroundTransparency = 1
Container.Parent = MainFrame

Title.Size = UDim2.new(0.7, 0, 0, 30)
Title.Position = UDim2.new(0, 8, 0, 0)
Title.BackgroundTransparency = 1
Title.Font = Enum.Font.GothamBold
Title.Text = "SUPERMAN FLY"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = Container

StatusIndicator.Size = UDim2.new(0, 8, 0, 8)
StatusIndicator.Position = UDim2.new(1, -15, 0, 11)
StatusIndicator.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
StatusIndicator.Parent = Container
local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(1, 0)
statusCorner.Parent = StatusIndicator

ToggleButton.Size = UDim2.new(1, 0, 0, 38)
ToggleButton.Position = UDim2.new(0, 0, 0, 40)
ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = "FLY: OFF"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 14
ToggleButton.AutoButtonColor = false
ToggleButton.Parent = Container

SpeedSlider.Size = UDim2.new(1, 0, 0, 38)
SpeedSlider.Position = UDim2.new(0, 0, 0, 88)
SpeedSlider.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
SpeedSlider.Font = Enum.Font.GothamSemibold
SpeedSlider.Text = "SPEED: " .. flySpeed
SpeedSlider.TextColor3 = Color3.fromRGB(255, 255, 255)
SpeedSlider.TextSize = 14
SpeedSlider.AutoButtonColor = false
SpeedSlider.Parent = Container

KeybindButton.Size = UDim2.new(1, 0, 0, 38)
KeybindButton.Position = UDim2.new(0, 0, 0, 136)
KeybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
KeybindButton.Font = Enum.Font.GothamSemibold
KeybindButton.Text = "KEYBIND: X"
KeybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
KeybindButton.TextSize = 14
KeybindButton.AutoButtonColor = false
KeybindButton.Parent = Container

for _, button in pairs({MainFrame, ToggleButton, SpeedSlider, KeybindButton}) do
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = button
	if button ~= MainFrame then
		local hover = false
		button.MouseEnter:Connect(function()
			hover = true
			TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = button.BackgroundColor3:Lerp(Color3.fromRGB(255, 255, 255), 0.1)}):Play()
		end)
		button.MouseLeave:Connect(function()
			hover = false
			local target
			if button == ToggleButton then
				target = (flying and Color3.fromRGB(75, 255, 75)) or Color3.fromRGB(255, 75, 75)
			else
				target = Color3.fromRGB(45, 45, 50)
			end
			TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = target}):Play()
		end)
	end
end

for _, button in pairs({ToggleButton, SpeedSlider, KeybindButton}) do
	button.MouseButton1Down:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.1), {Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, button.Size.Y.Scale, button.Size.Y.Offset - 2)}):Play()
	end)
	button.MouseButton1Up:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.1), {Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, button.Size.Y.Scale, button.Size.Y.Offset + 2)}):Play()
	end)
end

local ctrl = {f = 0, b = 0, l = 0, r = 0}
local lastctrl = {f = 0, b = 0, l = 0, r = 0}
local keyConnections = {}
local currentAnim = nil

local function PlayAnim(id, time, speed)
	pcall(function()
		if currentAnim then
			currentAnim:Stop(0.1)
		end
		player.Character.Animate.Disabled = true
		local hum = player.Character.Humanoid
		local animtrack = hum:GetPlayingAnimationTracks()
		for i, track in pairs(animtrack) do
			track:Stop()
		end
		local Anim = Instance.new("Animation")
		Anim.AnimationId = "rbxassetid://" .. id
		local loadanim = hum:LoadAnimation(Anim)
		loadanim:Play()
		loadanim.TimePosition = time
		loadanim:AdjustSpeed(speed)
		currentAnim = loadanim
		loadanim.Stopped:Connect(function()
			player.Character.Animate.Disabled = false
			for i, track in pairs(animtrack) do
				track:Stop()
			end
		end)
	end)
end

local function StopAnim()
	player.Character.Animate.Disabled = false
	local animtrack = player.Character.Humanoid:GetPlayingAnimationTracks()
	for i, track in pairs(animtrack) do
		track:Stop()
	end
end

local lastDirection = "none"
local turnTilt = 0
local maxTilt = 45

-- (The unused updateFly function remains here for reference.)
local function updateFly()
	if (not flying) then
		return
	end
	local camera = workspace.CurrentCamera
	local speed = flySpeed
	if (not rootPart:FindFirstChild("FlyGyro")) then
		local bg = Instance.new("BodyGyro")
		bg.Name = "FlyGyro"
		bg.P = 90000
		bg.maxTorque = Vector3.new(8999999488, 8999999488, 8999999488)
		bg.CFrame = rootPart.CFrame
		bg.Parent = rootPart
		local bv = Instance.new("BodyVelocity")
		bv.Name = "FlyVelocity"
		bv.Velocity = Vector3.new(0, 0.1, 0)
		bv.MaxForce = Vector3.new(8999999488, 8999999488, 8999999488)
		bv.Parent = rootPart
	end
	local bg = rootPart.FlyGyro
	local bv = rootPart.FlyVelocity
	if ((ctrl.f + ctrl.b + ctrl.l + ctrl.r) > 0) then
		bv.Velocity = ((camera.CoordinateFrame.lookVector * (ctrl.f + ctrl.b)) + ((camera.CoordinateFrame * CFrame.new(ctrl.l + ctrl.r, (ctrl.f + ctrl.b) * 0.2, 0).p) - camera.CoordinateFrame.p)) * speed
		lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
	elseif (((ctrl.f + ctrl.b + ctrl.l + ctrl.r) == 0 and speed ~= 0)) then
		bv.Velocity = ((camera.CoordinateFrame.lookVector * (lastctrl.f + lastctrl.b)) + ((camera.CoordinateFrame * CFrame.new(lastctrl.l + lastctrl.r, (lastctrl.f + lastctrl.b) * 0.2, 0).p) - camera.CoordinateFrame.p)) * speed
	else
		bv.Velocity = Vector3.new(0, 0.1, 0)
	end
	bg.CFrame = camera.CoordinateFrame * CFrame.Angles(-math.rad(ctrl.f * 90), 0, 0)
end

local function enhanceGUI()
	local UIGradient = Instance.new("UIGradient")
	UIGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 50)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 40))
	})
	UIGradient.Rotation = 45
	UIGradient.Parent = MainFrame
	for _, button in pairs({ToggleButton, SpeedSlider, KeybindButton}) do
		if button == ToggleButton then
			button.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
		else
			button.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
		end
	end
end

local isMobile = UserInputService.TouchEnabled
local TouchGui = nil
local TouchControls = nil
local TouchActive = false
if isMobile then
	TouchGui = Instance.new("ScreenGui")
	TouchGui.Name = "FlyTouchControls"
	TouchGui.ResetOnSpawn = false
	TouchGui.Parent = player.PlayerGui
	TouchControls = Instance.new("ImageButton")
	TouchControls.Size = UDim2.new(0, 150, 0, 150)
	TouchControls.Position = UDim2.new(0.1, 0, 0.5, 0)
	TouchControls.AnchorPoint = Vector2.new(0.5, 0.5)
	TouchControls.BackgroundTransparency = 0.5
	TouchControls.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	TouchControls.Image = "rbxassetid://8997446837"
	TouchControls.ImageTransparency = 0.5
	TouchControls.Visible = false
	TouchControls.Parent = TouchGui
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = TouchControls
end

local PlayerModule = require(player.PlayerScripts:WaitForChild("PlayerModule"))
local Controls = PlayerModule:GetControls()

local function toggleFlight()
	flying = not flying
	ToggleButton.Text = (flying and "FLY: ON") or "FLY: OFF"
	local targetColor = (flying and Color3.fromRGB(75, 255, 75)) or Color3.fromRGB(255, 75, 75)
	TweenService:Create(ToggleButton, TweenInfo.new(0.3), {BackgroundColor3 = targetColor}):Play()
	if flying then
		-- Jump first before activating flight
		humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		wait(0.2)  -- adjust delay as needed
		workspace.Gravity = 0
		humanoid.PlatformStand = true
		PlayAnim(10714347256, 4, 0)
		-- Retain your original animation logic:
		RunService:BindToRenderStep("FlyControls", Enum.RenderPriority.Input.Value, function()
			local moveVector = Controls:GetMoveVector()
			if ((4513 > 2726) and (1404 == 1404) and (moveVector.Magnitude > 0.1)) then
				if ((moveVector.Z < 0) or (3748 < 2212) or (1481 >= 2658)) then
					if ((moveVector.X < -0.1) or (1180 == 2180)) then
						if (lastDirection ~= "left") then
							lastDirection = "left"
							PlayAnim(10714177846, 4.65, 0)
						end
					elseif ((moveVector.X > 0.1) or (3220 == 1364)) then
						if ((lastDirection ~= "right") or (1054 > 3392)) then
							lastDirection = "right"
							PlayAnim(10714177846, 4.65, 0)
						end
					elseif ((lastDirection ~= "forward") or (676 >= 1642)) then
						lastDirection = "forward"
						PlayAnim(10714177846, 4.65, 0)
					end
				elseif ((4136 > 2397) and (4090 < 4653) and (moveVector.Z > 0)) then
					if (lastDirection ~= "backward") then
						lastDirection = "backward"
						PlayAnim(10147823318, 4.11, 0)
					end
				end
			elseif (lastDirection ~= "idle") then
				lastDirection = "idle"
				PlayAnim(10714347256, 4, 0)
			end
		end)
		-- Create the BodyGyro and BodyVelocity objects:
		local bg = Instance.new("BodyGyro")
		bg.Name = "FlyGyro"
		bg.P = 90000
		bg.maxTorque = Vector3.new(8999999488, 8999999488, 8999999488)
		bg.CFrame = rootPart.CFrame
		bg.Parent = rootPart
		local bv = Instance.new("BodyVelocity")
		bv.Name = "FlyVelocity"
		bv.Velocity = Vector3.new(0, 0.1, 0)
		bv.MaxForce = Vector3.new(8999999488, 8999999488, 8999999488)
		bv.Parent = rootPart
		-- Smooth flying movement and idle floating:
		RunService:BindToRenderStep("Fly", Enum.RenderPriority.Camera.Value, function(dt)
			local camera = workspace.CurrentCamera
			local moveVector = Controls:GetMoveVector()
			local targetVelocity
			if moveVector.Magnitude > 0 then
				targetVelocity = ((camera.CFrame.LookVector * -moveVector.Z) + (camera.CFrame.RightVector * moveVector.X)) * flySpeed
			else
				local t = tick()
				local floatAmplitude = 1    -- adjust amplitude as desired
				local floatSpeed = 2        -- adjust speed as desired
				local floatOffset = math.sin(t * floatSpeed) * floatAmplitude
				targetVelocity = Vector3.new(0, 0.1 + floatOffset, 0)
			end
			bv.Velocity = bv.Velocity:Lerp(targetVelocity, 0.1)
			local forwardTilt = (moveVector.Magnitude > 0 and ((moveVector.Z < 0 and -90) or (moveVector.Z * 50))) or 0
			local sideTilt = (moveVector.Magnitude > 0 and (-moveVector.X * 45)) or 0
			local targetCFrame = camera.CFrame * CFrame.Angles(math.rad(forwardTilt), 0, math.rad(sideTilt))
			bg.CFrame = bg.CFrame:Lerp(targetCFrame, 0.1)
		end)
	else
		workspace.Gravity = defaultGravity
		humanoid.PlatformStand = false
		lastDirection = "none"
		StopAnim()
		if rootPart:FindFirstChild("FlyGyro") then
			rootPart.FlyGyro:Destroy()
		end
		if rootPart:FindFirstChild("FlyVelocity") then
			rootPart.FlyVelocity:Destroy()
		end
		RunService:UnbindFromRenderStep("FlyControls")
		RunService:UnbindFromRenderStep("Fly")
	end
end

ToggleButton.MouseButton1Click:Connect(toggleFlight)

SpeedSlider.MouseButton1Down:Connect(function()
	local mouse = player:GetMouse()
	local moveConnection
	local releaseConnection
	local function updateSpeed(mouseX)
		local relativeX = math.clamp((mouseX - SpeedSlider.AbsolutePosition.X) / SpeedSlider.AbsoluteSize.X, 0, 1)
		flySpeed = math.floor(minSpeed + ((maxSpeed - minSpeed) * relativeX))
		if flySpeed < 10 then
			flySpeed = 10
		end
		SpeedSlider.Text = "SPEED: " .. flySpeed
		local speedColor = Color3.fromRGB(math.floor(255 - (relativeX * 180)), math.floor(75 + (relativeX * 180)), 75)
		TweenService:Create(SpeedSlider, TweenInfo.new(0.1), {BackgroundColor3 = speedColor}):Play()
	end
	updateSpeed(mouse.X)
	moveConnection = mouse.Move:Connect(function()
		updateSpeed(mouse.X)
	end)
	releaseConnection = UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			if moveConnection then
				moveConnection:Disconnect()
			end
			if releaseConnection then
				releaseConnection:Disconnect()
			end
		end
	end)
end)

local function handleKeybind(input)
	if not isSelectingKeybind and (input.KeyCode == TOGGLE_KEY) then
		toggleFlight()
	end
end

KeybindButton.MouseButton1Click:Connect(function()
	isSelectingKeybind = true
	KeybindButton.Text = "PRESS ANY KEY..."
	KeybindButton.BackgroundColor3 = Color3.fromRGB(75, 255, 75)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then
		return
	end
	if isSelectingKeybind then
		if input.UserInputType == Enum.UserInputType.Keyboard then
			local blacklistedKeys = {
				Enum.KeyCode.Unknown,
				Enum.KeyCode.LeftShift,
				Enum.KeyCode.RightShift,
				Enum.KeyCode.LeftControl,
				Enum.KeyCode.RightControl,
				Enum.KeyCode.LeftAlt,
				Enum.KeyCode.RightAlt,
				Enum.KeyCode.LeftSuper,
				Enum.KeyCode.RightSuper
			}
			for _, blockedKey in ipairs(blacklistedKeys) do
				if input.KeyCode == blockedKey then
					return
				end
			end
			isSelectingKeybind = false
			TOGGLE_KEY = input.KeyCode
			KeybindButton.Text = "KEYBIND: " .. input.KeyCode.Name
			KeybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
		end
	else
		handleKeybind(input)
	end
end)

UserInputService.InputBegan:Connect(function(input)
	if isSelectingKeybind and input.UserInputType == Enum.UserInputType.MouseButton1 then
		local mousePosition = UserInputService:GetMouseLocation()
		local buttonPosition = KeybindButton.AbsolutePosition
		local buttonSize = KeybindButton.AbsoluteSize
		if mousePosition.X < buttonPosition.X or mousePosition.X > (buttonPosition.X + buttonSize.X) or mousePosition.Y < buttonPosition.Y or mousePosition.Y > (buttonPosition.Y + buttonSize.Y) then
			isSelectingKeybind = false
			KeybindButton.Text = "KEYBIND: " .. TOGGLE_KEY.Name
			KeybindButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
		end
	end
end)

player.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	humanoid = character:WaitForChild("Humanoid")
	rootPart = character:WaitForChild("HumanoidRootPart")
	if flying then
		workspace.Gravity = defaultGravity
		toggleFlight()
	end
end)

local function enableDragging(frame)
	local dragging = false
	local dragTouch = nil
	local dragStart = nil
	local startPos = nil
	frame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch and not dragging then
			dragging = true
			dragTouch = input.Touch.TouchId
			dragStart = input.Position
			startPos = frame.Position
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch and dragging and input.Touch.TouchId == dragTouch then
			local delta = input.Position - dragStart
			frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
	UserInputService.TouchEnded:Connect(function(input)
		if input.Touch.TouchId == dragTouch then
			dragging = false
			dragTouch = nil
		end
	end)
end

local function updateSpeedSlider()
	local sliding = false
	local touchId = nil
	local function updateSpeed(inputPosition)
		local mainFramePos = MainFrame.AbsolutePosition
		local mainFrameSize = MainFrame.AbsoluteSize
		if inputPosition.X < mainFramePos.X or inputPosition.X > (mainFramePos.X + mainFrameSize.X) or inputPosition.Y < mainFramePos.Y or inputPosition.Y > (mainFramePos.Y + mainFrameSize.Y) then
			sliding = false
			touchId = nil
			return
		end
		local relativeX = math.clamp((inputPosition.X - SpeedSlider.AbsolutePosition.X) / SpeedSlider.AbsoluteSize.X, 0, 1)
		flySpeed = math.floor(minSpeed + ((maxSpeed - minSpeed) * relativeX))
		if flySpeed < 10 then
			flySpeed = 10
		end
		SpeedSlider.Text = "SPEED: " .. flySpeed
		local speedColor = Color3.fromRGB(math.floor(255 - (relativeX * 180)), math.floor(75 + (relativeX * 180)), 75)
		SpeedSlider.BackgroundColor3 = speedColor
	end
	SpeedSlider.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			sliding = true
			touchId = input.Touch.TouchId
			updateSpeed(input.Position)
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if sliding and input.UserInputType == Enum.UserInputType.Touch and input.Touch.TouchId == touchId then
			updateSpeed(input.Position)
		end
	end)
	UserInputService.TouchEnded:Connect(function(input)
		if input.Touch.TouchId == touchId then
			sliding = false
			touchId = nil
		end
	end)
	game:GetService("RunService").RenderStepped:Connect(function()
		if sliding then
			local touches = UserInputService:GetTouches()
			local touchFound = false
			for _, touch in ipairs(touches) do
				if touch.TouchId == touchId then
					touchFound = true
					updateSpeed(touch.Position)
					break
				end
			end
			if not touchFound then
				sliding = false
				touchId = nil
			end
		end
	end)
end
updateSpeedSlider()
enableDragging(MainFrame)
enhanceGUI()

for _, button in pairs({ToggleButton, SpeedSlider, KeybindButton}) do
	button.MouseButton1Down:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.1), {Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, button.Size.Y.Scale, button.Size.Y.Offset - 2)}):Play()
	end)
	button.MouseButton1Up:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.1), {Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, button.Size.Y.Scale, button.Size.Y.Offset + 2)}):Play()
	end)
end

local function updateGUI()
	if SpeedSlider then
		SpeedSlider:Destroy()
	end
	local SpeedControl = Instance.new("Frame")
	SpeedControl.Name = "SpeedControl"
	SpeedControl.Size = UDim2.new(1, 0, 0, 38)
	SpeedControl.Position = UDim2.new(0, 0, 0, 88)
	SpeedControl.BackgroundTransparency = 1
	SpeedControl.Parent = Container
	local MinusButton = Instance.new("TextButton")
	MinusButton.Size = UDim2.new(0.2, 0, 1, 0)
	MinusButton.Position = UDim2.new(0, 0, 0, 0)
	MinusButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
	MinusButton.Text = "-"
	MinusButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	MinusButton.TextSize = 24
	MinusButton.Font = Enum.Font.GothamBold
	MinusButton.Parent = SpeedControl
	local SpeedDisplay = Instance.new("TextLabel")
	SpeedDisplay.Size = UDim2.new(0.6, 0, 1, 0)
	SpeedDisplay.Position = UDim2.new(0.2, 0, 0, 0)
	SpeedDisplay.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
	SpeedDisplay.Text = "SPEED: " .. flySpeed
	SpeedDisplay.TextColor3 = Color3.fromRGB(255, 255, 255)
	SpeedDisplay.TextSize = 14
	SpeedDisplay.Font = Enum.Font.GothamSemibold
	SpeedDisplay.Parent = SpeedControl
	local PlusButton = Instance.new("TextButton")
	PlusButton.Size = UDim2.new(0.2, 0, 1, 0)
	PlusButton.Position = UDim2.new(0.8, 0, 0, 0)
	PlusButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
	PlusButton.Text = "+"
	PlusButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	PlusButton.TextSize = 24
	PlusButton.Font = Enum.Font.GothamBold
	PlusButton.Parent = SpeedControl
	local CloseButton = Instance.new("TextButton")
	CloseButton.Size = UDim2.new(0, 25, 0, 25)
	CloseButton.Position = UDim2.new(1, -8, 0, 3)
	CloseButton.AnchorPoint = Vector2.new(1, 0)
	CloseButton.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
	CloseButton.Text = "×"
	CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	CloseButton.TextSize = 20
	CloseButton.Font = Enum.Font.GothamBold
	CloseButton.Parent = Container
	local MinimizeButton = Instance.new("TextButton")
	MinimizeButton.Size = UDim2.new(0, 25, 0, 25)
	MinimizeButton.Position = UDim2.new(1, -38, 0, 3)
	MinimizeButton.AnchorPoint = Vector2.new(1, 0)
	MinimizeButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
	MinimizeButton.Text = "-"
	MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	MinimizeButton.TextSize = 20
	MinimizeButton.Font = Enum.Font.GothamBold
	MinimizeButton.Parent = Container
	for _, button in pairs({MinusButton, SpeedDisplay, PlusButton, CloseButton, MinimizeButton}) do
		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = button
	end
	for _, button in pairs({MinusButton, PlusButton, CloseButton, MinimizeButton}) do
		button.MouseEnter:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = button.BackgroundColor3:Lerp(Color3.fromRGB(255, 255, 255), 0.1)}):Play()
		end)
		button.MouseLeave:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = (button == CloseButton and Color3.fromRGB(255, 75, 75)) or Color3.fromRGB(45, 45, 50)}):Play()
		end)
	end
	local function updateSpeedDisplay()
		SpeedDisplay.Text = "SPEED: " .. flySpeed
		local relativeSpeed = (flySpeed - minSpeed) / (maxSpeed - minSpeed)
		local speedColor = Color3.fromRGB(math.floor(255 - (relativeSpeed * 180)), math.floor(75 + (relativeSpeed * 180)), 75)
		TweenService:Create(SpeedDisplay, TweenInfo.new(0.1), {BackgroundColor3 = speedColor}):Play()
	end
	MinusButton.MouseButton1Click:Connect(function()
		flySpeed = math.max(10, flySpeed - 10)
		updateSpeedDisplay()
	end)
	PlusButton.MouseButton1Click:Connect(function()
		flySpeed = math.min(maxSpeed, flySpeed + 10)
		updateSpeedDisplay()
	end)
	CloseButton.MouseButton1Click:Connect(function()
		for _, child in pairs(Container:GetChildren()) do
			TweenService:Create(child, TweenInfo.new(0.2), {BackgroundTransparency = 1}):Play()
			if child:IsA("TextButton") or child:IsA("TextLabel") then
				TweenService:Create(child, TweenInfo.new(0.2), {TextTransparency = 1}):Play()
			end
		end
		wait(0.2)
		TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, MainFrame.Size.X.Offset, 0, 0), Position = UDim2.new(MainFrame.Position.X.Scale, MainFrame.Position.X.Offset, MainFrame.Position.Y.Scale, MainFrame.Position.Y.Offset + (MainFrame.Size.Y.Offset / 2))}):Play()
		if flying then
			toggleFlight()
		end
		wait(0.3)
		ScreenGui:Destroy()
	end)
	local minimized = false
	MinimizeButton.MouseButton1Click:Connect(function()
		if minimized then
			TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = MainFrame:GetAttribute("OriginalSize")}):Play()
			wait(0.1)
			for _, child in pairs(Container:GetChildren()) do
				if child ~= Title and child ~= CloseButton and child ~= MinimizeButton then
					child.Visible = true
					TweenService:Create(child, TweenInfo.new(0.2), {BackgroundTransparency = 0}):Play()
					if child:IsA("TextButton") or child:IsA("TextLabel") then
						TweenService:Create(child, TweenInfo.new(0.2), {TextTransparency = 0}):Play()
					end
				end
			end
			MinimizeButton.Text = "-"
		else
			if not MainFrame:GetAttribute("OriginalSize") then
				MainFrame:SetAttribute("OriginalSize", MainFrame.Size)
			end
			for _, child in pairs(Container:GetChildren()) do
				if child ~= Title and child ~= CloseButton and child ~= MinimizeButton then
					TweenService:Create(child, TweenInfo.new(0.2), {BackgroundTransparency = 1}):Play()
					if child:IsA("TextButton") or child:IsA("TextLabel") then
						TweenService:Create(child, TweenInfo.new(0.2), {TextTransparency = 1}):Play()
					end
					delay(0.2, function()
						child.Visible = false
					end)
				end
			end
			wait(0.2)
			TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 200, 0, 40)}):Play()
			MinimizeButton.Text = "+"
		end
		minimized = not minimized
	end)
	local function enableDragging(frame)
		local dragging = false
		local dragInput
		local dragStart
		local startPos
		frame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
				dragging = true
				dragStart = input.Position
				startPos = frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragging = false
					end
				end)
			end
		end)
		frame.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
				dragInput = input
			end
		end)
		UserInputService.InputChanged:Connect(function(input)
			if input == dragInput and dragging then
				local delta = input.Position - dragStart
				frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
			end
		end)
	end
	enableDragging(MainFrame)
end
updateGUI()


--[[ superflypcver ]]
--------------------------------------------------
-- COMPLETTES FLUGSYSTEM MIT BOBBING & BACKWARDS-ANIMATION
--------------------------------------------------

-- Dienste laden
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

-- Lokale Variablen
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
local originalGravity = Workspace.Gravity

local isFlying = false
local flightSpeed = 50           -- Standardfluggeschwindigkeit
local toggleKey = Enum.KeyCode.X   -- Standard Umschalttaste
local waitingForKeybind = false

-- Steuerungstabelle für Flugbewegung (W, A, S, D)
local moveState = {
	forward = 0,    -- W
	backward = 0,   -- S
	left = 0,       -- A
	right = 0       -- D
}

-- Zustände für Flugausrichtung (Rotation)
local currentCF = nil       -- Aktuell interpolierter CFrame der Rotation
local currentRoll = 0       -- Aktueller Rollwinkel (für seitliches Neigen)
local maxRoll = 45          -- Maximaler Rollwinkel in Grad
local lerpCoef = 0.1        -- Übergangskoeffizient für Rotation

-- Variable für den Sliding-Effekt (inertiales Gleiten)
local slideDamping = 0.05   -- Wert zwischen 0 und 1 (kleiner = mehr Slide)
local currentVelocity = Vector3.new(0, 0, 0)

-- Parameter für den Bobbing-Effekt (sanftes Auf- und Abgleiten beim Schweben)
local bobbingFrequency = 1    -- Frequenz des Sinus (je kleiner = längere Periode)
local bobbingAmplitude = 0.5  -- Amplitude des Bobbings (Höhe der Schwankung)

-- Verbindungstabellen, um alle Events später sauber zu trennen
local flightConns = {}
local globalConns = {}

-- Variable für aktuell laufende Animation
local currentAnimTrack = nil

--------------------------------------------------
-- ANIMATIONEN (Starten/Stoppen)
--------------------------------------------------
local function disableDefaultAnimate()
	local animate = character:FindFirstChild("Animate")
	if animate then
		animate.Disabled = true
	end
end

local function enableDefaultAnimate()
	local animate = character:FindFirstChild("Animate")
	if animate then
		animate.Disabled = false
	end
end

local function playAnimation(animId, startTime, speed)
	-- Beende vorherige Animation
	if currentAnimTrack then
		currentAnimTrack:Stop(0.1)
		currentAnimTrack = nil
	end
	disableDefaultAnimate()
	-- Stoppe alle bereits laufenden Animationen
	for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop()
	end
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://" .. tostring(animId)
	currentAnimTrack = humanoid:LoadAnimation(anim)
	currentAnimTrack:Play()
	currentAnimTrack.TimePosition = startTime
	currentAnimTrack:AdjustSpeed(speed)
end

local function stopAnimation()
	if currentAnimTrack then
		currentAnimTrack:Stop(0.1)
		currentAnimTrack = nil
	end
	enableDefaultAnimate()
	for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop()
	end
end

--------------------------------------------------
-- HILFSFUNKTION: UI-Elemente erstellen
--------------------------------------------------
local function createElement(className, properties, parent)
	local obj = Instance.new(className)
	for prop, val in pairs(properties) do
		obj[prop] = val
	end
	if parent then
		obj.Parent = parent
	end
	return obj
end

--------------------------------------------------
-- GUI ERSTELLEN (Sauber innerhalb des Rahmens)
--------------------------------------------------
local flyGui = createElement("ScreenGui", {Name = "FlyGui", ResetOnSpawn = false}, player:WaitForChild("PlayerGui"))

-- Hauptfenster: Größe 220x170, sodass alles reinpasst
local mainFrame = createElement("Frame", {
	Name = "MainFrame",
	Size = UDim2.new(0, 220, 0, 170),
	Position = UDim2.new(0.5, -110, 0.5, -85),
	BackgroundColor3 = Color3.fromRGB(35, 35, 40),
	BorderSizePixel = 0,
	Active = true
}, flyGui)
createElement("UICorner", {CornerRadius = UDim.new(0, 10)}, mainFrame)

-- Titel
local titleLabel = createElement("TextLabel", {
	Name = "TitleLabel",
	Size = UDim2.new(1, 0, 0, 40),
	Position = UDim2.new(0, 0, 0, 0),
	BackgroundTransparency = 1,
	Text = "Superman Fly",
	Font = Enum.Font.GothamBold,
	TextSize = 24,
	TextColor3 = Color3.new(1, 1, 1)
}, mainFrame)

-- Toggle Button (An/Aus Flugmodus)
local toggleButton = createElement("TextButton", {
	Name = "ToggleButton",
	Size = UDim2.new(0.9, 0, 0, 30),
	Position = UDim2.new(0.05, 0, 0, 45),
	BackgroundColor3 = Color3.fromRGB(200, 50, 50),
	Text = "FLY: OFF",
	Font = Enum.Font.GothamBold,
	TextSize = 20,
	TextColor3 = Color3.new(1, 1, 1),
	BorderSizePixel = 0
}, mainFrame)
createElement("UICorner", {CornerRadius = UDim.new(0, 8)}, toggleButton)

-- Speed Control Panel
local speedFrame = createElement("Frame", {
	Name = "SpeedFrame",
	Size = UDim2.new(0, 200, 0, 30),
	Position = UDim2.new(0, 10, 0, 80),
	BackgroundTransparency = 1
}, mainFrame)

local minusButton = createElement("TextButton", {
	Name = "MinusButton",
	Size = UDim2.new(0, 30, 0, 30),
	Position = UDim2.new(0, 0, 0, 0),
	BackgroundColor3 = Color3.fromRGB(50, 50, 50),
	Text = "–",
	Font = Enum.Font.GothamBold,
	TextSize = 24,
	TextColor3 = Color3.new(1, 1, 1),
	BorderSizePixel = 0
}, speedFrame)
createElement("UICorner", {CornerRadius = UDim.new(0, 8)}, minusButton)

local speedTextBox = createElement("TextBox", {
	Name = "SpeedTextBox",
	Size = UDim2.new(0, 140, 0, 30),
	Position = UDim2.new(0, 30, 0, 0),
	BackgroundColor3 = Color3.fromRGB(50, 50, 50),
	Text = tostring(flightSpeed),
	Font = Enum.Font.GothamBold,
	TextSize = 20,
	TextColor3 = Color3.new(1, 1, 1),
	ClearTextOnFocus = false,
	BorderSizePixel = 0,
	TextScaled = true
}, speedFrame)
createElement("UICorner", {CornerRadius = UDim.new(0, 8)}, speedTextBox)

local plusButton = createElement("TextButton", {
	Name = "PlusButton",
	Size = UDim2.new(0, 30, 0, 30),
	Position = UDim2.new(0, 170, 0, 0),
	BackgroundColor3 = Color3.fromRGB(50, 50, 50),
	Text = "+",
	Font = Enum.Font.GothamBold,
	TextSize = 24,
	TextColor3 = Color3.new(1, 1, 1),
	BorderSizePixel = 0
}, speedFrame)
createElement("UICorner", {CornerRadius = UDim.new(0, 8)}, plusButton)

-- Keybind Button
local keybindButton = createElement("TextButton", {
	Name = "KeybindButton",
	Size = UDim2.new(0.9, 0, 0, 30),
	Position = UDim2.new(0.05, 0, 0, 120),
	BackgroundColor3 = Color3.fromRGB(50, 50, 50),
	Text = "KEYBIND: " .. toggleKey.Name,
	Font = Enum.Font.GothamBold,
	TextSize = 20,
	TextColor3 = Color3.new(1, 1, 1),
	BorderSizePixel = 0
}, mainFrame)
createElement("UICorner", {CornerRadius = UDim.new(0, 8)}, keybindButton)

-- Close Button (Bleibt in der Ecke)
local closeButton = createElement("TextButton", {
	Name = "CloseButton",
	Size = UDim2.new(0, 30, 0, 30),
	Position = UDim2.new(1, -35, 0, 5),
	BackgroundColor3 = Color3.fromRGB(200, 50, 50),
	Text = "X",
	Font = Enum.Font.GothamBold,
	TextSize = 20,
	TextColor3 = Color3.new(1, 1, 1),
	BorderSizePixel = 0
}, mainFrame)
createElement("UICorner", {CornerRadius = UDim.new(0, 8)}, closeButton)

--------------------------------------------------
-- GUI: Drag & Drop (Hauptframe verschiebbar)
--------------------------------------------------
local dragging = false
local dragStartPos, dragStartMousePos

mainFrame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStartPos = mainFrame.Position
		dragStartMousePos = input.Position
	end
end)

mainFrame.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStartMousePos
		mainFrame.Position = UDim2.new(dragStartPos.X.Scale, dragStartPos.X.Offset + delta.X, dragStartPos.Y.Scale, dragStartPos.Y.Offset + delta.Y)
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)

--------------------------------------------------
-- Fluggeschwindigkeit anpassen
--------------------------------------------------
speedTextBox.FocusLost:Connect(function()
	local newSpeed = tonumber(speedTextBox.Text)
	if newSpeed then
		flightSpeed = newSpeed
	else
		speedTextBox.Text = tostring(flightSpeed)
	end
end)

-- Plus/Minus Button Ereignisse zum Erhöhen/Verringern der Geschwindigkeit
local speedStep = 5  -- Schrittweite

plusButton.MouseButton1Click:Connect(function()
	flightSpeed = flightSpeed + speedStep
	speedTextBox.Text = tostring(flightSpeed)
end)

minusButton.MouseButton1Click:Connect(function()
	flightSpeed = math.max(0, flightSpeed - speedStep)
	speedTextBox.Text = tostring(flightSpeed)
end)

--------------------------------------------------
-- Umschalten des Keybinds
--------------------------------------------------
keybindButton.MouseButton1Click:Connect(function()
	waitingForKeybind = true
	keybindButton.Text = "PRESS ANY KEY..."
	keybindButton.BackgroundColor3 = Color3.fromRGB(75, 255, 75)
end)

--------------------------------------------------
-- GLOBALE TASTEN- UND KEYBIND-VERARBEITUNG
--------------------------------------------------
local function onGlobalInput(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		if waitingForKeybind then
			-- Ignoriere Modifier
			local ignored = {
				Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift,
				Enum.KeyCode.LeftControl, Enum.KeyCode.RightControl,
				Enum.KeyCode.LeftAlt, Enum.KeyCode.RightAlt,
				Enum.KeyCode.LeftSuper, Enum.KeyCode.RightSuper,
				Enum.KeyCode.Unknown
			}
			for _, key in ipairs(ignored) do
				if input.KeyCode == key then
					return
				end
			end
			waitingForKeybind = false
			toggleKey = input.KeyCode
			keybindButton.Text = "KEYBIND: " .. toggleKey.Name
			keybindButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		elseif input.KeyCode == toggleKey then
			-- Umschalten des Flugmodus
			if not isFlying then
				-- Flugmodus starten
				isFlying = true
				toggleButton.Text = "FLY: ON"
				local ti = TweenInfo.new(0.3)
				local tween = TweenService:Create(toggleButton, ti, {BackgroundColor3 = Color3.fromRGB(75, 255, 75)})
				tween:Play()

				-------------------------------
				-- FLUGMODUS STARTEN
				-------------------------------
				Workspace.Gravity = 0
				humanoid.PlatformStand = true
				-- Sofort-Animation beim Aktivieren (ID 10714347256, Startzeit 4 s, Speed 0)
				playAnimation(10714347256, 4, 0)

				-- Erstelle BodyGyro für Drehung
				local gyro = Instance.new("BodyGyro")
				gyro.Name = "FlyGyro"
				gyro.Parent = hrp
				gyro.P = 90000
				gyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
				gyro.CFrame = hrp.CFrame

				-- Erstelle BodyVelocity für Bewegung
				local bv = Instance.new("BodyVelocity")
				bv.Name = "FlyVelocity"
				bv.Parent = hrp
				bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
				-- Setze einen minimalen Y-Vektor, damit die Physik aktiv bleibt
				bv.Velocity = Vector3.new(0, 0.1, 0)

				-- Reset des aktuellen Geschwindigkeitsvektors
				currentVelocity = Vector3.new(0, 0, 0)

				-- RenderStep-Update: Berechnet in jedem Frame die neue Position und Rotation
				local flightUpdate = RunService.RenderStepped:Connect(function(deltaTime)
					local cam = Workspace.CurrentCamera

					-- Berechne Input: Vorwärts (W) minus Rückwärts (S) und seitlich (A/D)
					local fwd = moveState.forward - moveState.backward
					local side = moveState.right - moveState.left

					-- Input-Vektor basierend auf der Kameraausrichtung
					local inputVec = (cam.CFrame.LookVector * fwd) + (cam.CFrame.RightVector * side)

					-- Falls Vorwärts gedrückt: füge einen leichten Höhenoffset hinzu
					if fwd ~= 0 then
						inputVec = inputVec + Vector3.new(0, 0.2 * fwd, 0)
					end

					-- Bobbing-Effekt: Wenn keinerlei Input vorhanden ist (Schwebezustand)
					local bobbing = math.sin(tick() * bobbingFrequency) * bobbingAmplitude
					local desiredVelocity = Vector3.new(0, 0, 0)
					if inputVec.Magnitude > 0 then
						desiredVelocity = inputVec.Unit * flightSpeed
					else
						-- Beim Schweben: sanftes Auf und Ab
						desiredVelocity = Vector3.new(0, bobbing, 0)
					end

					-- Sanfte Interpolation (Sliding/Inertia)
					currentVelocity = currentVelocity:Lerp(desiredVelocity, 0.1)
					bv.Velocity = currentVelocity

					-- Berechne gewünschte Rotation:
					-- Bei Vorwärtsflug neigen wir den Pitch auf -90° plus Roll,
					-- ansonsten erfolgt eine leichtere Pitch-Anpassung, wobei auch rückwärts
					-- (fwd < 0) geneigt wird.
					local desiredCF
					if fwd > 0 then
						desiredCF = cam.CFrame * CFrame.Angles(math.rad(-90), 0, math.rad(currentRoll))
					else
						desiredCF = cam.CFrame * CFrame.Angles(math.rad(-45 * fwd), 0, math.rad(currentRoll))
					end
					if currentCF then
						currentCF = currentCF:Lerp(desiredCF, lerpCoef)
					else
						currentCF = desiredCF
					end
					gyro.CFrame = currentCF
				end)
				table.insert(flightConns, flightUpdate)

				-- Verbinde Tasteneingaben für Richtungssteuerung im Flugmodus
				local function onFlyInputBegan(input, gameProc)
					if gameProc then return end
					if input.UserInputType == Enum.UserInputType.Keyboard then
						local key = input.KeyCode
						if key == Enum.KeyCode.W then
							moveState.forward = 1
							playAnimation(10714177846, 4.65, 0)
						elseif key == Enum.KeyCode.S then
							-- Bei Rückwärtsflug: Verwende dieselbe Animation wie beim Stehen (10714347256)
							moveState.backward = 1
							playAnimation(10714347256, 4, 0)
						elseif key == Enum.KeyCode.A then
							moveState.left = 1
							if moveState.forward > 0 then
								playAnimation(10714177846, 4.65, 0)
							end
						elseif key == Enum.KeyCode.D then
							moveState.right = 1
							if moveState.forward > 0 then
								playAnimation(10714177846, 4.65, 0)
							end
						end
					end
				end
				local flyBegan = UserInputService.InputBegan:Connect(onFlyInputBegan)
				table.insert(flightConns, flyBegan)

				local function onFlyInputEnded(input, gameProc)
					if input.UserInputType == Enum.UserInputType.Keyboard then
						local key = input.KeyCode
						if key == Enum.KeyCode.W then
							moveState.forward = 0
							playAnimation(10714347256, 4, 0)
						elseif key == Enum.KeyCode.S then
							moveState.backward = 0
							playAnimation(10714347256, 4, 0)
						elseif key == Enum.KeyCode.A then
							moveState.left = 0
							if moveState.forward > 0 then
								playAnimation(10714177846, 4.65, 0)
							end
						elseif key == Enum.KeyCode.D then
							moveState.right = 0
							if moveState.forward > 0 then
								playAnimation(10714177846, 4.65, 0)
							end
						end
					end
				end
				local flyEnded = UserInputService.InputEnded:Connect(onFlyInputEnded)
				table.insert(flightConns, flyEnded)

			else
				-- Flugmodus beenden
				isFlying = false
				toggleButton.Text = "FLY: OFF"
				local ti = TweenInfo.new(0.3)
				local tween = TweenService:Create(toggleButton, ti, {BackgroundColor3 = Color3.fromRGB(200, 50, 50)})
				tween:Play()

				Workspace.Gravity = originalGravity
				humanoid.PlatformStand = false
				stopAnimation()
				if hrp:FindFirstChild("FlyGyro") then hrp.FlyGyro:Destroy() end
				if hrp:FindFirstChild("FlyVelocity") then hrp.FlyVelocity:Destroy() end
				-- Trenne alle im Flugmodus verbundenen Events
				for _, conn in ipairs(flightConns) do
					if conn.Connected then conn:Disconnect() end
				end
				flightConns = {}
				moveState = {forward = 0, backward = 0, left = 0, right = 0}
			end
		end
	end
end
local globalInputConn = UserInputService.InputBegan:Connect(onGlobalInput)
table.insert(globalConns, globalInputConn)

--------------------------------------------------
-- Toggle-Button: Gleicher Effekt wie die Umschalttaste
--------------------------------------------------
toggleButton.MouseButton1Click:Connect(function()
	onGlobalInput({KeyCode = toggleKey, UserInputType = Enum.UserInputType.Keyboard}, false)
end)

--------------------------------------------------
-- CHARACTER-RELOAD: Aktualisiere Referenzen und beende Flugmodus (zur Sicherheit)
--------------------------------------------------
player.CharacterAdded:Connect(function(newChar)
	character = newChar
	humanoid = character:WaitForChild("Humanoid")
	hrp = character:WaitForChild("HumanoidRootPart")
	if isFlying then
		isFlying = false
		toggleButton.Text = "FLY: OFF"
		Workspace.Gravity = originalGravity
		humanoid.PlatformStand = false
		stopAnimation()
		if hrp:FindFirstChild("FlyGyro") then hrp.FlyGyro:Destroy() end
		if hrp:FindFirstChild("FlyVelocity") then hrp.FlyVelocity:Destroy() end
		for _, conn in ipairs(flightConns) do
			if conn.Connected then conn:Disconnect() end
		end
		flightConns = {}
		moveState = {forward = 0, backward = 0, left = 0, right = 0}
	end
end)

--------------------------------------------------
-- CLOSE-BUTTON: Aufräumen und Skript beenden
--------------------------------------------------
closeButton.MouseButton1Click:Connect(function()
	if isFlying then
		isFlying = false
		Workspace.Gravity = originalGravity
		humanoid.PlatformStand = false
		stopAnimation()
		if hrp:FindFirstChild("FlyGyro") then hrp.FlyGyro:Destroy() end
		if hrp:FindFirstChild("FlyVelocity") then hrp.FlyVelocity:Destroy() end
		for _, conn in ipairs(flightConns) do
			if conn.Connected then conn:Disconnect() end
		end
		flightConns = {}
	end
	for _, conn in ipairs(globalConns) do
		if conn.Connected then conn:Disconnect() end
	end
	flyGui:Destroy()
	script:Destroy()
end)


--[[ ad ]]
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function chatMessage(str)
    str = tostring(str)
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local generalChannel = TextChatService:FindFirstChild("TextChannels"):FindFirstChild("RBXGeneral")
        if generalChannel then
            generalChannel:SendAsync(str)
        else
            warn("RBXGeneral channel not found!")
        end
    else
        local chatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents"):FindFirstChild("SayMessageRequest")
        if chatEvent then
            chatEvent:FireServer(str, "All")
        else
            warn("DefaultChatSystemChatEvents not found!")
        end
    end
end

local blob = "\u{000D}"
local clearMessage = ""..string.rep(blob, 197)..""


for i = 1, 1 do
    chatMessage(clearMessage) 
end



loadstring(game:HttpGet("https://raw.githubusercontent.com/vqmpjayZ/More-Scripts/refs/heads/main/Anthony's%20ACL"))()

wait(1)

local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Create notification
StarterGui:SetCore("SendNotification", {
    Title = "AK ADMIN",
    Text = "You need to change your Roblox Language to Қазақ тілі so it won't get tagged",
    Duration = 5
})

local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Function to send a chat message
local function chatMessage(str)
    str = tostring(str)
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local generalChannel = TextChatService:FindFirstChild("TextChannels")
        if generalChannel then
            generalChannel = generalChannel:FindFirstChild("RBXGeneral")
            if generalChannel then
                generalChannel:SendAsync(str)
            else
                warn("RBXGeneral channel not found!") 
            end
        else
            warn("TextChannels not found!")
        end
    else
        local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
        if chatEvents then
            local chatEvent = chatEvents:FindFirstChild("SayMessageRequest")
            if chatEvent then
                chatEvent:FireServer(str, "All")
            else
                warn("SayMessageRequest event not found!")
            end
        else
            warn("DefaultChatSystemChatEvents not found!")
        end
    end
end

-- Invisible character for new lines
local blob = ""

-- Formatted message (common for both systems)
wait(0.1)
local newMessage = 
        blob .. "\r" ..
        " ----------------🔥 AK ADMIN 🔥-------------  " .. blob .. "\r" ..
        blob .. "\r" ..
        blob .. "\r" ..
        " JOIN NOW AT " .. blob .. "\r" ..
        blob .. "\r" ..
        "----------DISִCORD.GG/AKADMIN------------" 

-- New message for the old chat system (without ASCII art)
local oldMessage = "🔥AK ADMIN🔥 👉 .ĝĝ/akadmin 👈"


-- Send the appropriate message based on the chat system
local function sendMessage()
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        -- New chat system
        chatMessage(newMessage)
    else
        -- Old chat system
        chatMessage(oldMessage)
    end
end

-- Retry mechanism in case the message fails to send
local retries = 3
while retries > 0 do
    local success, err = pcall(sendMessage)
    if success then
        break
    else
        warn("Failed to send message: " .. err)
        retries = retries - 1
        wait(1) -- Wait before retrying
    end
end

if retries == 0 then
    warn("Failed to send message after multiple attempts.")
end



--[[ modifiedacl ]]
-- Basically Anthony's anti-chat logger script but with slight changes
-- Thank you anthony

if not game:IsLoaded() then
    game.Loaded:wait()
end

local ACL_LoadTime = tick()
local NotificationTitle = "Anthony's ACL"

local OldCoreTypeSettings = {}
local WhitelistedCoreTypes = {
    "Chat",
    "All",
    Enum.CoreGuiType.Chat,
    Enum.CoreGuiType.All
}

local OldCoreSetting = nil

local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")

local Player = Players.LocalPlayer

local Notify = function(_Title, _Text , Time)
    StarterGui:SetCore("SendNotification", {Title = _Title, Text = _Text, Icon = "rbxassetid://2541869220", Duration = Time})
end

local Tween = function(Object, Time, Style, Direction, Property)
    return TweenService:Create(Object, TweenInfo.new(Time, Enum.EasingStyle[Style], Enum.EasingDirection[Direction]), Property)
end

local PlayerGui = Player:FindFirstChildWhichIsA("PlayerGui") do
    if not PlayerGui then
        local Timer = tick() + 5
        repeat task.wait() until Player:FindFirstChildWhichIsA("PlayerGui") or (tick() > Timer)
        PlayerGui = Player:FindFirstChildWhichIsA("PlayerGui") or false
        if not PlayerGui then
            return Notify(NotificationTitle, "Failed to find PlayerGui!", 10)
        end
    end
end

if getgenv().AntiChatLogger then
if identifyexecutor() == "Solara" then
    return Notify(NotificationTitle, "Anti Chat & Screenshot Logger Loaded!", 15)
else
    return Notify(NotificationTitle, "Anti Chat & Screenshot Logger already loaded!", 15)
end

local Services = setmetatable({}, {
    __index = function(_, serviceName)
        local success, service = pcall(function()
            return game:GetService(serviceName)
        end)
        if success then
            return cloneref(service)
        else
            return nil
        end
    end
})
else
    getgenv().AntiChatLogger = true
end

local Metatable = getrawmetatable(StarterGui)
setreadonly(Metatable, false)

local MessageEvent = Instance.new("BindableEvent")

if hookmetamethod then
    local CoreHook do
        CoreHook = hookmetamethod(StarterGui, "__namecall", newcclosure(function(self, ...)
            local Method = getnamecallmethod()
            local Arguments = {...}
            
            if self == StarterGui and not checkcaller() then
                if Method == "SetCoreGuiEnabled" then
                    local CoreType = Arguments[1]
                    local Enabled = Arguments[2]
                    
                    if table.find(WhitelistedCoreTypes, CoreType) and Enabled == false then -- Thanks Harun for correcting me on the second argument
                        OldCoreTypeSettings[CoreType] = Enabled
                        return
                    end
                elseif Method == "SetCore" then
                    local Core = Arguments[1]
                    local Connection = Arguments[2]
                    
                    if Core == "CoreGuiChatConnections" then
                        OldCoreSetting = Connection
                        return
                    end
                end
            end
            
            return CoreHook(self, ...)
        end))
    end

    if not getgenv().ChattedFix then
        getgenv().ChattedFix = true

        local ChattedFix do
            ChattedFix = hookmetamethod(Player, "__index", newcclosure(function(self, index)
                if self == Player and tostring(index):lower():match("chatted") and MessageEvent.Event then
                    return MessageEvent.Event
                end

                return ChattedFix(self, index)
            end))
        end

        local AnimateChattedFix = task.spawn(function()
            local ChattedSignal = false

            for _, x in next, getgc() do
                if type(x) == "function" and getfenv(x).script ~= nil and tostring(getfenv(x).script) == "Animate" then
                    if islclosure(x) then
                        local Constants = getconstants(x)

                        for _, v in next, Constants do
                            if v == "Chatted" then
                                ChattedSignal = x
                            end
                        end
                    end
                end
            end

            if ChattedSignal then
                ChattedSignal()
            end
        end)
    end
end

local EnabledChat = task.spawn(function()
    repeat
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
        task.wait()
    until StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat)
end)

local WarningGuiThread = task.spawn(function()
    WarningUI = Instance.new("ScreenGui")
    Main = Instance.new("Frame")
    BackgroundHolder = Instance.new("Frame")
    Background = Instance.new("Frame")
    TopBar = Instance.new("Frame")
    UIGradient = Instance.new("UIGradient")
    TitleHolder = Instance.new("Frame")
    Title = Instance.new("TextLabel")
    Holder = Instance.new("Frame")
    UIListLayout = Instance.new("UIListLayout")
    Reason_1 = Instance.new("TextLabel")
    Reason_2 = Instance.new("TextLabel")
    Reason_3 = Instance.new("TextLabel")
    WarningText = Instance.new("TextLabel")
    Exit = Instance.new("TextButton")
    ImageLabel = Instance.new("ImageLabel")
    
    WarningUI.Enabled = false
    WarningUI.Name = "WarningUI"
    WarningUI.Parent = CoreGui
    
    Main.Name = "Main"
    Main.Parent = WarningUI
    Main.AnchorPoint = Vector2.new(.5, .5)
    Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Main.BackgroundTransparency = 1
    Main.Position = UDim2.new(.5, 0, .5, 0)
    Main.Size = UDim2.new(0, 400, 0, 400)
    
    BackgroundHolder.Name = "BackgroundHolder"
    BackgroundHolder.Parent = Main
    BackgroundHolder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    BackgroundHolder.BackgroundTransparency = .25
    BackgroundHolder.BorderSizePixel = 0
    BackgroundHolder.Size = UDim2.new(1, 0, 1, 0)
    
    Background.Name = "Background"
    Background.Parent = BackgroundHolder
    Background.AnchorPoint = Vector2.new(.5, .5)
    Background.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Background.BorderSizePixel = 0
    Background.Position = UDim2.new(.5, 0, .5, 0)
    Background.Size = UDim2.new(.96, 0, .96, 0)
    
    TopBar.Name = "TopBar"
    TopBar.Parent = Background
    TopBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TopBar.BorderSizePixel = 0
    TopBar.Size = UDim2.new(1, 0, 0, 2)
    
    UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(53, 149, 146)), ColorSequenceKeypoint.new(.29, Color3.fromRGB(93, 86, 141)), ColorSequenceKeypoint.new(.50, Color3.fromRGB(126, 64, 138)), ColorSequenceKeypoint.new(.75, Color3.fromRGB(143, 112, 112)), ColorSequenceKeypoint.new(1, Color3.fromRGB(159, 159, 80))}
    UIGradient.Parent = TopBar
    
    TitleHolder.Name = "TitleHolder"
    TitleHolder.Parent = Background
    TitleHolder.AnchorPoint = Vector2.new(.5, .5)
    TitleHolder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    TitleHolder.BorderColor3 = Color3.fromRGB(44, 44, 44)
    TitleHolder.BorderSizePixel = 2
    TitleHolder.Position = UDim2.new(.5, 0, .5, 0)
    TitleHolder.Size = UDim2.new(.9, 0, .9, 0)
    
    Title.Name = "Title"
    Title.Parent = TitleHolder
    Title.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Title.BorderSizePixel = 0
    Title.Position = UDim2.new(0, 15, 0, -12)
    Title.Size = UDim2.new(0, 75, 0, 20)
    Title.Font = Enum.Font.SourceSansBold
    Title.Text = "Warning"
    Title.TextColor3 = Color3.fromRGB(235, 235, 235)
    Title.TextScaled = true
    Title.TextWrapped = true
    
    Holder.Name = "Holder"
    Holder.Parent = TitleHolder
    Holder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Holder.BackgroundTransparency = 1
    Holder.Position = UDim2.new(0, 30, .125, 0)
    Holder.Size = UDim2.new(1, -30, .875, 0)
    
    UIListLayout.Parent = Holder
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    Reason_1.Name = "Reason_1"
    Reason_1.Parent = Holder
    Reason_1.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Reason_1.BackgroundTransparency = 1
    Reason_1.BorderSizePixel = 0
    Reason_1.Size = UDim2.new(1, 0, 0, 20)
    Reason_1.Font = Enum.Font.SourceSans
    Reason_1.Text = "- TextChatService is enabled"
    Reason_1.TextColor3 = Color3.fromRGB(199, 40, 42)
    Reason_1.TextScaled = true
    Reason_1.TextWrapped = true
    Reason_1.TextXAlignment = Enum.TextXAlignment.Left
    Reason_1.Visible = false
    
    Reason_2.Name = "Reason_2"
    Reason_2.Parent = Holder
    Reason_2.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Reason_2.BackgroundTransparency = 1
    Reason_2.BorderSizePixel = 0
    Reason_2.Size = UDim2.new(1, 0, 0, 20)
    Reason_2.Font = Enum.Font.SourceSans
    Reason_2.Text = "- Legacy chat module was not found"
    Reason_2.TextColor3 = Color3.fromRGB(199, 40, 42)
    Reason_2.TextScaled = true
    Reason_2.TextWrapped = true
    Reason_2.TextXAlignment = Enum.TextXAlignment.Left
    Reason_2.Visible = false
    
    Reason_3.Name = "Reason_3"
    Reason_3.Parent = Holder
    Reason_3.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Reason_3.BackgroundTransparency = 1
    Reason_3.BorderSizePixel = 0
    Reason_3.Size = UDim2.new(1, 0, 0, 20)
    Reason_3.Font = Enum.Font.SourceSans
    Reason_3.Text = "- MessagePosted function was not found"
    Reason_3.TextColor3 = Color3.fromRGB(199, 40, 42)
    Reason_3.TextScaled = true
    Reason_3.TextWrapped = true
    Reason_3.TextXAlignment = Enum.TextXAlignment.Left
    Reason_3.Visible = false
    
    WarningText.Name = "WarningText"
    WarningText.Parent = TitleHolder
    WarningText.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    WarningText.BackgroundTransparency = 1
    WarningText.BorderSizePixel = 0
    WarningText.Position = UDim2.new(0, 30, .05, 0)
    WarningText.RichText = true
    WarningText.Size = UDim2.new(1, -30, 0, 20)
    WarningText.Font = Enum.Font.SourceSans
    WarningText.Text = "> Anti-<font color=\"#6ea644\">Chat Logger</font> will not work here!"
    WarningText.TextColor3 = Color3.fromRGB(255, 255, 255)
    WarningText.TextScaled = true
    WarningText.TextWrapped = true
    WarningText.TextXAlignment = Enum.TextXAlignment.Left
    
    Exit.Name = "Exit"
    Exit.Parent = TitleHolder
    Exit.AnchorPoint = Vector2.new(.5, .5)
    Exit.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
    Exit.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Exit.Position = UDim2.new(.5, 0, .899999976, 0)
    Exit.Size = UDim2.new(0, 250, 0, 20)
    Exit.Font = Enum.Font.SourceSans
    Exit.Text = "Ok"
    Exit.TextColor3 = Color3.fromRGB(255, 255, 255)
    Exit.TextScaled = true
    Exit.TextWrapped = true
    
    ImageLabel.Parent = TitleHolder
    ImageLabel.AnchorPoint = Vector2.new(.5, .5)
    ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ImageLabel.BackgroundTransparency = 1
    ImageLabel.Position = UDim2.new(.5, 0, .6, 0)
    ImageLabel.Size = UDim2.new(.3, 0, .3, 0)
    ImageLabel.ZIndex = 1
    ImageLabel.Image = "rbxassetid://12969025384"
    ImageLabel.ImageColor3 = Color3.fromRGB(40, 40, 40)
    ImageLabel.ImageTransparency = .5
    
    Exit.MouseButton1Down:Connect(function()
        WarningUI:Destroy()
    end)
end)

if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    WarningUI.Enabled = false
    Reason_1.Visible = false
    return
end

local PlayerScripts = Player:WaitForChild("PlayerScripts")
local ChatMain = PlayerScripts:FindFirstChild("ChatMain", true) or false

if not ChatMain then
    local Timer = tick()
    
    repeat task.wait() until PlayerScripts:FindFirstChild("ChatMain", true) or tick() > (Timer + 3)
    ChatMain = PlayerScripts:FindFirstChild("ChatMain", true)
    
    if not ChatMain then
        WarningUI.Enabled = true
        Reason_2.Visible = true
        return
    end
end

local PostMessage = require(ChatMain).MessagePosted

if not PostMessage then
    WarningUI.Enabled = true
    Reason_3.Visible = true
    return
end

local OldFunctionHook; OldFunctionHook = hookfunction(PostMessage.fire, function(self, Message)
    if self == PostMessage then
        MessageEvent:Fire(Message)
        return
    end
    return OldFunctionHook(self, Message)
end)

if setfflag then
    pcall(function()
        setfflag("AbuseReportScreenshot", "False")
        setfflag("AbuseReportScreenshotPercentage", "0")
    end)
end -- To prevent roblox from taking screenshots of your client.

local Credits = task.spawn(function()
    local UserIds = {
        1414978355
    }
    
    if table.find(UserIds, Player.UserId) then
        return
    end
    
    local Tag = Instance.new("BillboardGui")
    local Title = Instance.new("TextLabel", Tag)
    local Rank = Instance.new("TextLabel", Tag)
    local Gradient = Instance.new("UIGradient", Title)
    
    Tag.Brightness = 2
    Tag.Size = UDim2.new(4, 0, 1, 0)
    Tag.StudsOffsetWorldSpace = Vector3.new(0, 5, 0)
    
    Title.BackgroundTransparency = 1
    Title.Size = UDim2.new(1, 0, .6, 0)
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextScaled = true
    
    Rank.AnchorPoint = Vector2.new(.5, 0)
    Rank.BackgroundTransparency = 1
    Rank.Position = UDim2.new(.5, 0, .65, 0)
    Rank.Size = UDim2.new(.75, 0, .5, 0)
    Rank.TextColor3 = Color3.fromRGB(0, 0, 0)
    Rank.TextScaled = true
    Rank.Text = "< Anti Chat-Logger >"
    
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(.75, .75, .75)),
        ColorSequenceKeypoint.new(.27, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(.5, Color3.new(.3, 0, .5)),
        ColorSequenceKeypoint.new(0.78, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(.75, .75, .75))
    })
    Gradient.Offset = Vector2.new(-1, 0)
    
    local GradientTeen = Tween(Gradient, 2, "Circular", "Out", {Offset = Vector2.new(1, 0)})
    
    function PlayAnimation()
    	GradientTeen:Play()
    	GradientTeen.Completed:Wait()
    	Gradient.Offset = Vector2.new(-1, 0)
    	task.wait(.75)
    	PlayAnimation()
    end
    
    local AddTitle = function(Character)
        repeat task.wait() until Character
        
        local Humanoid = Character and Character:WaitForChild("Humanoid")
        local RootPart = Humanoid and Humanoid.RootPart
        
        if Humanoid then
            Humanoid:GetPropertyChangedSignal("RootPart"):Connect(function()
                if Humanoid.RootPart then
                    Tag.Adornee = RootPart
                end
            end)
        end
        
        if RootPart then
            Tag.Adornee = RootPart
        end
    end
    
    task.spawn(PlayAnimation)
    
    for _, x in next, Players:GetPlayers() do
        if table.find(UserIds, x.UserId) then
            Tag.Parent = workspace.Terrain
            Title.Text = x.Name
            AddTitle(x.Character)
            x.CharacterAdded:Connect(AddTitle)
        end
    end
    
    Players.PlayerAdded:Connect(function(x)
        if table.find(UserIds, x.UserId) then
            Tag.Parent = workspace.Terrain
            Title.Text = x.Name
            x.CharacterAdded:Connect(AddTitle)
        end
    end)
    
    Players.PlayerRemoving:Connect(function(x)
        if table.find(UserIds, x.UserId) then
            Tag.Parent = game
        end
    end)
end)

task.delay(1, function() WarningUI:Destroy() end)

for _, x in next, OldCoreTypeSettings do
    if not x then
        StarterGui:SetCore("ChatActive", false)
    end
    StarterGui:SetCoreGuiEnabled(_, x)
end

if OldCoreSetting then
    StarterGui:SetCore("CoreGuiChatConnections", OldCoreSetting)
end

if StarterGui:GetCore("ChatActive") then
    StarterGui:SetCore("ChatActive", false)
    StarterGui:SetCore("ChatActive", true)
end

--Metatable.__namecall = CoreHook
if CoreHook then
    setmetatable(Metatable, {__namecall = CoreHook}) 
end
setreadonly(Metatable, true)

Notify(NotificationTitle, "Anti Chat & Screenshot Logger Loaded!", 15)
print(string.format("AnthonyIsntHere's Anti Chat-Logger has loaded in %s seconds.", string.format("%.2f", tostring(tick() - ACL_LoadTime))))

Notify(NotificationTitle, "Anti Chat & Screenshot Logger Loaded!", 15)
print(string.format("AnthonyIsntHere's Anti Chat-Logger has loaded in %s seconds.", string.format("%.2f", tostring(tick() - ACL_LoadTime))))


--[[ reanim ]]
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Store last death position
local lastDeathCFrame = nil
local HttpService = game:GetService("HttpService")

local ghostEnabled = false
local originalCharacter
local ghostClone
local originalCFrame
local originalAnimateScript
local updateConnection
local ghostOriginalHipHeight
local ghostOriginalSizes = {}
local ghostOriginalMotorCFrames = {}
local animationCache = {}
local currentSound = nil
local audioCache = {}
local musicEnabled = true

local bodyParts = {
    "Head", "UpperTorso", "LowerTorso",
    "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot"
}

local animationState = {
    isRunning = false,
    currentId = nil,
    keyframes = nil,
    totalDuration = 0,
    elapsedTime = 0,
    speed = 1,
    connection = nil
}

local BuiltInAnimationsR15 = {}
local BuiltInAnimationsOrder = {}
local hasFetchedAnimations = false

-- Respawn at last death location logic
local function setupRespawnAtDeath()
    local function onCharacterAdded(character)
        -- Teleport to last death position if available
        if lastDeathCFrame then
            local hrp = character:WaitForChild("HumanoidRootPart", 5)
            if hrp then
                hrp.CFrame = lastDeathCFrame
            end
            lastDeathCFrame = nil -- Only teleport once after dying
        end
        -- Listen for death
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    lastDeathCFrame = hrp.CFrame
                end
            end)
        end
    end
    if LocalPlayer.Character then
        onCharacterAdded(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
end

setupRespawnAtDeath()

local function fetchAnimationsFromGitHub()
    if hasFetchedAnimations then return end
    hasFetchedAnimations = true
    local url = "https://ichfickdeinemutta.pages.dev/anims.lua"
    local success, response = pcall(function()
        return game:HttpGet(url)
    end)
    if success then
        local loadSuccess, result = pcall(function()
            return loadstring(response)()
        end)
        if loadSuccess and type(result) == "table" then
            BuiltInAnimationsR15 = result
            BuiltInAnimationsOrder = {}
            for line in response:gmatch("[^\r\n]+") do
                local name = line:match('%["([^"]+)"%]')
                if name and result[name] and not table.find(BuiltInAnimationsOrder, name) then
                    table.insert(BuiltInAnimationsOrder, name)
                end
            end
        else
            warn("Failed to compile GitHub script:", result)
        end
    else
        warn("Failed to fetch animations:", response)
    end
end
fetchAnimationsFromGitHub()

local newAnimations = {
    ["twerking"] = 77493234914180,
    ["Wait love me like I love you"] = 113197266804415,
    ["head banger (fortnite)"] = 117390128696430,
    ["egg dance (acu saya)"] = 14765075073,
    ["nya arigato"] = 16038410193,
    ["move ya body"] = 109551168484965,
    ["hug"] = 113001288211277,
    ["push 2 start"] = 121825287394407,
    ["jumpstyle"] = 127818220981023,
    ["Lap Dance"] = 18726264577,
    ["jerk off"] = 85510928563896,
    ["backshots"] = 107788763755159
}

local existingIds = {}
for _, id in pairs(BuiltInAnimationsR15) do
    existingIds[id] = true
end
for animName, animId in pairs(newAnimations) do
    if not existingIds[animId] and not table.find(BuiltInAnimationsOrder, animName) then
        BuiltInAnimationsR15[animName] = animId
        table.insert(BuiltInAnimationsOrder, animName)
    end
end

local favoriteAnimations = {}
local animationKeybinds = {}
local customAnimations = {}

local KEYBIND_SPEED_FILE = "ak/speed_keybinds.json"
local speedKeybindData = {
    SlowMarker = {ratio = 0.2, key = ""}, -- Default values
    FastMarker = {ratio = 0.8, key = ""}
}
local speedKeybindFunctions = {}

local function ensureakFolder()
    if not isfolder("ak") then
        makefolder("ak")
    end
end

local function ensureAudiosFolder()
    ensureakFolder()
    if not isfolder("ak/audios") then
        makefolder("ak/audios")
    end
end

local hasCreatedFavoritesFile = false
local hasCreatedKeybindsFile = false
local hasCreatedCustomAnimationsFile = false

local function saveFavorites()
    ensureakFolder()
    local favoritesToSave = {}
    for animName, animId in pairs(favoriteAnimations) do
        favoritesToSave[animName] = tostring(animId)
    end
    local success, encodedFavorites = pcall(HttpService.JSONEncode, HttpService, favoritesToSave)
    if success then
        local saveSuccess, errorMessage = pcall(function()
            writefile("ak/favorite_animations.json", encodedFavorites)
        end)
        if not saveSuccess then
            warn("Error saving favorites:", errorMessage)
        elseif not hasCreatedFavoritesFile then
            hasCreatedFavoritesFile = true
        end
    else
        warn("Error encoding favorites:", encodedFavorites)
    end
end

local function loadFavorites()
    ensureakFolder()
    local success, fileContent = pcall(readfile, "ak/favorite_animations.json")
    if success then
        local decodeSuccess, decodedFavorites = pcall(HttpService.JSONDecode, HttpService, fileContent)
        if decodeSuccess and typeof(decodedFavorites) == "table" then
            favoriteAnimations = {}
            for animName, animId in pairs(decodedFavorites) do
                favoriteAnimations[animName] = animId
                if not BuiltInAnimationsR15[animName] then
                    BuiltInAnimationsR15[animName] = animId
                    if not table.find(BuiltInAnimationsOrder, animName) then
                        table.insert(BuiltInAnimationsOrder, animName)
                    end
                end
            end
        else
            favoriteAnimations = {}
        end
    else
        favoriteAnimations = {}
    end
end

local function saveKeybinds()
    ensureakFolder()
    local keybindsToSave = {}
    for animName, keyCode in pairs(animationKeybinds) do
        keybindsToSave[animName] = keyCode.Name
    end
    local success, encodedKeybinds = pcall(HttpService.JSONEncode, HttpService, keybindsToSave)
    if success then
        local saveSuccess, errorMessage = pcall(function()
            writefile("ak/animation_keybinds.json", encodedKeybinds)
        end)
        if not saveSuccess then
            warn("Error saving keybinds:", errorMessage)
        elseif not hasCreatedKeybindsFile then
            hasCreatedKeybindsFile = true
        end
    else
        warn("Error encoding keybinds:", encodedKeybinds)
    end
end

local function loadKeybinds()
    ensureakFolder()
    local success, fileContent = pcall(readfile, "ak/animation_keybinds.json")
    if success then
        local decodeSuccess, decodedKeybinds = pcall(HttpService.JSONDecode, HttpService, fileContent)
        if decodeSuccess and typeof(decodedKeybinds) == "table" then
            animationKeybinds = {}
            for animName, keyName in pairs(decodedKeybinds) do
                animationKeybinds[animName] = Enum.KeyCode[keyName]
            end
        else
            animationKeybinds = {}
        end
    else
        animationKeybinds = {}
    end
end

local function saveSpeedKeybinds()
    ensureakFolder()
    local keybindsToSave = {
        SlowMarker = speedKeybindData.SlowMarker,
        FastMarker = speedKeybindData.FastMarker
    }
    local success, encodedKeybinds = pcall(HttpService.JSONEncode, HttpService, keybindsToSave)
    if success then
        local saveSuccess, errorMessage = pcall(function()
            writefile(KEYBIND_SPEED_FILE, encodedKeybinds)
        end)
        if not saveSuccess then
            warn("Error saving speed keybinds:", errorMessage)
        end
    else
        warn("Error encoding speed keybinds:", encodedKeybinds)
    end
end

local function loadSpeedKeybinds()
    ensureakFolder()
    local success, fileContent = pcall(readfile, KEYBIND_SPEED_FILE)
    if success then
        local decodeSuccess, decodedData = pcall(HttpService.JSONDecode, HttpService, fileContent)
        if decodeSuccess and typeof(decodedData) == "table" then
            if decodedData.SlowMarker and type(decodedData.SlowMarker.ratio) == "number" and type(decodedData.SlowMarker.key) == "string" and
               decodedData.FastMarker and type(decodedData.FastMarker.ratio) == "number" and type(decodedData.FastMarker.key) == "string" then
                speedKeybindData = decodedData
            else
                warn("Loaded speed keybind data has incorrect format, using defaults.")
                -- Keep default speedKeybindData
            end
        else
            warn("Failed to decode speed keybinds or data is not a table:", decodedData)
            -- Keep default speedKeybindData
        end
    else
        -- File doesn't exist or couldn't be read, keep default speedKeybindData
        -- warn("Speed keybind file not found or unreadable, using defaults.")
    end
end

local function saveCustomAnimations()
    ensureakFolder()
    local customToSave = {}
    for animName, animId in pairs(customAnimations) do
        customToSave[animName] = tostring(animId)
    end
    local success, encodedCustom = pcall(HttpService.JSONEncode, HttpService, customToSave)
    if success then
        local saveSuccess, errorMessage = pcall(function()
            writefile("ak/custom_animations.json", encodedCustom)
        end)
        if not saveSuccess then
            warn("Error saving custom animations:", errorMessage)
        elseif not hasCreatedCustomAnimationsFile then
            hasCreatedCustomAnimationsFile = true
        end
    else
        warn("Error encoding custom animations:", encodedCustom)
    end
end

local function loadCustomAnimations()
    ensureakFolder()
    local success, fileContent = pcall(readfile, "ak/custom_animations.json")
    if success then
        local decodeSuccess, decodedCustom = pcall(HttpService.JSONDecode, HttpService, fileContent)
        if decodeSuccess and typeof(decodedCustom) == "table" then
            customAnimations = decodedCustom
        else
            customAnimations = {}
        end
    else
        customAnimations = {}
    end
end

local function preloadAnimations(animationTable)
    for animName, animId in pairs(animationTable) do
        if not animationCache[animId] then
            local success, animationAsset = pcall(function()
                return game:GetObjects("rbxassetid://" .. animId)[1]
            end)
            if success and animationAsset then
                animationCache[animId] = animationAsset
            else
                warn("Failed to preload animation:", animName, "ID:", animId)
            end
        end
    end
end

local function fetchAudio(animationId)
    local filePath = "ak/audios/" .. animationId .. ".mp3"
    local url = "https://github.com/BloxiAstra/audios/raw/refs/heads/main/" .. animationId .. ".mp3"
    local success, response = pcall(function()
        return game:HttpGet(url)
    end)
    if success then
        writefile(filePath, response)
        return true
    else
        warn("Failed to download audio for ID " .. animationId .. ": " .. tostring(response))
        return false
    end
end

local function loadAudio(animationId)
    if audioCache[animationId] then
        return audioCache[animationId]
    end
    local filePath = "ak/audios/" .. animationId .. ".mp3"
    if isfile(filePath) then
        local sound = Instance.new("Sound")
        sound.SoundId = getcustomasset(filePath)
        sound.Volume = 1 
        sound.Looped = true
        spawn(function()
while wait() do
if sound then
sound.Pitch = animationState.speed
else
continue
end
end
end)
        sound.Parent = LocalPlayer:WaitForChild("PlayerGui")
        audioCache[animationId] = sound
        return sound
    end
    return nil
end

local activeNotifications = {}

local function showNotification(message, duration)
    local screenGui = LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("EnhancedGhostGui") or LocalPlayer:WaitForChild("PlayerGui")
    local notification = Instance.new("TextLabel")
    notification.Size = UDim2.new(0, 220, 0, 40)
    notification.Position = UDim2.new(1, 0, 0.1, 0)
    notification.Text = message
    notification.TextColor3 = Color3.fromRGB(255, 255, 255)
    notification.TextSize = 16
    notification.Font = Enum.Font.GothamSemibold
    notification.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    notification.BackgroundTransparency = 1
    notification.TextTransparency = 1
    notification.BorderSizePixel = 0
    notification.ZIndex = 10

    local notifCorner = Instance.new("UICorner")
    notifCorner.CornerRadius = UDim.new(0, 8)
    notifCorner.Parent = notification

    local shadow = Instance.new("UIStroke")
    shadow.Thickness = 2
    shadow.Color = Color3.fromRGB(20, 20, 20)
    shadow.Transparency = 0.5
    shadow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    shadow.Parent = notification

    notification.Parent = screenGui

    local yOffset = 0
    for _, existingNotif in pairs(activeNotifications) do
        if existingNotif and existingNotif.Parent then
            yOffset = yOffset + existingNotif.AbsoluteSize.Y + 10
        end
    end

    table.insert(activeNotifications, notification)

    local tweenInfoIn = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local goalIn = {
        Position = UDim2.new(0.5, -110, 0.1, yOffset),
        BackgroundTransparency = 0,
        TextTransparency = 0
    }
    local tweenIn = TweenService:Create(notification, tweenInfoIn, goalIn)
    tweenIn:Play()

    task.delay(duration or 2, function()
        if notification and notification.Parent then
            local tweenInfoOut = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.In)
            local goalOut = {
                Position = UDim2.new(0.5, -110, 0, -50),
                BackgroundTransparency = 1,
                TextTransparency = 1
            }
            local tweenOut = TweenService:Create(notification, tweenInfoOut, goalOut)
            tweenOut:Play()
            tweenOut.Completed:Connect(function()
                if notification and notification.Parent then
                    notification:Destroy()
                    for i, notif in ipairs(activeNotifications) do
                        if notif == notification then
                            table.remove(activeNotifications, i)
                            break
                        end
                    end
                    local newOffset = 0
                    for _, remainingNotif in pairs(activeNotifications) do
                        if remainingNotif and remainingNotif.Parent then
                            TweenService:Create(remainingNotif, tweenInfoIn, {
                                Position = UDim2.new(0.5, -110, 0.1, newOffset)
                            }):Play()
                            newOffset = newOffset + remainingNotif.AbsoluteSize.Y + 10
                        end
                    end
                end
            end)
        end
    end)
end

local function preloadAudios()
    ensureAudiosFolder()
    local url = "https://raw.githubusercontent.com/BloxiAstra/audios/refs/heads/main/ids.json"
    local success, response = pcall(function()
        return game:HttpGet(url)
    end)
    if success then
        local decodeSuccess, data = pcall(HttpService.JSONDecode, HttpService, response)
        if decodeSuccess and data.audio_ids and type(data.audio_ids) == "table" then
            local audioCount = #data.audio_ids
            local fetchedCount = 0
            for _, animId in ipairs(data.audio_ids) do
                local idStr = tostring(animId)
                local filePath = "ak/audios/" .. idStr .. ".mp3"
                if not isfile(filePath) then
                    local fetchSuccess = fetchAudio(idStr)
                    if fetchSuccess then
                        fetchedCount = fetchedCount + 1
                        showNotification(idStr .. ".mp3 fetched!", 2)
                    end
                else
                    fetchedCount = fetchedCount + 1
                end
            end
            print("Loaded " .. fetchedCount .. " audios")
        else
            warn("Failed to decode ids.json or invalid format: " .. tostring(data))
        end
    else
        warn("Failed to fetch ids.json: " .. tostring(response))
    end
end

local function initializePreloading()
    loadFavorites()
    loadCustomAnimations()
    -- Only preload the first 10 favorite animations if there are more than 10
    local favCount = 0
    local favToPreload = {}
    for animName, animId in pairs(favoriteAnimations) do
        favToPreload[animName] = animId
        favCount = favCount + 1
        if favCount >= 10 then break end
    end
    preloadAnimations(favToPreload)
    preloadAnimations(customAnimations)
    preloadAudios()
end

local function scaleCFrame(cf, scale)
    local pos = cf.Position * scale
    local xRot, yRot, zRot = cf:ToEulerAnglesXYZ()
    return CFrame.new(pos) * CFrame.Angles(xRot, yRot, zRot)
end

local function adjustCloneToGround(clone)
    if not clone then return end
    local lowestY = math.huge
    for _, part in ipairs(clone:GetDescendants()) do
        if part:IsA("BasePart") then
            local bottomY = part.Position.Y - (part.Size.Y / 2)
            if bottomY < lowestY then
                lowestY = bottomY
            end
        end
    end
    local groundY = 0
    local offset = groundY - lowestY
    if offset > 0 then
        if clone.PrimaryPart then
            clone:SetPrimaryPartCFrame(clone.PrimaryPart.CFrame + Vector3.new(0, offset, 0))
        else
            clone:TranslateBy(Vector3.new(0, offset, 0))
        end
    end
end

local preservedGuis = {}
local function preserveGuis()
    local playerGui = LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
    if playerGui then
        for _, gui in ipairs(playerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.ResetOnSpawn then
                table.insert(preservedGuis, gui)
                gui.ResetOnSpawn = false
            end
        end
    end
end

local function restoreGuis()
    for _, gui in ipairs(preservedGuis) do
        gui.ResetOnSpawn = true
    end
    table.clear(preservedGuis)
end

local function updateCloneTransparency()
    if not ghostClone then return end
    for _, part in pairs(ghostClone:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Transparency = 1
        end
    end
    local head = ghostClone:FindFirstChild("Head")
    if head then
        for _, child in ipairs(head:GetChildren()) do
            if child:IsA("Decal") then
                child.Transparency = 1
            end
        end
    end
end

local function updateRagdolledParts()
    if not ghostEnabled or not originalCharacter or not ghostClone then return end
    for _, partName in ipairs(bodyParts) do
        local originalPart = originalCharacter:FindFirstChild(partName)
        local clonePart = ghostClone:FindFirstChild(partName)
        if originalPart and clonePart then
            originalPart.CFrame = clonePart.CFrame
            originalPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            originalPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        end
    end
    local originalNeck = originalCharacter:FindFirstChild("Head") and originalCharacter.Head:FindFirstChild("Neck")
    local cloneNeck = ghostClone:FindFirstChild("Head") and ghostClone.Head:FindFirstChild("Neck")
    if originalNeck and cloneNeck then
        originalNeck.C0 = cloneNeck.C0
    end
end

local function suppressHeadMovement()
    local headMovementScript = Workspace:FindFirstChild("VirtuallyNad") and Workspace.VirtuallyNad:FindFirstChild("HeadMovement")
    if headMovementScript and headMovementScript:IsA("LocalScript") then
        headMovementScript.Disabled = true
    end
    LocalPlayer:SetAttribute("TurnHead", false)
end

local function restoreHeadMovement()
    local headMovementScript = Workspace:FindFirstChild("VirtuallyNad") and Workspace.VirtuallyNad:FindFirstChild("HeadMovement")
    if headMovementScript and headMovementScript:IsA("LocalScript") then
        headMovementScript.Disabled = false
    end
end

local originalNeckC0 = nil
local function resetNeckOrientation(character, isClone)
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end

    local neck = humanoid.RigType == Enum.HumanoidRigType.R15 and character:WaitForChild("Head"):FindFirstChild("Neck")
        or humanoid.RigType == Enum.HumanoidRigType.R6 and character:WaitForChild("Torso"):FindFirstChild("Neck")
    if not neck or not originalNeckC0 then return end

    local position = originalNeckC0.Position
    local neutralOrientation = CFrame.new(position, position + Vector3.new(0, 0, -1))
    neck.C0 = neutralOrientation

    if isClone then
        ghostOriginalMotorCFrames[neck] = { C0 = neutralOrientation, C1 = neck.C1 }
    end
end

local function setGhostEnabled(newState)
    ghostEnabled = newState

    local hasDefaultRagdollEvents = ReplicatedStorage:FindFirstChild("RagdollEvent") and ReplicatedStorage:FindFirstChild("UnragdollEvent")
    local Packets = nil
    if not hasDefaultRagdollEvents then
        local success, module = pcall(function()
            return require(ReplicatedStorage:WaitForChild("LocalModules"):WaitForChild("Backend"):WaitForChild("Packets"))
        end)
        if success then
            Packets = module
        else
            warn("Failed to load Packets module!")
        end
    end
    
    if ghostEnabled then
        local char = LocalPlayer.Character
        if not char then
            warn("No character found!")
            return
        end

        local humanoid = char:FindFirstChildWhichIsA("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if not humanoid or not root then
            warn("Character is missing either Humanoid or HumanoidRootPart!")
            return
        end

        originalCharacter = char
        originalCFrame = root.CFrame

        local neck = humanoid.RigType == Enum.HumanoidRigType.R15 and char:WaitForChild("Head"):FindFirstChild("Neck")
            or humanoid.RigType == Enum.HumanoidRigType.R6 and char:WaitForChild("Torso"):FindFirstChild("Neck")
        if neck then
            originalNeckC0 = neck.C0
        end

        char.Archivable = true
        ghostClone = char:Clone()
        char.Archivable = false

        local originalName = originalCharacter.Name
        ghostClone.Name = originalName .. "_clone"

        local ghostHumanoid = ghostClone:FindFirstChildWhichIsA("Humanoid")
        if ghostHumanoid then
            ghostHumanoid.DisplayName = originalName .. "_clone"
            ghostOriginalHipHeight = ghostHumanoid.HipHeight
            ghostHumanoid.WalkSpeed = humanoid.WalkSpeed
            ghostHumanoid.JumpPower = humanoid.JumpPower
        end

        if not ghostClone.PrimaryPart then
            local hrp = ghostClone:FindFirstChild("HumanoidRootPart")
            if hrp then
                ghostClone.PrimaryPart = hrp
            end
        end

        updateCloneTransparency()

        ghostOriginalSizes = {}
        ghostOriginalMotorCFrames = {}
        for _, desc in ipairs(ghostClone:GetDescendants()) do
            if desc:IsA("BasePart") then
                ghostOriginalSizes[desc] = desc.Size
            elseif desc:IsA("Motor6D") then
                ghostOriginalMotorCFrames[desc] = { C0 = desc.C0, C1 = desc.C1 }
            end
        end

        local animate = originalCharacter:FindFirstChild("Animate")
        if animate then
            originalAnimateScript = animate:Clone()
            originalAnimateScript.Parent = ghostClone
            originalAnimateScript.Disabled = true
        end

        if Packets then
            resetNeckOrientation(originalCharacter, false)
            resetNeckOrientation(ghostClone, true)
        end

        preserveGuis()
        ghostClone.Parent = Workspace

        adjustCloneToGround(ghostClone)

        LocalPlayer.Character = ghostClone
        if ghostHumanoid then
            Workspace.CurrentCamera.CameraSubject = ghostHumanoid
        end
        restoreGuis()

        task.delay(0.1, function()
            if not ghostEnabled or not ghostClone then return end
            if originalAnimateScript then
                originalAnimateScript.Disabled = false
            end
            if ghostHumanoid then
                ghostHumanoid:ChangeState(Enum.HumanoidStateType.Running)
            end
        end)

        task.delay(0, function()
            if not ghostEnabled then return end
            if hasDefaultRagdollEvents then
                if ReplicatedStorage:FindFirstChild("RagdollEvent") then
                    ReplicatedStorage.RagdollEvent:FireServer()
                else
                    warn("RagdollEvent not found!")
                end
            elseif Packets then
                Packets.Ragdoll:Fire(true)
                suppressHeadMovement()
            end
            task.delay(0, function()
                if not ghostEnabled then return end
                if updateConnection then updateConnection:Disconnect() end
                updateConnection = RunService.Heartbeat:Connect(updateRagdolledParts)
            end)
        end)
    else
        if updateConnection then
            updateConnection:Disconnect()
            updateConnection = nil
        end
        if animationState.connection then
            animationState.connection:Disconnect()
            animationState.connection = nil
        end

        if not originalCharacter or not ghostClone then return end

        for i = 1, 3 do
            if hasDefaultRagdollEvents then
                if ReplicatedStorage:FindFirstChild("UnragdollEvent") then
                    ReplicatedStorage.UnragdollEvent:FireServer()
                else
                    warn("UnragdollEvent not found!")
                end
            elseif Packets then
                Packets.Ragdoll:Fire(false)
                restoreHeadMovement()
            end
            task.wait(0.1)
        end

        local origRoot = originalCharacter:FindFirstChild("HumanoidRootPart")
        local ghostRoot = ghostClone:FindFirstChild("HumanoidRootPart")
        local targetCFrame = ghostRoot and ghostRoot.CFrame or originalCFrame

        local animate = ghostClone:FindFirstChild("Animate")
        if animate then
            animate.Parent = originalCharacter
            animate.Disabled = true
        end

        ghostClone:Destroy()

        for _, sound in pairs(audioCache) do
            if sound then
                sound:Destroy()
            end
        end
        table.clear(audioCache)

        if origRoot then
            origRoot.CFrame = targetCFrame
        end

        local origHumanoid = originalCharacter:FindFirstChildWhichIsA("Humanoid")
preserveGuis()
LocalPlayer.Character = originalCharacter
if origHumanoid then
    Workspace.CurrentCamera.CameraSubject = origHumanoid
end
restoreGuis()

        if animate then
            task.wait(0.1)
            animate.Disabled = false
        end

        originalNeckC0 = nil
    end
end

local function playAudio(animationId)
    if not musicEnabled then return end
    local filePath = "ak/audios/" .. animationId .. ".mp3"
    if isfile(filePath) then
        local sound = loadAudio(animationId)
        if sound then
            sound:Play()
            currentSound = sound
        end
    end
end

local function stopAudio()
    if currentSound then
        currentSound:Stop()
        currentSound = nil
    end
end

local animationButtons = {}
local customButtons = {}

local function stopFakeAnimation()
    animationState.isRunning = false
    stopAudio()
    if ghostClone then
        -- Reset all motor positions
        for motor, orig in pairs(ghostOriginalMotorCFrames) do
            if motor and motor:IsA("Motor6D") then
                motor.C0 = orig.C0
            end
        end

        -- Explicitly reset neck orientation
        local neck = ghostClone:FindFirstChild("Head") and ghostClone:FindFirstChild("Head"):FindFirstChild("Neck")
            or ghostClone:FindFirstChild("Torso") and ghostClone:FindFirstChild("Torso"):FindFirstChild("Neck")
        if neck and originalNeckC0 then
            neck.C0 = originalNeckC0
        end

        -- Re-enable scripts
        for _, script in pairs(ghostClone:GetChildren()) do
            if script:IsA("LocalScript") and not script.Enabled and script ~= originalAnimateScript then
                script.Enabled = true
            end
        end
        if originalAnimateScript then
            originalAnimateScript.Disabled = false
        end
    end
    if animationState.connection then
        animationState.connection:Disconnect()
        animationState.connection = nil
    end

    for animName, buttonData in pairs(animationButtons) do
        buttonData.NameButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    end
    for animName, buttonData in pairs(customButtons) do
        buttonData.NameButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    end
end

local function playFakeAnimation(animationId)
    if not ghostClone then
        warn("Reanimate first!")
        return
    end
    if animationId == "" then return end

    local humanoid = ghostClone:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then
        warn("No Humanoid found in Clone!")
        return
    end

    local refPart = ghostClone:FindFirstChild("LowerTorso") or ghostClone:FindFirstChild("Torso")
    if not refPart then
        warn("No LowerTorso or Torso found in Clone!")
        return
    end

    if animationState.isRunning then
        stopAudio()
        if animationState.currentId == animationId then
            stopFakeAnimation()
            animationState.currentId = nil
            return
        end
    end

    for animName, buttonData in pairs(animationButtons) do
        buttonData.NameButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    end
    for animName, buttonData in pairs(customButtons) do
        buttonData.NameButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    end

    local animName = nil
    for name, id in pairs(BuiltInAnimationsR15) do
        if tostring(id) == animationId then animName = name break end
    end
    if not animName then
        for name, id in pairs(customAnimations) do
            if tostring(id) == animationId then animName = name break end
        end
    end
    if not animName then
        for name, id in pairs(favoriteAnimations) do
            if tostring(id) == animationId then animName = name break end
        end
    end

    if animName then
        if animationButtons[animName] then
            animationButtons[animName].NameButton.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
        end
        if customButtons[animName] then
            customButtons[animName].NameButton.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
        end
    end

    local isMoving = humanoid.MoveDirection.Magnitude > 0 or humanoid:GetState() == Enum.HumanoidStateType.Running

    if originalAnimateScript then
        if isMoving then
            originalAnimateScript.Disabled = true
            for _, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                animTrack:Stop()
            end
        end
    end

    local NeededAssets = animationCache[animationId]
    if not NeededAssets then
        local success, animationAsset = pcall(function()
            return game:GetObjects("rbxassetid://" .. animationId)[1]
        end)
        if not success or not animationAsset then
            warn("Invalid Animation ID: " .. animationId)
            return
        end
        NeededAssets = animationAsset
        animationCache[animationId] = NeededAssets
    end

    NeededAssets.Priority = Enum.AnimationPriority.Action

    animationState.currentId = animationId
    animationState.keyframes = NeededAssets:GetKeyframes()
    animationState.totalDuration = animationState.keyframes[#animationState.keyframes].Time
    animationState.elapsedTime = 0
    animationState.isRunning = true

    playAudio(animationId)

    local character = ghostClone
    local Joints = {
        ["Torso"] = character:WaitForChild("HumanoidRootPart"):FindFirstChild("RootJoint"),
        ["Head"] = character:WaitForChild("Head"):FindFirstChild("Neck"),
        ["LeftUpperArm"] = character:WaitForChild("LeftUpperArm"):FindFirstChild("LeftShoulder"),
        ["RightUpperArm"] = character:WaitForChild("RightUpperArm"):FindFirstChild("RightShoulder"),
        ["LeftUpperLeg"] = character:WaitForChild("LeftUpperLeg"):FindFirstChild("LeftHip"),
        ["RightUpperLeg"] = character:WaitForChild("RightUpperLeg"):FindFirstChild("RightHip"),
        ["LeftFoot"] = character:WaitForChild("LeftFoot"):FindFirstChild("LeftAnkle"),
        ["RightFoot"] = character:WaitForChild("RightFoot"):FindFirstChild("RightAnkle"),
        ["LeftHand"] = character:WaitForChild("LeftHand"):FindFirstChild("LeftWrist"),
        ["RightHand"] = character:WaitForChild("RightHand"):FindFirstChild("RightWrist"),
        ["LeftLowerArm"] = character:WaitForChild("LeftLowerArm"):FindFirstChild("LeftElbow"),
        ["RightLowerArm"] = character:WaitForChild("RightLowerArm"):FindFirstChild("RightElbow"),
        ["LeftLowerLeg"] = character:WaitForChild("LeftLowerLeg"):FindFirstChild("LeftKnee"),
        ["RightLowerLeg"] = character:WaitForChild("RightLowerLeg"):FindFirstChild("RightKnee"),
        ["LowerTorso"] = character:WaitForChild("LowerTorso"):FindFirstChild("Root"),
        ["UpperTorso"] = character:WaitForChild("UpperTorso"):FindFirstChild("Waist"),
    }

    if not animationState.connection then
        for _, script in pairs(ghostClone:GetChildren()) do
            if script:IsA("LocalScript") and script.Enabled and script ~= originalAnimateScript then
                script.Enabled = false
            end
        end

        animationState.connection = RunService.Heartbeat:Connect(function(deltaTime)
            if not animationState.isRunning or not ghostClone then
                stopFakeAnimation()
                return
            end

            if not animationState.keyframes then return end

            animationState.elapsedTime = animationState.elapsedTime + (deltaTime * animationState.speed)
            if animationState.elapsedTime >= animationState.totalDuration then
                animationState.elapsedTime = animationState.elapsedTime % animationState.totalDuration
            end

            local currentFrame, nextFrame
            for i = 1, #animationState.keyframes - 1 do
                if animationState.elapsedTime >= animationState.keyframes[i].Time and animationState.elapsedTime < animationState.keyframes[i + 1].Time then
                    currentFrame = animationState.keyframes[i]
                    nextFrame = animationState.keyframes[i + 1]
                    break
                end
            end
            if not currentFrame then
                currentFrame = animationState.keyframes[#animationState.keyframes]
                nextFrame = animationState.keyframes[1]
            end

            local frameDuration = nextFrame.Time - currentFrame.Time
            local frameTime = animationState.elapsedTime - currentFrame.Time
            local alpha = frameTime / frameDuration
            alpha = math.clamp(alpha, 0, 1)

            for _, pose in pairs(currentFrame:GetDescendants()) do
                local motor = Joints[pose.Name]
                if motor and ghostOriginalMotorCFrames[motor] then
                    local currentCFrame = ghostOriginalMotorCFrames[motor].C0 * pose.CFrame
                    local nextPose = nextFrame:FindFirstChild(pose.Name, true)
                    if nextPose then
                        local nextCFrame = ghostOriginalMotorCFrames[motor].C0 * nextPose.CFrame
                        motor.C0 = currentCFrame:Lerp(nextCFrame, alpha)
                    else
                        motor.C0 = currentCFrame
                    end
                end
            end
        end)
    end
end

local function createAnimationListGui()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AnimationListGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    screenGui.Enabled = false

    loadFavorites()
    loadKeybinds()
    loadSpeedKeybinds()

    -- Shadow Container Frame
    local shadowContainer = Instance.new("Frame")
    shadowContainer.Name = "shadowContainer"
    shadowContainer.BackgroundTransparency = 1
    shadowContainer.Size = UDim2.new(0, 332, 0, 535) -- Adjusted height for keybinds
    shadowContainer.Position = UDim2.new(0.7, -166, 0.5, -250)
    shadowContainer.ZIndex = 1
    shadowContainer.Parent = screenGui
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadowContainer

    -- Main Shadow ImageLabel
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "shadow"
    shadow.Image = "rbxassetid://297774371"
    shadow.ImageColor3 = Color3.fromRGB(15, 15, 15)
    shadow.ImageTransparency = 0.3
    shadow.SliceCenter = Rect.new(20, 20, 280, 280)
    shadow.BackgroundTransparency = 1
    shadow.Size = UDim2.new(1, 0, 1, 0)
    shadow.Position = UDim2.new(0, 0, 0, 0)
    shadow.ZIndex = 1
    shadow.Parent = shadowContainer

    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 300, 0, 505) -- Adjusted height to fit keybinds and provide more space
    mainFrame.Position = UDim2.new(0.7, -150, 0.5, -234)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.ZIndex = 2
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 12)
    uiCorner.Parent = mainFrame
    local uiGradient = Instance.new("UIGradient")
    uiGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 30)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 40))
    }
    uiGradient.Parent = mainFrame
    mainFrame.Parent = screenGui

    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 50)
    titleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    titleBar.BorderSizePixel = 0
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = titleBar
    titleBar.Parent = mainFrame

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(0.7, 0, 1, 0)
    titleLabel.Position = UDim2.new(0.05, 0, 0, 0)
    titleLabel.Text = "Animations"
    titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.GothamSemibold
    titleLabel.BackgroundTransparency = 1
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = titleBar

    local contentFrame = Instance.new("Frame")
    contentFrame.Size = UDim2.new(1, 0, 1, -110)
    contentFrame.Position = UDim2.new(0, 0, 0, 50)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = mainFrame

    local tabFrame = Instance.new("Frame")
    tabFrame.Size = UDim2.new(0.9, 0, 0, 40)
    tabFrame.Position = UDim2.new(0.05, 0, 0, 10)
    tabFrame.BackgroundTransparency = 1
    tabFrame.Parent = contentFrame

    local allTabButton = Instance.new("TextButton")
    allTabButton.Size = UDim2.new(0.31, -5, 0, 35)
    allTabButton.Position = UDim2.new(0, 0, 0, 0)
    allTabButton.Text = "All"
    allTabButton.TextColor3 = Color3.fromRGB(220, 220, 220)
    allTabButton.TextSize = 16
    allTabButton.Font = Enum.Font.GothamSemibold
    allTabButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
    allTabButton.BorderSizePixel = 0
    local allTabCorner = Instance.new("UICorner")
    allTabCorner.CornerRadius = UDim.new(0, 8)
    allTabCorner.Parent = allTabButton
    allTabButton.Parent = tabFrame

    local favTabButton = Instance.new("TextButton")
    favTabButton.Size = UDim2.new(0.31, -5, 0, 35)
    favTabButton.Position = UDim2.new(0.34, 5, 0, 0)
    favTabButton.Text = "Favorites"
    favTabButton.TextColor3 = Color3.fromRGB(220, 220, 220)
    favTabButton.TextSize = 16
    favTabButton.Font = Enum.Font.GothamSemibold
    favTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    favTabButton.BorderSizePixel = 0
    local favTabCorner = Instance.new("UICorner")
    favTabCorner.CornerRadius = UDim.new(0, 8)
    favTabCorner.Parent = favTabButton
    favTabButton.Parent = tabFrame

    local musicTabButton = Instance.new("TextButton")
    musicTabButton.Size = UDim2.new(0.31, -5, 0, 35)
    musicTabButton.Position = UDim2.new(0.68, 5, 0, 0)
    musicTabButton.Text = "Music"
    musicTabButton.TextColor3 = Color3.fromRGB(220, 220, 220)
    musicTabButton.TextSize = 16
    musicTabButton.Font = Enum.Font.GothamSemibold
    musicTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    musicTabButton.BorderSizePixel = 0
    local musicTabCorner = Instance.new("UICorner")
    musicTabCorner.CornerRadius = UDim.new(0, 8)
    musicTabCorner.Parent = musicTabButton
    musicTabButton.Parent = tabFrame

    local searchBox = Instance.new("TextBox")
    searchBox.Size = UDim2.new(0.9, 0, 0, 35)
    searchBox.Position = UDim2.new(0.05, 0, 0, 55)
    searchBox.PlaceholderText = "Search animations..."
    searchBox.Text = ""
    searchBox.TextColor3 = Color3.fromRGB(200, 200, 200)
    searchBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
    searchBox.TextSize = 14
    searchBox.Font = Enum.Font.Gotham
    searchBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    searchBox.BorderSizePixel = 0
    local searchCorner = Instance.new("UICorner")
    searchCorner.CornerRadius = UDim.new(0, 8)
    searchCorner.Parent = searchBox
    searchBox.Parent = contentFrame

    local allScrollFrame = Instance.new("ScrollingFrame")
    allScrollFrame.Size = UDim2.new(0.9, 0, 0, 235)
    allScrollFrame.Position = UDim2.new(0.05, 0, 0, 100)
    allScrollFrame.BackgroundTransparency = 1
    allScrollFrame.BorderSizePixel = 0
    allScrollFrame.ScrollBarThickness = 4
    allScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    allScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    allScrollFrame.Parent = contentFrame

    local favScrollFrame = Instance.new("ScrollingFrame")
    favScrollFrame.Size = UDim2.new(0.9, 0, 0, 235)
    favScrollFrame.Position = UDim2.new(0.05, 0, 0, 100)
    favScrollFrame.BackgroundTransparency = 1
    favScrollFrame.BorderSizePixel = 0
    favScrollFrame.ScrollBarThickness = 4
    favScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    favScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    favScrollFrame.Visible = false
    favScrollFrame.Parent = contentFrame

    local musicScrollFrame = Instance.new("ScrollingFrame")
    musicScrollFrame.Size = UDim2.new(0.9, 0, 0, 235)
    musicScrollFrame.Position = UDim2.new(0.05, 0, 0, 100)
    musicScrollFrame.BackgroundTransparency = 1
    musicScrollFrame.BorderSizePixel = 0
    musicScrollFrame.ScrollBarThickness = 4
    musicScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    musicScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    musicScrollFrame.Visible = false
    musicScrollFrame.Parent = contentFrame

    local speedSection = Instance.new("Frame")
    speedSection.Name = "SpeedSection"
    speedSection.Size = UDim2.new(0.9, 0, 0, 90) -- Adjusted height for more compact markers
    speedSection.Position = UDim2.new(0.05, 0, 0, 350)
    speedSection.BackgroundTransparency = 1
    speedSection.Parent = contentFrame

    local speedLabel = Instance.new("TextLabel")
    speedLabel.Size = UDim2.new(1, 0, 0, 20)
    speedLabel.Text = "Animation Speed: 100%"
    speedLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    speedLabel.TextSize = 14
    speedLabel.Font = Enum.Font.GothamMedium
    speedLabel.BackgroundTransparency = 1
    speedLabel.Parent = speedSection

    local speedSliderBG = Instance.new("Frame")
    speedSliderBG.Size = UDim2.new(1, 0, 0, 6)
    speedSliderBG.Position = UDim2.new(0, 0, 0, 30)
    speedSliderBG.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    speedSliderBG.BorderSizePixel = 0
    local speedBGCorner = Instance.new("UICorner")
    speedBGCorner.CornerRadius = UDim.new(1, 0)
    speedBGCorner.Parent = speedSliderBG
    speedSliderBG.Parent = speedSection

    local speedSliderFill = Instance.new("Frame")
    speedSliderFill.Size = UDim2.new(0.25, 0, 1, 0)
    speedSliderFill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    speedSliderFill.BorderSizePixel = 0
    local speedFillCorner = Instance.new("UICorner")
    speedFillCorner.CornerRadius = UDim.new(1, 0)
    speedFillCorner.Parent = speedSliderFill
    speedSliderFill.Parent = speedSliderBG

    local speedSliderHandle = Instance.new("Frame")
    speedSliderHandle.Size = UDim2.new(0, 16, 0, 16)
    speedSliderHandle.Position = UDim2.new(0.25, -8, 0.5, -8)
    speedSliderHandle.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    speedSliderHandle.BorderSizePixel = 0
    local speedHandleCorner = Instance.new("UICorner")
    speedHandleCorner.CornerRadius = UDim.new(1, 0)
    speedHandleCorner.Parent = speedSliderHandle
    speedSliderHandle.Parent = speedSliderBG

    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    local function updateSpeedSlider(value)
        local fillValue = value / 4
        local tween = TweenService:Create(speedSliderFill, tweenInfo, {Size = UDim2.new(math.clamp(fillValue, 0, 1), 0, 1, 0)})
        tween:Play()
        local handleTween = TweenService:Create(speedSliderHandle, tweenInfo, {Position = UDim2.new(math.clamp(fillValue, 0, 1), -8, 0.5, -8)})
        handleTween:Play()
        speedLabel.Text = "Animation Speed: " .. math.floor(value * 100) .. "%"
        animationState.speed = value
    end

    updateSpeedSlider(1)

    local isDraggingSpeed = false
    local function updateSpeedFromPosition(input)
        local sliderPosition = (input.Position.X - speedSliderBG.AbsolutePosition.X) / speedSliderBG.AbsoluteSize.X
        sliderPosition = math.clamp(sliderPosition, 0, 1)
        local newValue = sliderPosition * 4
        updateSpeedSlider(newValue)
    end

    speedSliderBG.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDraggingSpeed = true
            updateSpeedFromPosition(input)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDraggingSpeed = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if isDraggingSpeed and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSpeedFromPosition(input)
        end
    end)

    local keybindInputActive = false
    local currentAnimationForKeybind = nil

    local audioIds = {}
    local function loadAudioIds()
        local url = "https://raw.githubusercontent.com/BloxiAstra/audios/refs/heads/main/ids.json"
        local success, response = pcall(function()
            return game:HttpGet(url)
        end)
        if success then
            local decodeSuccess, data = pcall(HttpService.JSONDecode, HttpService, response)
            if decodeSuccess and data.audio_ids then
                for _, id in ipairs(data.audio_ids) do
                    audioIds[tostring(id)] = true
                end
            else
                warn("Failed to decode ids.json or invalid format: " .. tostring(data))
            end
        else
            warn("Failed to fetch ids.json: " .. tostring(response))
        end
    end
    loadAudioIds()

    local function createAnimationButton(animName, animId, parentFrame)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 45)
        container.BackgroundTransparency = 1
        container.Parent = parentFrame

        local nameButton = Instance.new("TextButton")
        nameButton.Size = UDim2.new(0.55, 0, 0, 35)
        nameButton.Position = UDim2.new(0, 5, 0, 5)
        nameButton.Text = animName
        nameButton.TextColor3 = Color3.fromRGB(220, 220, 220)
        nameButton.TextSize = 14
        nameButton.Font = Enum.Font.SourceSansBold
        nameButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        nameButton.BorderSizePixel = 0
        nameButton.TextXAlignment = Enum.TextXAlignment.Left
        nameButton.TextTruncate = Enum.TextTruncate.AtEnd
        local nameCorner = Instance.new("UICorner")
        nameCorner.CornerRadius = UDim.new(0, 6)
        nameCorner.Parent = nameButton
        nameButton.Parent = container

        nameButton.MouseButton1Click:Connect(function()
            playFakeAnimation(tostring(animId))
            setclipboard(tostring(animId))
        end)

        local favoriteButton = Instance.new("TextButton")
        favoriteButton.Size = UDim2.new(0, 30, 0, 30)
        favoriteButton.Position = UDim2.new(0.57, 5, 0, 7)
        favoriteButton.Text = favoriteAnimations[animName] and "★" or "☆"
        favoriteButton.TextColor3 = Color3.fromRGB(255, 215, 0)
        favoriteButton.TextSize = 18
        favoriteButton.Font = Enum.Font.GothamBold
        favoriteButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        favoriteButton.BackgroundTransparency = 1
        favoriteButton.BorderSizePixel = 0
        local favCorner = Instance.new("UICorner")
        favCorner.CornerRadius = UDim.new(1, 0)
        favCorner.Parent = favoriteButton
        favoriteButton.Parent = container

        local keybindButton = Instance.new("TextButton")
        keybindButton.Size = UDim2.new(0, 40, 0, 30)
        keybindButton.Position = UDim2.new(0.73, 0, 0, 7)
        keybindButton.Text = "Bind"
        keybindButton.TextColor3 = Color3.fromRGB(150, 150, 255)
        keybindButton.TextSize = 12
        keybindButton.Font = Enum.Font.GothamMedium
        keybindButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        keybindButton.BorderSizePixel = 0
        local keybindCorner = Instance.new("UICorner")
        keybindCorner.CornerRadius = UDim.new(0, 6)
        keybindCorner.Parent = keybindButton
        keybindButton.Parent = container

        local removeBindButton = Instance.new("TextButton")
        removeBindButton.Size = UDim2.new(0, 30, 0, 30)
        removeBindButton.Position = UDim2.new(0.87, 0, 0, 7)
        removeBindButton.Text = "X"
        removeBindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        removeBindButton.TextSize = 18
        removeBindButton.Font = Enum.Font.GothamBold
        removeBindButton.BackgroundTransparency = 1
        removeBindButton.BorderSizePixel = 0
        removeBindButton.Visible = false
        removeBindButton.Parent = container

        favoriteButton.MouseButton1Click:Connect(function()
            if favoriteAnimations[animName] then
                favoriteAnimations[animName] = nil
                favoriteButton.Text = "☆"
                if favTabButton.BackgroundColor3 == Color3.fromRGB(45, 45, 50) then
                    animationButtons[animName].Container.Visible = false
                    local yOffset = 0
                    for _, buttonData in pairs(animationButtons) do
                        if buttonData.Container.Visible then
                            buttonData.Container.Position = UDim2.new(0, 0, 0, yOffset)
                            yOffset = yOffset + 50
                        end
                    end
                    favScrollFrame.CanvasSize = UDim2.new(0, 0, 0, yOffset)
                end
            else
                favoriteAnimations[animName] = tostring(animId)
                favoriteButton.Text = "★"
                if favTabButton.BackgroundColor3 == Color3.fromRGB(45, 45, 50) then
                    updateAnimationButtons("favorites", searchBox.Text)
                end
            end
            saveFavorites()
        end)

        keybindButton.MouseButton1Click:Connect(function()
            if keybindInputActive then return end
            keybindInputActive = true
            currentAnimationForKeybind = animName
            keybindButton.Text = "..."

            local connection
            connection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
                if not keybindInputActive or currentAnimationForKeybind ~= animName then
                    connection:Disconnect()
                    return
                end
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    animationKeybinds[animName] = input.KeyCode
                    saveKeybinds()
                    keybindButton.Text = input.KeyCode.Name
                    removeBindButton.Visible = true
                    keybindInputActive = false
                    currentAnimationForKeybind = nil
                    connection:Disconnect()
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    keybindButton.Text = "Bind"
                    removeBindButton.Visible = false
                    keybindInputActive = false
                    currentAnimationForKeybind = nil
                    connection:Disconnect()
                end
            end)
        end)

        removeBindButton.MouseButton1Click:Connect(function()
            animationKeybinds[animName] = nil
            saveKeybinds()
            keybindButton.Text = "Bind"
            removeBindButton.Visible = false
        end)
        
        local buttonData = {
            Container = container,
            NameButton = nameButton,
            FavoriteButton = favoriteButton,
            KeybindButton = keybindButton,
            RemoveBindButton = removeBindButton
        }
        
        animationButtons[animName] = buttonData
        return buttonData
    end

    local function updateAnimationButtons(tab, searchText)
        searchText = searchText or ""
        local scrollFrame = (tab == "all") and allScrollFrame or (tab == "favorites") and favScrollFrame or musicScrollFrame
        local animationList = (tab == "all" or tab == "music") and BuiltInAnimationsR15 or favoriteAnimations

        for _, buttonData in pairs(animationButtons) do
            if buttonData.Container then
                buttonData.Container:Destroy()
            end
        end
        animationButtons = {}

        local yOffset = 0
        local lowerSearchText = string.lower(searchText)

        if tab == "all" then
            for _, animName in ipairs(BuiltInAnimationsOrder) do
                local animId = BuiltInAnimationsR15[animName]
                if animId and animName then
                    local lowerAnimName = string.lower(animName)
                    if searchText == "" or string.find(lowerAnimName, lowerSearchText, 1, true) then
                        local buttonData = createAnimationButton(animName, animId, scrollFrame)
                        buttonData.Container.Position = UDim2.new(0, 0, 0, yOffset)
                        local keybind = animationKeybinds[animName]
                        if keybind then
                            buttonData.KeybindButton.Text = keybind.Name
                            buttonData.RemoveBindButton.Visible = true
                        end
                        yOffset = yOffset + 50
                    end
                end
            end
        elseif tab == "favorites" then
            for animName, animId in pairs(animationList) do
                if animName and animId then
                    local lowerAnimName = string.lower(animName)
                    if searchText == "" or string.find(lowerAnimName, lowerSearchText, 1, true) then
                        local buttonData = createAnimationButton(animName, animId, scrollFrame)
                        buttonData.Container.Position = UDim2.new(0, 0, 0, yOffset)
                        local keybind = animationKeybinds[animName]
                        if keybind then
                            buttonData.KeybindButton.Text = keybind.Name
                            buttonData.RemoveBindButton.Visible = true
                        end
                        yOffset = yOffset + 50
                    end
                end
            end
        elseif tab == "music" then
            for _, animName in ipairs(BuiltInAnimationsOrder) do
                local animId = BuiltInAnimationsR15[animName]
                if animId and animName and audioIds[tostring(animId)] then
                    local lowerAnimName = string.lower(animName)
                    if searchText == "" or string.find(lowerAnimName, lowerSearchText, 1, true) then
                        local buttonData = createAnimationButton(animName, animId, scrollFrame)
                        buttonData.Container.Position = UDim2.new(0, 0, 0, yOffset)
                        local keybind = animationKeybinds[animName]
                        if keybind then
                            buttonData.KeybindButton.Text = keybind.Name
                            buttonData.RemoveBindButton.Visible = true
                        end
                        yOffset = yOffset + 50
                    end
                end
            end
        end
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, yOffset)
    end

    updateAnimationButtons("all", "")

    allTabButton.MouseButton1Click:Connect(function()
        allScrollFrame.Visible = true
        favScrollFrame.Visible = false
        musicScrollFrame.Visible = false
        allTabButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        favTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        musicTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        updateAnimationButtons("all", searchBox.Text)
    end)

    favTabButton.MouseButton1Click:Connect(function()
        allScrollFrame.Visible = false
        favScrollFrame.Visible = true
        musicScrollFrame.Visible = false
        allTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        favTabButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        musicTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        updateAnimationButtons("favorites", searchBox.Text)
    end)

    musicTabButton.MouseButton1Click:Connect(function()
        allScrollFrame.Visible = false
        favScrollFrame.Visible = false
        musicScrollFrame.Visible = true
        allTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        favTabButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        musicTabButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        updateAnimationButtons("music", searchBox.Text)
    end)

    local searchDebounce = false
    searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        if searchDebounce then return end
        searchDebounce = true
        task.delay(0.2, function()
            if allTabButton.BackgroundColor3 == Color3.fromRGB(45, 45, 50) then
                updateAnimationButtons("all", searchBox.Text)
            elseif favTabButton.BackgroundColor3 == Color3.fromRGB(45, 45, 50) then
                updateAnimationButtons("favorites", searchBox.Text)
            else
                updateAnimationButtons("music", searchBox.Text)
            end
            searchDebounce = false
        end)
    end)

    local keybindInputActive = false
    local currentAnimationForKeybind = nil

    local audioIds = {}
    local function loadAudioIds()
        local url = "https://raw.githubusercontent.com/BloxiAstra/audios/refs/heads/main/ids.json"
        local success, response = pcall(function()
            return game:HttpGet(url)
        end)
        if success then
            local decodeSuccess, data = pcall(HttpService.JSONDecode, HttpService, response)
            if decodeSuccess and data.audio_ids then
                for _, id in ipairs(data.audio_ids) do
                    audioIds[tostring(id)] = true
                end
            else
                warn("Failed to decode ids.json or invalid format: " .. tostring(data))
            end
        else
            warn("Failed to fetch ids.json: " .. tostring(response))
        end
    end
    loadAudioIds()

    local function createMarker(name, initialRatio, defaultKey)
        local markerContainer = Instance.new("Frame")
        markerContainer.Name = name
        markerContainer.Size = UDim2.new(0, 0, 1, 0) -- Width is 0, uses position
        markerContainer.Position = UDim2.new(initialRatio, 0, 0, 0)
        markerContainer.BackgroundTransparency = 1
        markerContainer.ZIndex = 4 -- Above slider fill/handle
        markerContainer.Parent = speedSection

        local marker = Instance.new("Frame")
        marker.Name = "Marker"
        marker.Size = UDim2.new(0, 4, 0, 30) -- Shorter marker line (30px)
        marker.Position = UDim2.new(0, -2, 0, 33) -- Position lower to avoid overlap with slider
        marker.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
        marker.BorderSizePixel = 0
        marker.ZIndex = 5
        local markerCorner = Instance.new("UICorner")
        markerCorner.CornerRadius = UDim.new(1, 0)
        markerCorner.Parent = marker
        marker.Parent = markerContainer
        
        local markerStroke = Instance.new("UIStroke")
        markerStroke.Color = Color3.fromRGB(0, 150, 255)
        markerStroke.Thickness = 1
        markerStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        markerStroke.Parent = marker
        
        local leftArrow = Instance.new("TextLabel")
        leftArrow.Name = "LeftArrow"
        leftArrow.Text = "←"
        leftArrow.Font = Enum.Font.GothamMedium
        leftArrow.TextSize = 16
        leftArrow.TextColor3 = Color3.fromRGB(180, 180, 200)
        leftArrow.BackgroundTransparency = 1
        leftArrow.TextTransparency = 1 -- Start fully transparent
        leftArrow.Size = UDim2.new(0, 40, 0, 40)
        leftArrow.Position = UDim2.new(0, -40, 0, 33)
        leftArrow.ZIndex = 5
        leftArrow.Parent = markerContainer
        
        local rightArrow = Instance.new("TextLabel")
        rightArrow.Name = "RightArrow"
        rightArrow.Text = "→"
        rightArrow.Font = Enum.Font.GothamMedium
        rightArrow.TextSize = 16
        rightArrow.TextColor3 = Color3.fromRGB(180, 180, 200)
        rightArrow.BackgroundTransparency = 1
        rightArrow.TextTransparency = 1 -- Start fully transparent
        rightArrow.Size = UDim2.new(0, 40, 0, 40)
        rightArrow.Position = UDim2.new(0, 4, 0, 33)
        rightArrow.ZIndex = 5
        rightArrow.Parent = markerContainer
        
        -- Create a larger proximity detection area
        local proximityArea = Instance.new("Frame")
        proximityArea.Name = "ProximityArea"
        proximityArea.Size = UDim2.new(0, 120, 0, 50)
        proximityArea.Position = UDim2.new(0, -60, 0, 23)
        proximityArea.BackgroundTransparency = 1
        proximityArea.ZIndex = 4
        proximityArea.Parent = markerContainer

        local hitbox = Instance.new("Frame") -- Larger hitbox for dragging
        hitbox.Name = "Hitbox"
        hitbox.Size = UDim2.new(0, 84, 0, 40) -- Much wider hitbox
        hitbox.Position = UDim2.new(0, -41, 0, 33) -- Position to cover arrows and marker
        hitbox.BackgroundTransparency = 1 -- Make hitbox invisible
        hitbox.ZIndex = 6
        hitbox.Parent = markerContainer

        local keybind = Instance.new("TextButton")
        keybind.Name = "KeybindButton"
        keybind.Size = UDim2.new(0, 40, 0, 30) -- Larger keybind button
        keybind.Position = UDim2.new(0, -20, 0, 63) -- Position further below marker
        keybind.Text = defaultKey == "" and "key" or defaultKey
        keybind.Font = Enum.Font.GothamMedium
        keybind.TextSize = 14 -- Slightly larger text
        keybind.TextColor3 = Color3.fromRGB(220, 220, 220)
        keybind.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        keybind.AutoButtonColor = false
        keybind.ZIndex = 5
        local keybindCorner = Instance.new("UICorner")
        keybindCorner.CornerRadius = UDim.new(0, 6)
        keybindCorner.Parent = keybind
        keybind.Parent = markerContainer
        
        local keybindStroke = Instance.new("UIStroke")
        keybindStroke.Color = Color3.fromRGB(45, 45, 50)
        keybindStroke.Thickness = 1
        keybindStroke.Parent = keybind

        local removeBindButton = Instance.new("TextButton")
        removeBindButton.Name = "RemoveBindButton"
        removeBindButton.Size = UDim2.new(0, 20, 0, 20) -- Standard size remove button
        removeBindButton.Position = UDim2.new(0, 25, 0, 69) -- Position near keybind button but lower
        removeBindButton.Text = "X"
        removeBindButton.TextColor3 = Color3.fromRGB(255, 100, 100)
        removeBindButton.TextSize = 12
        removeBindButton.Font = Enum.Font.GothamBold
        removeBindButton.BackgroundTransparency = 1
        removeBindButton.TextTransparency = 1 -- Start fully transparent
        removeBindButton.ZIndex = 6
        removeBindButton.Visible = defaultKey ~= "None" and defaultKey ~= "" -- Only show if key is set
        removeBindButton.Parent = markerContainer
        
        -- Create proximity area for the keybind button
        local keybindProximityArea = Instance.new("Frame")
        keybindProximityArea.Name = "KeybindProximityArea"
        keybindProximityArea.Size = UDim2.new(0, 80, 0, 40) -- Area covering keybind button
        keybindProximityArea.Position = UDim2.new(0, -20, 0, 59) -- Position to cover keybind and X button
        keybindProximityArea.BackgroundTransparency = 1
        keybindProximityArea.ZIndex = 4
        keybindProximityArea.Parent = markerContainer

        keybind.MouseEnter:Connect(function()
            TweenService:Create(keybind, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(50, 50, 60)}):Play()
        end)
        keybind.MouseLeave:Connect(function()
            TweenService:Create(keybind, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(40, 40, 45)}):Play()
        end)

        removeBindButton.MouseButton1Click:Connect(function()
            speedKeybindData[name].key = ""
            keybind.Text = "key"
            removeBindButton.Visible = false
            saveSpeedKeybinds()
            if speedKeybindFunctions[name] then
                speedKeybindFunctions[name]:Disconnect()
                speedKeybindFunctions[name] = nil
            end
        end)

        return markerContainer
    end

    local slowMarkerRatio = (speedKeybindData.SlowMarker and speedKeybindData.SlowMarker.ratio) or 0.2
    local slowMarkerKey = (speedKeybindData.SlowMarker and speedKeybindData.SlowMarker.key) or ""
    local fastMarkerRatio = (speedKeybindData.FastMarker and speedKeybindData.FastMarker.ratio) or 0.8
    local fastMarkerKey = (speedKeybindData.FastMarker and speedKeybindData.FastMarker.key) or ""

    local SlowMarkerContainer = createMarker("SlowMarker", slowMarkerRatio, slowMarkerKey)
    local FastMarkerContainer = createMarker("FastMarker", fastMarkerRatio, fastMarkerKey)

    local currentDraggingMarker = nil
    local function setupMarker(markerContainer)
        local hitbox = markerContainer:FindFirstChild("Hitbox")
        local keybindButton = markerContainer:FindFirstChild("KeybindButton")
        local removeButton = markerContainer:FindFirstChild("RemoveBindButton")
        local proximityArea = markerContainer:FindFirstChild("ProximityArea")
        local leftArrow = markerContainer:FindFirstChild("LeftArrow")
        local rightArrow = markerContainer:FindFirstChild("RightArrow")
        local keybindProximityArea = markerContainer:FindFirstChild("KeybindProximityArea")
        
        if not hitbox or not keybindButton or not removeButton or
           not proximityArea or not leftArrow or not rightArrow or
           not keybindProximityArea then
            warn("Missing required elements for marker setup")
            return
        end

        local markerName = markerContainer.Name
        local currentKeybindEnum = keybindButton.Text ~= "key" and keybindButton.Text ~= "" and Enum.KeyCode[keybindButton.Text] or nil
        local fadeTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local fadeInTweens = {
            left = TweenService:Create(leftArrow, fadeTweenInfo, {TextTransparency = 0}),
            right = TweenService:Create(rightArrow, fadeTweenInfo, {TextTransparency = 0}),
            removeBtn = removeButton.Visible and TweenService:Create(removeButton, fadeTweenInfo, {TextTransparency = 0}) or nil
        }
        local fadeOutTweens = {
            left = TweenService:Create(leftArrow, fadeTweenInfo, {TextTransparency = 1}),
            right = TweenService:Create(rightArrow, fadeTweenInfo, {TextTransparency = 1}),
            removeBtn = removeButton.Visible and TweenService:Create(removeButton, fadeTweenInfo, {TextTransparency = 1}) or nil
        }
        local arrowsVisible = false
        local removeBtnVisible = false
        
        -- Handle proximity detection for arrows
        local function checkProximity(mousePosition)
            local proximityAreaPos = proximityArea.AbsolutePosition
            local proximityAreaSize = proximityArea.AbsoluteSize
            
            -- Check if mouse is inside proximity area
            local isInside = 
                mousePosition.X >= proximityAreaPos.X and
                mousePosition.X <= proximityAreaPos.X + proximityAreaSize.X and
                mousePosition.Y >= proximityAreaPos.Y and
                mousePosition.Y <= proximityAreaPos.Y + proximityAreaSize.Y
            
            -- Show/hide arrows accordingly
            if isInside and not arrowsVisible and not currentDraggingMarker then
                arrowsVisible = true
                fadeInTweens.left:Play()
                fadeInTweens.right:Play()
            elseif not isInside and arrowsVisible and not currentDraggingMarker then
                arrowsVisible = false
                fadeOutTweens.left:Play()
                fadeOutTweens.right:Play()
            end
        end
        
        -- Show arrows while dragging
        local function showArrowsWhileDragging()
            if currentDraggingMarker == markerContainer and not arrowsVisible then
                arrowsVisible = true
                fadeInTweens.left:Play()
                fadeInTweens.right:Play()
            end
        end
        
        -- Connect proximity checker to mouse movement
        -- Handle proximity detection for remove button
        local function checkKeybindProximity(mousePosition)
            if not removeButton.Visible then return end -- Skip if button shouldn't be visible at all
            
            local proximityAreaPos = keybindProximityArea.AbsolutePosition
            local proximityAreaSize = keybindProximityArea.AbsoluteSize
            
            -- Check if mouse is inside keybind proximity area
            local isInside = 
                mousePosition.X >= proximityAreaPos.X and
                mousePosition.X <= proximityAreaPos.X + proximityAreaSize.X and
                mousePosition.Y >= proximityAreaPos.Y and
                mousePosition.Y <= proximityAreaPos.Y + proximityAreaSize.Y
            
            -- Show/hide remove button accordingly
            if isInside and not removeBtnVisible then
                removeBtnVisible = true
                if fadeInTweens.removeBtn then fadeInTweens.removeBtn:Play() end
            elseif not isInside and removeBtnVisible then
                removeBtnVisible = false
                if fadeOutTweens.removeBtn then fadeOutTweens.removeBtn:Play() end
            end
        end
        
        local proximityConnection = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                checkProximity(input.Position)
                checkKeybindProximity(input.Position)
                showArrowsWhileDragging()
            end
        end)
        
        hitbox.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                currentDraggingMarker = markerContainer
                -- Show arrows when dragging starts
                arrowsVisible = true
                fadeInTweens.left:Play()
                fadeInTweens.right:Play()
            end
        end)

        -- Use UserInputService for global mouse up detection
        local mouseUpConnection = UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                if currentDraggingMarker == markerContainer then
                    currentDraggingMarker = nil
                    saveSpeedKeybinds() -- Save position when drag ends
                    
                    -- Check if mouse is still over proximity area after dragging
                    local mousePos = UserInputService:GetMouseLocation()
                    local proximityAreaPos = proximityArea.AbsolutePosition
                    local proximityAreaSize = proximityArea.AbsoluteSize
                    
                    local isInside = 
                        mousePos.X >= proximityAreaPos.X and
                        mousePos.X <= proximityAreaPos.X + proximityAreaSize.X and
                        mousePos.Y >= proximityAreaPos.Y and
                        mousePos.Y <= proximityAreaPos.Y + proximityAreaSize.Y
                    
                    -- Only hide arrows if mouse is outside proximity area
                    if not isInside then
                        arrowsVisible = false
                        fadeOutTweens.left:Play()
                        fadeOutTweens.right:Play()
                    end
                end
            end
        end)

        -- Use RunService for smooth dragging
        local function updateMarkerFromMouse()
            if currentDraggingMarker == markerContainer then
                local mouse = UserInputService:GetMouseLocation()
                local x = mouse.X - speedSection.AbsolutePosition.X
                local ratio = math.clamp(x / speedSection.AbsoluteSize.X, 0, 1)
                markerContainer.Position = UDim2.new(ratio, 0, 0, 0)
                speedKeybindData[markerName].ratio = ratio -- Update data while dragging
                -- We don't save file on every update to avoid performance issues
            end
        end
        
        local dragUpdateConnection = RunService.Heartbeat:Connect(updateMarkerFromMouse)

        -- Cleanup connections when the GUI is destroyed
        markerContainer.Destroying:Connect(function()
            if mouseUpConnection then mouseUpConnection:Disconnect() end
            if dragUpdateConnection then dragUpdateConnection:Disconnect() end
            if proximityConnection then proximityConnection:Disconnect() end
            if speedKeybindFunctions[markerName] then
                speedKeybindFunctions[markerName]:Disconnect()
                speedKeybindFunctions[markerName] = nil
            end
            -- Cancel any active tweens
            fadeInTweens.left:Cancel()
            fadeInTweens.right:Cancel()
            fadeOutTweens.left:Cancel()
            fadeOutTweens.right:Cancel()
            if fadeInTweens.removeBtn then fadeInTweens.removeBtn:Cancel() end
            if fadeOutTweens.removeBtn then fadeOutTweens.removeBtn:Cancel() end
        end)

        -- Keybind setting logic
        keybindButton.MouseButton1Click:Connect(function()
            if keybindInputActive then return end -- Prevent multiple binds at once
            keybindInputActive = true -- Use the global flag
            currentAnimationForKeybind = nil -- Ensure animation bind isn't active
            keybindButton.Text = "..."

            local connection
            connection = UserInputService.InputBegan:Connect(function(input)
                if not keybindInputActive then connection:Disconnect() return end -- Check if still binding this

                if input.UserInputType == Enum.UserInputType.Keyboard then
                    local keyCode = input.KeyCode
                    if keyCode == Enum.KeyCode.Escape then -- Allow cancelling with Escape
                       keybindButton.Text = currentKeybindEnum and currentKeybindEnum.Name or "None"
                    else
                        keybindButton.Text = keyCode.Name
                        currentKeybindEnum = keyCode
                        removeButton.Visible = true
                        speedKeybindData[markerName].key = keyCode.Name -- Update data for saving
                        saveSpeedKeybinds()

                        -- Update keybind function
                        if speedKeybindFunctions[markerName] then
                            speedKeybindFunctions[markerName]:Disconnect()
                        end
                        speedKeybindFunctions[markerName] = UserInputService.InputBegan:Connect(function(input)
                           if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybindEnum then
                                local ratio = markerContainer.Position.X.Scale
                                updateSpeedSlider(ratio * 4)
                            end
                        end)
                        
                        -- Update remove button and its tweens
                        removeButton.Visible = true
                        removeButton.TextTransparency = removeBtnVisible and 0 or 1 -- Keep current transparency state
                        -- Recreate tweens for the remove button
                        fadeInTweens.removeBtn = TweenService:Create(removeButton, fadeTweenInfo, {TextTransparency = 0})
                        fadeOutTweens.removeBtn = TweenService:Create(removeButton, fadeTweenInfo, {TextTransparency = 1})
                   end
                    keybindInputActive = false
                    connection:Disconnect()
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    -- Clicked elsewhere, cancel binding
                    keybindButton.Text = currentKeybindEnum and currentKeybindEnum.Name or "None"
                    keybindInputActive = false
                    connection:Disconnect()
                end
            end)
        end)

        -- Initial keybind setup
        if currentKeybindEnum then
            if speedKeybindFunctions[markerName] then speedKeybindFunctions[markerName]:Disconnect() end
            speedKeybindFunctions[markerName] = UserInputService.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybindEnum then
                    local ratio = markerContainer.Position.X.Scale
                    updateSpeedSlider(ratio * 4)
                end
            end)
        end
    end

    setupMarker(SlowMarkerContainer)
    setupMarker(FastMarkerContainer)

    -- Restore dragging functionality
    local dragging = false
    local dragOffset = Vector2.new(0, 0)
    local currentTween = nil
    local shadowTween = nil
    local dragConnection
    local tweenInfoDrag = TweenInfo.new(0.05, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            local mousePos = UserInputService:GetMouseLocation()
            dragOffset = mousePos - Vector2.new(mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y)
            if dragConnection then dragConnection:Disconnect() end
            dragConnection = RunService.RenderStepped:Connect(function()
                if not dragging then return end
                local mousePos = UserInputService:GetMouseLocation()
                local targetPos = UDim2.new(0, mousePos.X - dragOffset.X, 0, mousePos.Y - dragOffset.Y)
                local shadowPos = UDim2.new(0, (mousePos.X - dragOffset.X) - 16, 0, (mousePos.Y - dragOffset.Y) - 16)
                if currentTween then currentTween:Cancel() end
                currentTween = TweenService:Create(mainFrame, tweenInfoDrag, {Position = targetPos})
                currentTween:Play()
                if shadowTween then shadowTween:Cancel() end
                shadowTween = TweenService:Create(shadowContainer, tweenInfoDrag, {Position = shadowPos})
                shadowTween:Play()
            end)
        end
    end)

    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            if dragConnection then
                dragConnection:Disconnect()
                dragConnection = nil
            end
            if currentTween then
                currentTween:Cancel()
                currentTween = nil
            end
            if shadowTween then
                shadowTween:Cancel()
                shadowTween = nil
            end
        end
    end)

    return screenGui
end

local function createCustomAnimationsGui()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CustomAnimationsGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    screenGui.Enabled = false

    loadCustomAnimations()
    loadKeybinds()

    -- Shadow Container Frame
    local shadowContainer = Instance.new("Frame")
    shadowContainer.Name = "shadowContainer"
    shadowContainer.BackgroundTransparency = 1
    shadowContainer.Size = UDim2.new(0, 332, 0, 482)
    shadowContainer.Position = UDim2.new(1, -336, 1, -486)
    shadowContainer.ZIndex = 1
    shadowContainer.Parent = screenGui
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadowContainer

    -- Main Shadow ImageLabel
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "shadow"
    shadow.Image = "rbxassetid://297774371"
    shadow.ImageColor3 = Color3.fromRGB(15, 15, 15)
    shadow.ImageTransparency = 0.3
    shadow.SliceCenter = Rect.new(20, 20, 280, 280)
    shadow.BackgroundTransparency = 1
    shadow.Size = UDim2.new(1, 0, 1, 0)
    shadow.Position = UDim2.new(0, 0, 0, 0)
    shadow.ZIndex = 1
    shadow.Parent = shadowContainer

    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 300, 0, 450) -- Set to 450 height as requested
    mainFrame.Position = UDim2.new(1, -320, 1, -500)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.ZIndex = 2
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 12)
    uiCorner.Parent = mainFrame
    local uiGradient = Instance.new("UIGradient")
    uiGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 30)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 40))
    }
    uiGradient.Parent = mainFrame
    mainFrame.Parent = screenGui

    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 50)
    titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    titleBar.BorderSizePixel = 0
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = titleBar
    local titleGradient = Instance.new("UIGradient")
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 45)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 55))
    }
    titleGradient.Parent = titleBar
    titleBar.Parent = mainFrame

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(0.7, 0, 1, 0)
    titleLabel.Position = UDim2.new(0.05, 0, 0, 0)
    titleLabel.Text = "Custom Animations"
    titleLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.BackgroundTransparency = 1
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = titleBar

    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Size = UDim2.new(0, 40, 0, 40)
    minimizeButton.Position = UDim2.new(1, -45, 0, 5)
    minimizeButton.Text = "−"
    minimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    minimizeButton.TextSize = 28
    minimizeButton.Font = Enum.Font.GothamBold
    minimizeButton.BackgroundTransparency = 1
    minimizeButton.Parent = titleBar
    
    minimizeButton.MouseEnter:Connect(function()
        minimizeButton.TextColor3 = Color3.fromRGB(0, 191, 255)
    end)
    minimizeButton.MouseLeave:Connect(function()
        minimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    end)

    local contentFrame = Instance.new("Frame")
    contentFrame.Size = UDim2.new(1, 0, 1, -110)
    contentFrame.Position = UDim2.new(0, 0, 0, 50)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = mainFrame

    -- Redesigned input area for custom animations
    local inputFrame = Instance.new("Frame")
    inputFrame.Size = UDim2.new(0.9, 0, 0, 45)
    inputFrame.Position = UDim2.new(0.05, 0, 0, 10)
    inputFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    inputFrame.BorderSizePixel = 0
    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 8)
    inputCorner.Parent = inputFrame
    inputFrame.Parent = contentFrame

    -- Animation Name box (smaller, left)
    local nameBox = Instance.new("TextBox")
    nameBox.Size = UDim2.new(0.38, -4, 0, 30)
    nameBox.Position = UDim2.new(0.02, 0, 0.5, -15)
    nameBox.PlaceholderText = "Name"
    nameBox.Text = ""
    nameBox.TextColor3 = Color3.fromRGB(220, 220, 220)
    nameBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
    nameBox.TextSize = 14
    nameBox.Font = Enum.Font.Gotham
    nameBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    nameBox.BorderSizePixel = 0
    nameBox.TextWrapped = true
    nameBox.TextScaled = false
    nameBox.TextSize = 14
    nameBox.Focused:Connect(function()
        nameBox.TextScaled = true
    end)
    nameBox.FocusLost:Connect(function()
        if nameBox.Text == "" then
            nameBox.TextScaled = false
            nameBox.TextSize = 14
        end
    end)
    local nameCorner = Instance.new("UICorner")
    nameCorner.CornerRadius = UDim.new(0, 6)
    nameCorner.Parent = nameBox
    nameBox.Parent = inputFrame

    -- Animation ID box (smaller, center)
    local idBox = Instance.new("TextBox")
    idBox.Size = UDim2.new(0.38, -4, 0, 30)
    idBox.Position = UDim2.new(0.42, 0, 0.5, -15)
    idBox.PlaceholderText = "ID"
    idBox.Text = ""
    idBox.TextColor3 = Color3.fromRGB(220, 220, 220)
    idBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
    idBox.TextSize = 14
    idBox.Font = Enum.Font.Gotham
    idBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    idBox.BorderSizePixel = 0
    idBox.TextWrapped = true
    idBox.TextScaled = false
    idBox.TextSize = 14
    idBox.Focused:Connect(function()
        idBox.TextScaled = true
    end)
    idBox.FocusLost:Connect(function()
        if idBox.Text == "" then
            idBox.TextScaled = false
            idBox.TextSize = 14
        end
    end)
    local idCorner = Instance.new("UICorner")
    idCorner.CornerRadius = UDim.new(0, 6)
    idCorner.Parent = idBox
    idBox.Parent = inputFrame

    -- Add button (right, dark theme, blue accent on hover)
    local addButton = Instance.new("TextButton")
    addButton.Size = UDim2.new(0.18, 0, 0, 30)
    addButton.Position = UDim2.new(0.81, 0, 0.5, -15)
    addButton.Text = "Add"
    addButton.TextColor3 = Color3.fromRGB(220, 220, 255)
    addButton.TextSize = 15
    addButton.Font = Enum.Font.GothamSemibold
    addButton.BackgroundColor3 = Color3.fromRGB(35, 40, 60)
    addButton.BorderSizePixel = 0
    local addCorner = Instance.new("UICorner")
    addCorner.CornerRadius = UDim.new(0, 6)
    addCorner.Parent = addButton
    addButton.Parent = inputFrame
    -- Blue accent on hover
    addButton.MouseEnter:Connect(function()
        addButton.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
    end)
    addButton.MouseLeave:Connect(function()
        addButton.BackgroundColor3 = Color3.fromRGB(35, 40, 60)
    end)

    -- Move search bar up, just below inputFrame
    local searchBox = Instance.new("TextBox")
    searchBox.Size = UDim2.new(0.9, 0, 0, 30)
    searchBox.Position = UDim2.new(0.05, 0, 0, 60)
    searchBox.PlaceholderText = "Search custom animations..."
    searchBox.Text = ""
    searchBox.TextColor3 = Color3.fromRGB(200, 200, 200)
    searchBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
    searchBox.TextSize = 14
    searchBox.Font = Enum.Font.Gotham
    searchBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    searchBox.BorderSizePixel = 0
    local searchCorner = Instance.new("UICorner")
    searchCorner.CornerRadius = UDim.new(0, 8)
    searchCorner.Parent = searchBox
    searchBox.Parent = contentFrame

    -- Move scrollFrame up, just below searchBox, and make it fill up to the speed bar
    local scrollFrame = Instance.new("ScrollingFrame")
    scrollFrame.Size = UDim2.new(0.9, 0, 0, 250)
    scrollFrame.Position = UDim2.new(0.05, 0, 0, 100)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 4
    scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.Parent = contentFrame

    local speedSection = Instance.new("Frame")
    speedSection.Name = "SpeedSection" -- Add name for easier referencing
    speedSection.Size = UDim2.new(0.9, 0, 0, 90) -- Increased height for markers
    speedSection.Position = UDim2.new(0.05, 0, 0, 350)
    speedSection.BackgroundTransparency = 1
    speedSection.Parent = contentFrame

    local speedLabel = Instance.new("TextLabel")
    speedLabel.Size = UDim2.new(1, 0, 0, 20)
    speedLabel.Text = "Animation Speed: 100%"
    speedLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    speedLabel.TextSize = 14
    speedLabel.Font = Enum.Font.GothamMedium
    speedLabel.BackgroundTransparency = 1
    speedLabel.Parent = speedSection

    local speedSliderBG = Instance.new("Frame")
    speedSliderBG.Size = UDim2.new(1, 0, 0, 6)
    speedSliderBG.Position = UDim2.new(0, 0, 0, 30)
    speedSliderBG.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    speedSliderBG.BorderSizePixel = 0
    local speedBGCorner = Instance.new("UICorner")
    speedBGCorner.CornerRadius = UDim.new(1, 0)
    speedBGCorner.Parent = speedSliderBG
    speedSliderBG.Parent = speedSection

    local speedSliderFill = Instance.new("Frame")
    speedSliderFill.Size = UDim2.new(0.25, 0, 1, 0)
    speedSliderFill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    speedSliderFill.BorderSizePixel = 0
    local speedFillCorner = Instance.new("UICorner")
    speedFillCorner.CornerRadius = UDim.new(1, 0)
    speedFillCorner.Parent = speedSliderFill
    speedSliderFill.Parent = speedSliderBG

    local speedSliderHandle = Instance.new("Frame")
    speedSliderHandle.Size = UDim2.new(0, 16, 0, 16)
    speedSliderHandle.Position = UDim2.new(0.25, -8, 0.5, -8)
    speedSliderHandle.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    speedSliderHandle.BorderSizePixel = 0
    local speedHandleCorner = Instance.new("UICorner")
    speedHandleCorner.CornerRadius = UDim.new(1, 0)
    speedHandleCorner.Parent = speedSliderHandle
    speedSliderHandle.Parent = speedSliderBG

    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    local function updateSpeedSlider(value)
        local fillValue = value / 4
        local tween = TweenService:Create(speedSliderFill, tweenInfo, {Size = UDim2.new(math.clamp(fillValue, 0, 1), 0, 1, 0)})
        tween:Play()
        local handleTween = TweenService:Create(speedSliderHandle, tweenInfo, {Position = UDim2.new(math.clamp(fillValue, 0, 1), -8, 0.5, -8)})
        handleTween:Play()
        speedLabel.Text = "Animation Speed: " .. math.floor(value * 100) .. "%"
        animationState.speed = value
    end

    updateSpeedSlider(1)

    local isDraggingSpeed = false
    local function updateSpeedFromPosition(input)
        local sliderPosition = (input.Position.X - speedSliderBG.AbsolutePosition.X) / speedSliderBG.AbsoluteSize.X
        sliderPosition = math.clamp(sliderPosition, 0, 1)
        local newValue = sliderPosition * 4
        updateSpeedSlider(newValue)
    end

    speedSliderBG.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDraggingSpeed = true
            updateSpeedFromPosition(input)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDraggingSpeed = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if isDraggingSpeed and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSpeedFromPosition(input)
        end
    end)

    -- No keybind markers for Custom Animations GUI - speed slider only

    local function createCustomButton(animName, animId)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 45)
        container.BackgroundTransparency = 1
        container.Parent = scrollFrame

        local nameButton = Instance.new("TextButton")
        nameButton.Size = UDim2.new(0.55, 0, 0, 35)
        nameButton.Position = UDim2.new(0, 5, 0, 5)
        nameButton.Text = animName
        nameButton.TextColor3 = Color3.fromRGB(220, 220, 220)
        nameButton.TextSize = 14
        nameButton.Font = Enum.Font.SourceSansBold
        nameButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        nameButton.BorderSizePixel = 0
        nameButton.TextXAlignment = Enum.TextXAlignment.Left
        nameButton.TextTruncate = Enum.TextTruncate.AtEnd
        local nameCorner = Instance.new("UICorner")
        nameCorner.CornerRadius = UDim.new(0, 6)
        nameCorner.Parent = nameButton
        nameButton.Parent = container

        nameButton.MouseButton1Click:Connect(function()
            playFakeAnimation(tostring(animId))
        end)

        local keybindButton = Instance.new("TextButton")
        keybindButton.Size = UDim2.new(0, 40, 0, 30)
        keybindButton.Position = UDim2.new(0.57, 5, 0, 7)
        keybindButton.Text = "Bind"
        keybindButton.TextColor3 = Color3.fromRGB(150, 150, 255)
        keybindButton.TextSize = 12
        keybindButton.Font = Enum.Font.GothamMedium
        keybindButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        keybindButton.BorderSizePixel = 0
        local keybindCorner = Instance.new("UICorner")
        keybindCorner.CornerRadius = UDim.new(0, 6)
        keybindCorner.Parent = keybindButton
        keybindButton.Parent = container

        local removeBindButton = Instance.new("TextButton")
        removeBindButton.Size = UDim2.new(0, 30, 0, 30)
        removeBindButton.Position = UDim2.new(0.73, 0, 0, 7)
        removeBindButton.Text = "X"
        removeBindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        removeBindButton.TextSize = 18
        removeBindButton.Font = Enum.Font.GothamBold
        removeBindButton.BackgroundTransparency = 1
        removeBindButton.BorderSizePixel = 0
        removeBindButton.Visible = false
        removeBindButton.Parent = container

        local deleteButton = Instance.new("TextButton")
        deleteButton.Size = UDim2.new(0, 30, 0, 30)
        deleteButton.Position = UDim2.new(0.87, 0, 0, 7)
        deleteButton.Text = "🗑️"
        deleteButton.TextColor3 = Color3.fromRGB(255, 150, 150)
        deleteButton.TextSize = 16
        deleteButton.Font = Enum.Font.GothamBold
        deleteButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        deleteButton.BorderSizePixel = 0
        local deleteCorner = Instance.new("UICorner")
        deleteCorner.CornerRadius = UDim.new(1, 0)
        deleteCorner.Parent = deleteButton
        deleteButton.Parent = container

        keybindButton.MouseButton1Click:Connect(function()
            if keybindInputActive then return end
            keybindInputActive = true
            currentAnimationForKeybind = animName
            keybindButton.Text = "..."

            local connection
            connection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
                if not keybindInputActive or currentAnimationForKeybind ~= animName then
                    connection:Disconnect()
                    return
                end
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    animationKeybinds[animName] = input.KeyCode
                    saveKeybinds()
                    keybindButton.Text = input.KeyCode.Name
                    removeBindButton.Visible = true
                    keybindInputActive = false
                    currentAnimationForKeybind = nil
                    connection:Disconnect()
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    keybindButton.Text = "Bind"
                    removeBindButton.Visible = false
                    keybindInputActive = false
                    currentAnimationForKeybind = nil
                    connection:Disconnect()
                end
            end)
        end)

        removeBindButton.MouseButton1Click:Connect(function()
            animationKeybinds[animName] = nil
            saveKeybinds()
            keybindButton.Text = "Bind"
            removeBindButton.Visible = false
        end)

        deleteButton.MouseButton1Click:Connect(function()
            customAnimations[animName] = nil
            animationKeybinds[animName] = nil
            saveCustomAnimations()
            saveKeybinds()
            if container and container.Parent then
                container:Destroy()
            end
            customButtons[animName] = nil
            local yOffset = 0
            for _, buttonData in pairs(customButtons) do
                if buttonData and buttonData.Container then
                    buttonData.Container.Position = UDim2.new(0, 0, 0, yOffset)
                    yOffset = yOffset + 50
                end
            end
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, yOffset)
        end)

        customButtons[animName] = {
            Container = container,
            NameButton = nameButton,
            KeybindButton = keybindButton,
            RemoveBindButton = removeBindButton,
            DeleteButton = deleteButton
        }
    end

    local function updateCustomButtons(searchText)
        searchText = searchText or ""
        for _, buttonData in pairs(customButtons) do
            if buttonData and buttonData.Container then
                buttonData.Container:Destroy()
            end
        end
        customButtons = {}

        local sortedNames = {}
        for animName in pairs(customAnimations) do
            table.insert(sortedNames, animName)
        end
        table.sort(sortedNames)

        local yOffset = 0
        local lowerSearchText = string.lower(searchText)

        for _, animName in ipairs(sortedNames) do
            local animId = customAnimations[animName]
            if searchText == "" or string.find(string.lower(animName), lowerSearchText, 1, true) then
                createCustomButton(animName, animId)
                if customButtons[animName] then
                    customButtons[animName].Container.Position = UDim2.new(0, 0, 0, yOffset)
                    local keybind = animationKeybinds[animName]
                    if keybind then
                        customButtons[animName].KeybindButton.Text = keybind.Name
                        customButtons[animName].RemoveBindButton.Visible = true
                    else
                        customButtons[animName].KeybindButton.Text = "Bind"
                        customButtons[animName].RemoveBindButton.Visible = false
                    end
                    yOffset = yOffset + 50
                end
            end
        end
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, yOffset)
    end

    addButton.MouseButton1Click:Connect(function()
        local animName = nameBox.Text
        local animId = idBox.Text
        if animName ~= "" and animId ~= "" then
            if not customAnimations[animName] then
                customAnimations[animName] = animId
                saveCustomAnimations()
                preloadAnimations({[animName] = animId})
                updateCustomButtons(searchBox.Text)
                nameBox.Text = ""
                idBox.Text = ""
            else
                warn("Animation name already exists!")
            end
        else
            warn("Please enter both a name and an ID!")
        end
    end)

    local searchDebounce = false
    searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        if searchDebounce then return end
        searchDebounce = true
        task.delay(0.2, function()
            updateCustomButtons(searchBox.Text)
            searchDebounce = false
        end)
    end)

    updateCustomButtons()

    local originalGuiHeight = mainFrame.Size.Y.Offset
    local minimizedGuiHeight = titleBar.Size.Y.Offset
    local minimized = false
    local tweenInfoFade = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tweenInfoSize = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local originalTransparencies = {}
    local originalShadowSize = shadowContainer.Size
    local originalShadowPosition = shadowContainer.Position

for _, child in pairs(contentFrame:GetDescendants()) do
    if child:IsA("GuiObject") and not originalTransparencies[child] then
        originalTransparencies[child] = {
            BackgroundTransparency = child.BackgroundTransparency,
            TextTransparency = (child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox")) and child.TextTransparency or nil
        }
    end
end

minimizeButton.MouseButton1Click:Connect(function()
    minimized = not minimized

    if minimized then
        minimizeButton.Text = "+"
        contentFrame.Visible = false

        -- Fade out UI elements
        for _, child in pairs(contentFrame:GetDescendants()) do
            if child:IsA("GuiObject") then
                TweenService:Create(child, tweenInfoFade, {BackgroundTransparency = 1}):Play()
                if child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox") then
                    TweenService:Create(child, tweenInfoFade, {TextTransparency = 1}):Play()
                end
            end
        end
        
        -- Fade out shadow completely
        TweenService:Create(shadow, tweenInfoFade, {
            ImageTransparency = 1 -- Completely transparent
        }):Play()
        
        -- Resize main frame
        local sizeTween = TweenService:Create(
            mainFrame,
            tweenInfoSize,
            {Size = UDim2.new(0, mainFrame.Size.X.Offset, 0, minimizedGuiHeight)}
        )
        sizeTween:Play()
    else
        minimizeButton.Text = "−"
        contentFrame.Visible = true
        
        -- Keep shadow invisible during resize
        shadow.ImageTransparency = 1
        
        -- Resize main frame
        local sizeTween = TweenService:Create(
            mainFrame,
            tweenInfoSize,
            {Size = UDim2.new(0, mainFrame.Size.X.Offset, 0, originalGuiHeight)}
        )
        sizeTween:Play()
        
        -- Update shadow container position to be behind the current mainFrame position
        shadowContainer.Size = originalShadowSize
        -- Update position in completed handler to ensure it's correctly positioned

        sizeTween.Completed:Connect(function()
            -- Restore UI element transparencies
            for _, child in pairs(contentFrame:GetDescendants()) do
                if child:IsA("GuiObject") then
                    local orig = originalTransparencies[child]
                    if orig then
                        if orig.BackgroundTransparency ~= nil then
                            TweenService:Create(child, tweenInfoFade, {BackgroundTransparency = orig.BackgroundTransparency}):Play()
                        end
                        if orig.TextTransparency ~= nil then
                            TweenService:Create(child, tweenInfoFade, {TextTransparency = orig.TextTransparency}):Play()
                        end
                        if orig.Position then
                            TweenService:Create(child, tweenInfoFade, {Position = orig.Position}):Play()
                        end
                    end
                end
            end
            
            -- Position shadow container before fading in
            -- Calculate shadow position relative to mainFrame's current position
            shadowContainer.Size = UDim2.new(0, mainFrame.Size.X.Offset + 32, 0, mainFrame.Size.Y.Offset + 32)
            shadowContainer.Position = UDim2.new(0, mainFrame.AbsolutePosition.X - 16, 0, mainFrame.AbsolutePosition.Y - 16)
            
            -- Fade in shadow with a slight delay after GUI is maximized
            task.delay(0.1, function()
                TweenService:Create(shadow, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    ImageTransparency = 0.3
                }):Play()
            end)
        end)
    end
end)

    local dragging = false
    local dragOffset = Vector2.new(0, 0)
    local currentTween = nil
    local shadowTween = nil
    local dragConnection
    local tweenInfoDrag = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            local mousePos = UserInputService:GetMouseLocation()
            dragOffset = mousePos - Vector2.new(mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y)
            if dragConnection then dragConnection:Disconnect() end
            dragConnection = RunService.RenderStepped:Connect(function()
                if not dragging then return end
                local mousePos = UserInputService:GetMouseLocation()
                local targetPos = UDim2.new(0, mousePos.X - dragOffset.X, 0, mousePos.Y - dragOffset.Y)
                local shadowPos = UDim2.new(0, (mousePos.X - dragOffset.X) - 16, 0, (mousePos.Y - dragOffset.Y) - 16)
                if currentTween then currentTween:Cancel() end
                currentTween = TweenService:Create(mainFrame, tweenInfoDrag, {Position = targetPos})
                currentTween:Play()
                if shadowTween then shadowTween:Cancel() end
                shadowTween = TweenService:Create(shadowContainer, tweenInfoDrag, {Position = shadowPos})
                shadowTween:Play()
            end)
        end
    end)

    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            if dragConnection then
                dragConnection:Disconnect()
                dragConnection = nil
            end
            if currentTween then
                currentTween:Cancel()
                currentTween = nil
            end
            if shadowTween then
                shadowTween:Cancel()
                shadowTween = nil
            end
        end
    end)

    return screenGui
end

local function createDraggableGui(getGhostEnabled, toggleGhost)
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local LocalPlayer = game.Players.LocalPlayer

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "EnhancedGhostGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    screenGui.Enabled = false

    local shadowContainer = Instance.new("Frame")
    shadowContainer.Name = "shadowContainer"
    shadowContainer.BackgroundTransparency = 1
    shadowContainer.Size = UDim2.new(0, 352, 0, 291)
    shadowContainer.Position = UDim2.new(0.5, -176, 0.5, -146)
    shadowContainer.ZIndex = 1
    shadowContainer.Parent = screenGui
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadowContainer

    local shadow = Instance.new("ImageLabel")
    shadow.Name = "shadow"
    shadow.Image = "rbxassetid://297774371"
    shadow.ImageColor3 = Color3.fromRGB(15, 15, 15)
    shadow.ImageTransparency = 0.3
    shadow.SliceCenter = Rect.new(20, 20, 280, 280)
    shadow.BackgroundTransparency = 1
    shadow.Size = UDim2.new(1, 0, 1, 0)
    shadow.Position = UDim2.new(0, 0, 0, 0)
    shadow.ZIndex = 1
    shadow.Parent = shadowContainer

    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 320, 0, 260)
    mainFrame.Position = UDim2.new(0.5, -160, 0.5, -130)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundTransparency = 0
    mainFrame.ZIndex = 2
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 12)
    uiCorner.Parent = mainFrame
    local uiGradient = Instance.new("UIGradient")
    uiGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 30)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 40))
    }
    uiGradient.Parent = mainFrame
    mainFrame.Parent = screenGui

    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 50)
    titleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    titleBar.BorderSizePixel = 0
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = titleBar
    titleBar.Parent = mainFrame

    -- Main title: ak.gg (replaces 'Reanimation')
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(0.7, 0, 1, 0)
    titleLabel.Position = UDim2.new(0.05, 0, 0, 0)
    titleLabel.Text = "AK Reanim"
    titleLabel.TextColor3 = Color3.fromRGB(0, 180, 255)
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.BackgroundTransparency = 1
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.RichText = true
    titleLabel.Parent = titleBar

    -- Per-letter light blue wave animation (looping)
    local baseText = "AK Reanim"
    local baseColor = Color3.fromRGB(200, 160, 255) -- light purple
local waveColor = Color3.fromRGB(255, 105, 180) -- pink

    local waveLength = 2
    local waveSpeed = 4
    local t = 0
    RunService.Heartbeat:Connect(function(dt)
        t = t + dt
        local rich = ""
        for i = 1, #baseText do
            local c = baseText:sub(i, i)
            local phase = (t * waveSpeed - i / waveLength)
            local fade = 0.5 + 0.5 * math.sin(phase)
            local r = math.floor((baseColor.R + (waveColor.R - baseColor.R) * fade) * 255)
            local g = math.floor((baseColor.G + (waveColor.G - baseColor.G) * fade) * 255)
            local b = math.floor((baseColor.B + (waveColor.B - baseColor.B) * fade) * 255)
            local color = string.format("rgb(%d,%d,%d)", r, g, b)
            rich = rich .. string.format('<font color="%s"><b>%s</b></font>', color, c)
        end
        titleLabel.Text = rich
    end)

    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Size = UDim2.new(0, 40, 0, 40)
    minimizeButton.Position = UDim2.new(1, -90, 0, 5)
    minimizeButton.Text = "−"
    minimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    minimizeButton.TextSize = 28
    minimizeButton.Font = Enum.Font.GothamBold
    minimizeButton.BackgroundTransparency = 1
    minimizeButton.Parent = titleBar

    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 40, 0, 40)
    closeButton.Position = UDim2.new(1, -45, 0, 5)
    closeButton.Text = "×"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 28
    closeButton.Font = Enum.Font.GothamBold
    closeButton.BackgroundTransparency = 1
    closeButton.Parent = titleBar

    minimizeButton.MouseEnter:Connect(function()
        minimizeButton.TextColor3 = Color3.fromRGB(0, 191, 255)
    end)
    minimizeButton.MouseLeave:Connect(function()
        minimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    end)

    closeButton.MouseEnter:Connect(function()
        closeButton.TextColor3 = Color3.fromRGB(255, 0, 0)
    end)
    closeButton.MouseLeave:Connect(function()
        closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    end)

    local contentFrame = Instance.new("Frame")
    contentFrame.Size = UDim2.new(0.9, 0, 1, -60)
    contentFrame.Position = UDim2.new(0.05, 0, 0, 60)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = mainFrame

    local animationListGui = createAnimationListGui()
    local customAnimationsGui = createCustomAnimationsGui()

    local lastToggleTime = 0
    local COOLDOWN_DURATION = 3
    local fadeTweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)

    local function createToggleSwitch(name, position, enabled, callback)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 40)
        container.Position = position
        container.BackgroundTransparency = 1
        container.Parent = contentFrame

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.7, 0, 1, 0)
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 255)
        label.TextSize = 16
        label.Font = Enum.Font.GothamBold
        label.BackgroundTransparency = 1
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container

        local toggleFrame = Instance.new("TextButton")
        toggleFrame.Size = UDim2.new(0, 60, 0, 28)
        toggleFrame.Position = UDim2.new(0.82, 0, 0.5, -14)
        toggleFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
        toggleFrame.BorderSizePixel = 0
        toggleFrame.Text = ""
        local toggleCorner = Instance.new("UICorner")
        toggleCorner.CornerRadius = UDim.new(0, 14)
        toggleCorner.Parent = toggleFrame
        toggleFrame.Parent = container

        local toggleFill = Instance.new("Frame")
        toggleFill.Size = UDim2.new(1, 0, 1, 0)
        toggleFill.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
        toggleFill.BorderSizePixel = 0
        toggleFill.BackgroundTransparency = enabled and 0 or 1
        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(0, 14)
        fillCorner.Parent = toggleFill
        toggleFill.Parent = toggleFrame

        local toggleButton = Instance.new("Frame")
        toggleButton.Size = UDim2.new(0, 24, 0, 24)
        toggleButton.Position = UDim2.new(enabled and 0.5 or 0, 2, 0.5, -12)
        toggleButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        toggleButton.BorderSizePixel = 0
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 12)
        buttonCorner.Parent = toggleButton
        local buttonGradient = Instance.new("UIGradient")
        buttonGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.fromRGB(240, 240, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 255))
        }
        buttonGradient.Parent = toggleButton
        toggleButton.Parent = toggleFrame

        local cooldownLabel = Instance.new("TextLabel")
        cooldownLabel.Size = UDim2.new(0, 50, 0, 20)
        cooldownLabel.Position = UDim2.new(0.60, 0, 0.5, -10)
        cooldownLabel.Text = ""
        cooldownLabel.TextColor3 = Color3.fromRGB(150, 150, 255)
        cooldownLabel.TextSize = 16
        cooldownLabel.Font = Enum.Font.GothamMedium
        cooldownLabel.BackgroundTransparency = 1
        cooldownLabel.TextTransparency = 1
        cooldownLabel.TextXAlignment = Enum.TextXAlignment.Right
        cooldownLabel.Parent = container

        local toggleState = enabled
        local tweenInfoToggle = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        local fadeTweenInfoShort = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

        local function updateToggle(state)
            local currentTime = tick()
            if name == "Enable Reanimation" and currentTime - lastToggleTime < COOLDOWN_DURATION then
                return
            end

            toggleState = state
            local targetButtonPos = state and UDim2.new(0.5, 2, 0.5, -12) or UDim2.new(0, 2, 0.5, -12)
            local targetFillTransparency = state and 0 or 1

            TweenService:Create(toggleFill, tweenInfoToggle, {BackgroundTransparency = targetFillTransparency}):Play()
            TweenService:Create(toggleButton, tweenInfoToggle, {Position = targetButtonPos}):Play()

            if callback and name == "Enable Reanimation" then
                lastToggleTime = currentTime
                toggleFill.BackgroundColor3 = Color3.fromRGB(0, 50, 100)
                toggleFrame.AutoButtonColor = false

                local remainingTime = COOLDOWN_DURATION
                local lastNumber = nil

                local function updateCooldownDisplay()
                    local currentNumber = math.ceil(remainingTime)
                    if currentNumber ~= lastNumber then
                        TweenService:Create(cooldownLabel, fadeTweenInfoShort, {TextTransparency = 1}):Play()
                        task.delay(0.3, function()
                            if currentNumber > 0 then
                                cooldownLabel.Text = tostring(currentNumber)
                                TweenService:Create(cooldownLabel, fadeTweenInfoShort, {TextTransparency = 0}):Play()
                            else
                                cooldownLabel.Text = ""
                            end
                        end)
                        lastNumber = currentNumber
                    end
                end

                updateCooldownDisplay()

                local connection
                connection = RunService.Heartbeat:Connect(function(deltaTime)
                    remainingTime = remainingTime - deltaTime
                    updateCooldownDisplay()

                    if remainingTime <= 0 then
                        toggleFill.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
                        toggleFrame.AutoButtonColor = true
                        TweenService:Create(cooldownLabel, fadeTweenInfoShort, {TextTransparency = 1}):Play()
                        task.delay(0.3, function()
                            cooldownLabel.Text = ""
                        end)
                        connection:Disconnect()
                    end
                end)

                callback(state)
            elseif callback then
                callback(state)
            end
        end

        toggleFrame.MouseButton1Click:Connect(function()
            updateToggle(not toggleState)
        end)

        return {
            Container = container,
            ToggleFrame = toggleFrame,
            ToggleButton = toggleButton,
            ToggleFill = toggleFill,
            UpdateToggle = updateToggle,
            GetState = function() return toggleState end
        }
    end

    local reanimationToggle = createToggleSwitch("Enable Reanimation", UDim2.new(0, 0, 0, 0), false, function(state)
        toggleGhost(state)
    end)

    local animationListToggle = createToggleSwitch("Animation List", UDim2.new(0, 0, 0, 50), false, function(state)
        animationListGui.Enabled = state
    end)

    local customAnimationsToggle = createToggleSwitch("Custom Animations", UDim2.new(0, 0, 0, 100), false, function(state)
        customAnimationsGui.Enabled = state
    end)

    local musicToggle = createToggleSwitch("Music", UDim2.new(0, 0, 0, 150), true, function(state)
        musicEnabled = state
    end)

    local originalGuiHeight = mainFrame.Size.Y.Offset
    local minimizedGuiHeight = titleBar.Size.Y.Offset
    local minimized = false
    local tweenInfoFade = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tweenInfoSize = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

    -- Function to update toggle visuals
    local function updateToggleVisuals(toggle)
        local state = toggle.GetState()
        toggle.ToggleFill.BackgroundTransparency = state and 0 or 1
        toggle.ToggleButton.Position = state and UDim2.new(0.5, 2, 0.5, -12) or UDim2.new(0, 2, 0.5, -12)
    end

    local toggles = {reanimationToggle, animationListToggle, customAnimationsToggle, musicToggle}

    local originalTransparencies = {}
    for _, child in pairs(contentFrame:GetDescendants()) do
        if child:IsA("GuiObject") then
            originalTransparencies[child] = {
                BackgroundTransparency = child.BackgroundTransparency,
                TextTransparency = (child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox")) and child.TextTransparency or nil
            }
        end
    end

    minimizeButton.MouseButton1Click:Connect(function()
        minimized = not minimized

        if minimized then
            minimizeButton.Text = "+"
            contentFrame.Visible = false

            for _, child in pairs(contentFrame:GetDescendants()) do
                if child:IsA("GuiObject") then
                    TweenService:Create(child, tweenInfoFade, {BackgroundTransparency = 1}):Play()
                    if child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox") then
                        TweenService:Create(child, tweenInfoFade, {TextTransparency = 1}):Play()
                    end
                end
            end

            local sizeTween = TweenService:Create(
                mainFrame,
                tweenInfoSize,
                {Size = UDim2.new(0, mainFrame.Size.X.Offset, 0, minimizedGuiHeight)}
            )
            sizeTween:Play()
            TweenService:Create(shadowContainer, tweenInfoSize, {
                Size = UDim2.new(0, 332, 0, minimizedGuiHeight + 12),
                Position = UDim2.new(0, mainFrame.Position.X.Offset - 6, 0, mainFrame.Position.Y.Offset - 3)
            }):Play()
            TweenService:Create(shadow, tweenInfoSize, {
                ImageTransparency = 0.25
            }):Play()
        else
            minimizeButton.Text = "−"
            contentFrame.Visible = true

            local sizeTween = TweenService:Create(
                mainFrame,
                tweenInfoSize,
                {Size = UDim2.new(0, mainFrame.Size.X.Offset, 0, originalGuiHeight)}
            )
            sizeTween:Play()
            TweenService:Create(shadowContainer, tweenInfoSize, {
                Size = UDim2.new(0, 352, 0, originalGuiHeight + 31),
                Position = UDim2.new(0, mainFrame.Position.X.Offset - 16, 0, mainFrame.Position.Y.Offset - 16)
            }):Play()
            TweenService:Create(shadow, tweenInfoSize, {
                ImageTransparency = 0.3
            }):Play()

            sizeTween.Completed:Connect(function()
                for _, child in pairs(contentFrame:GetDescendants()) do
                    if child:IsA("GuiObject") then
                        local orig = originalTransparencies[child]
                        if orig then
                            TweenService:Create(child, tweenInfoFade, {BackgroundTransparency = orig.BackgroundTransparency}):Play()
                            if child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox") then
                                TweenService:Create(child, tweenInfoFade, {TextTransparency = orig.TextTransparency}):Play()
                            end
                        end
                    end
                end

                -- Update toggle visuals immediately after maximize
                for _, toggle in ipairs(toggles) do
                    updateToggleVisuals(toggle)
                end

                -- Schedule one-time update 0.1 seconds after maximize
                spawn(function()
                    wait(0.3)
                    if screenGui.Parent and not minimized then
                        for _, toggle in ipairs(toggles) do
                            updateToggleVisuals(toggle)
                        end
                    end
                end)
            end)
        end
    end)

    closeButton.MouseButton1Click:Connect(function()
        -- Stop any ongoing animation and audio
        stopFakeAnimation()

        -- Disable ghost mode if enabled
        if ghostEnabled then
            setGhostEnabled(false)
        end

        -- Disconnect all connections
        if updateConnection then
            updateConnection:Disconnect()
            updateConnection = nil
        end
        if animationState.connection then
            animationState.connection:Disconnect()
            animationState.connection = nil
        end

        -- Destroy all GUIs
        if screenGui then
            screenGui:Destroy()
        end
        if animationListGui then
            animationListGui:Destroy()
        end
        if customAnimationsGui then
            customAnimationsGui:Destroy()
        end

        -- Clear caches
        table.clear(animationCache)
        table.clear(audioCache)
        table.clear(favoriteAnimations)
        table.clear(animationKeybinds)
        table.clear(customAnimations)
        table.clear(ghostOriginalSizes)
        table.clear(ghostOriginalMotorCFrames)
        table.clear(activeNotifications)
        table.clear(preservedGuis)
        table.clear(animationButtons)
        table.clear(customButtons)

        -- Restore head movement if modified
        restoreHeadMovement()

        -- Reset variables
        ghostEnabled = false
        originalCharacter = nil
        ghostClone = nil
        originalCFrame = nil
        originalAnimateScript = nil
        ghostOriginalHipHeight = nil
        currentSound = nil
        musicEnabled = true
        hasFetchedAnimations = false
        hasCreatedFavoritesFile = false
        hasCreatedKeybindsFile = false
        hasCreatedCustomAnimationsFile = false
        originalNeckC0 = nil
        animationState = {
            isRunning = false,
            currentId = nil,
            keyframes = nil,
            totalDuration = 0,
            elapsedTime = 0,
            speed = 1,
            connection = nil
        }

        -- Clear any remaining sounds
        for _, sound in pairs(audioCache) do
            if sound then
                sound:Destroy()
            end
        end

        -- Reset/kill character
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0  -- Kill the character
            end
        end
    end)

    local dragging = false
    local dragOffset = Vector2.new(0, 0)
    local currentTween = nil
    local shadowTween = nil
    local dragConnection
    local trailConnection
    local tweenInfoDrag = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tweenInfoTrail = TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)

    local function createTrailShadow(parent, position, size)
        local trailContainer = Instance.new("Frame")
        trailContainer.BackgroundTransparency = 1
        trailContainer.Size = size
        trailContainer.Position = position
        trailContainer.ZIndex = 0
        trailContainer.Parent = parent
        local trailCorner = Instance.new("UICorner")
        trailCorner.CornerRadius = UDim.new(0, 12)
        trailCorner.Parent = trailContainer

        local trailShadow = Instance.new("ImageLabel")
        trailShadow.Image = "rbxassetid://297774371"
        trailShadow.ImageColor3 = Color3.fromRGB(15, 15, 15)
        trailShadow.ImageTransparency = 0.85
        trailShadow.SliceCenter = Rect.new(20, 20, 280, 280)
        trailShadow.BackgroundTransparency = 1
        trailShadow.Size = UDim2.new(1, 0, 1, 0)
        trailShadow.Position = UDim2.new(0, 0, 0, 0)
        trailShadow.ZIndex = 0
        trailShadow.Parent = trailContainer

        local fadeTween = TweenService:Create(trailShadow, tweenInfoTrail, {ImageTransparency = 1})
        fadeTween:Play()
        fadeTween.Completed:Connect(function()
            trailContainer:Destroy()
        end)
    end

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            local mousePos = UserInputService:GetMouseLocation()
            dragOffset = mousePos - Vector2.new(mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y)
            if dragConnection then dragConnection:Disconnect() end
            if trailConnection then trailConnection:Disconnect() end

            dragConnection = RunService.RenderStepped:Connect(function()
                if not dragging then return end
                local mousePos = UserInputService:GetMouseLocation()
                local targetPos = UDim2.new(0, mousePos.X - dragOffset.X, 0, mousePos.Y - dragOffset.Y)
                local shadowOffsetX = minimized and 6 or 16
                local shadowOffsetY = minimized and 3 or 16
                local shadowPos = UDim2.new(0, mousePos.X - dragOffset.X - shadowOffsetX, 0, mousePos.Y - dragOffset.Y - shadowOffsetY)
                if currentTween then currentTween:Cancel() end
                currentTween = TweenService:Create(mainFrame, tweenInfoDrag, {Position = targetPos})
                currentTween:Play()
                if shadowTween then shadowTween:Cancel() end
                shadowTween = TweenService:Create(shadowContainer, tweenInfoDrag, {Position = shadowPos})
                shadowTween:Play()
            end)

            trailConnection = RunService.Heartbeat:Connect(function()
                if not dragging then return end
                local shadowSize = UDim2.new(0, 352, 0, originalGuiHeight + 31)
                local shadowPos = shadowContainer.Position
                if minimized then
                    shadowSize = UDim2.new(0, 332, 0, minimizedGuiHeight + 12)
                end
                createTrailShadow(screenGui, shadowPos, shadowSize)
                task.wait(0.05) -- Reduced delay for smoother trails
            end)
        end
    end)

    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            if dragConnection then
                dragConnection:Disconnect()
            end
            if trailConnection then
                trailConnection:Disconnect()
                trailConnection = nil
            end
            -- Ensure final shadow position aligns with GUI
            local shadowSize = UDim2.new(0, 352, 0, originalGuiHeight + 31)
            local shadowPos = UDim2.new(0, mainFrame.Position.X.Offset - 16, 0, mainFrame.Position.Y.Offset - 16)
            local shadowTransparency = 0.3
            if minimized then
                shadowSize = UDim2.new(0, 332, 0, minimizedGuiHeight + 12)
                shadowPos = UDim2.new(0, mainFrame.Position.X.Offset - 6, 0, mainFrame.Position.Y.Offset - 3)
                shadowTransparency = 0.25
            end
            shadowContainer.Size = shadowSize
            shadowContainer.Position = shadowPos
            shadow.ImageTransparency = shadowTransparency
        end
    end)

    return screenGui, mainFrame, shadowContainer
end

-- Hide the main GUI initially
-- mainGui.Enabled = false

-- Fade-in function for the GUI
local function fadeInGui(gui, duration, mainFrame, shadowContainer, finalMainPos, finalShadowPos)
    -- Store original transparencies for restoration
    local originalTransparencies = {}
    -- Set initial transparency for all GUI elements
    for _, obj in pairs(gui:GetDescendants()) do
        if obj:IsA("GuiObject") then
            originalTransparencies[obj] = {
                BackgroundTransparency = obj.BackgroundTransparency,
                TextTransparency = (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.TextTransparency or nil,
                ImageTransparency = obj:IsA("ImageLabel") and obj.ImageTransparency or nil
            }
            -- Set to fully transparent initially
            obj.BackgroundTransparency = 1
            if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
                obj.TextTransparency = 1
            end
            if obj:IsA("ImageLabel") then
                obj.ImageTransparency = 1
            end
        end
    end
    -- Set initial positions to the right of the screen for slide-in
    if mainFrame and finalMainPos then
        mainFrame.Position = UDim2.new(1, 100, finalMainPos.Y.Scale, finalMainPos.Y.Offset)
    end
    if shadowContainer and finalShadowPos then
        shadowContainer.Position = UDim2.new(1, 100, finalShadowPos.Y.Scale, finalShadowPos.Y.Offset)
    end
    -- Enable the GUI
    gui.Enabled = true
    -- Create tweens to fade in
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
    for obj, orig in pairs(originalTransparencies) do
        if obj:IsA("GuiObject") then
            local tweenProps = {}
            if orig.BackgroundTransparency ~= nil then
                tweenProps.BackgroundTransparency = orig.BackgroundTransparency
            end
            if orig.TextTransparency ~= nil then
                tweenProps.TextTransparency = orig.TextTransparency
            end
            if orig.ImageTransparency ~= nil then
                tweenProps.ImageTransparency = orig.ImageTransparency
            end
            game:GetService("TweenService"):Create(obj, tweenInfo, tweenProps):Play()
        end
    end
    -- Tween the mainFrame and shadowContainer positions to their final positions
    if mainFrame and finalMainPos then
        game:GetService("TweenService"):Create(mainFrame, tweenInfo, {Position = finalMainPos}):Play()
    end
    if shadowContainer and finalShadowPos then
        game:GetService("TweenService"):Create(shadowContainer, tweenInfo, {Position = finalShadowPos}):Play()
    end
end

-- Modified preloading to fade in GUI after loading
local function initializePreloadingAndShowGui()
    initializePreloading() -- Your existing preloading function
    -- Create the GUIs after preloading
    local animationListGui = createAnimationListGui()
    local customAnimationsGui = createCustomAnimationsGui()
    local mainGui, mainFrame, shadowContainer = createDraggableGui(
        function() return ghostEnabled end,
        setGhostEnabled
    )
    -- Start with GUI disabled and fade it in with slide from top
    mainGui.Enabled = false
    -- Get intended final positions
    local finalMainPos = UDim2.new(0.5, -160, 0.5, -130)
    local finalShadowPos = UDim2.new(0.5, -176, 0.5, -146)
    fadeInGui(mainGui, 0.5, mainFrame, shadowContainer, finalMainPos, finalShadowPos)
end

task.spawn(initializePreloadingAndShowGui)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        for animName, keyCode in pairs(animationKeybinds) do
            if input.KeyCode == keyCode then
                local animId = BuiltInAnimationsR15[animName] or customAnimations[animName] or favoriteAnimations[animName]
                if animId then
                    playFakeAnimation(tostring(animId))
                end
                return
            end
        end
    end
end)

